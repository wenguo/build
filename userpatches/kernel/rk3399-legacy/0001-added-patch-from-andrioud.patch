From 2f61cfcb8b443145ff1d20fe338d769b412a5194 Mon Sep 17 00:00:00 2001
From: Wenguo Liu <liuwenguo@gmail.com>
Date: Fri, 14 Aug 2020 21:31:22 +0800
Subject: [PATCH 1/2] added patch from andrioud

---
 arch/arm64/boot/dts/rockchip/Makefile         |    1 +
 .../rockchip/hm3399-ad-board-edp-linux.dts    |  235 ++
 .../rockchip/hm3399-ad-board-lvds-linux.dts   |  231 ++
 .../boot/dts/rockchip/hm3399-ad-board.dtsi    |  417 ++++
 .../arm64/boot/dts/rockchip/hm3399-board.dtsi |  791 ++++++
 .../arm64/boot/dts/rockchip/hm3399-linux.dtsi |  191 ++
 .../hm3399_v2r0-ad-board-edp-linux.dts        |  235 ++
 .../hm3399_v2r0-ad-board-lvds-linux.dts       |  231 ++
 .../dts/rockchip/hm3399_v2r0-ad-board.dtsi    |  447 ++++
 .../boot/dts/rockchip/hm3399_v2r0-board.dtsi  |  791 ++++++
 .../boot/dts/rockchip/hm3399_v2r0-linux.dtsi  |  191 ++
 .../arm64/boot/dts/rockchip/rk3399-hm3399.dts |  235 ++
 arch/arm64/boot/dts/rockchip/rk3399.dtsi      |   13 +-
 arch/arm64/configs/hm3399_linux_defconfig     |  566 +++++
 .../arm64/configs/hm3399_v2r0_linux_defconfig |  561 +++++
 drivers/gpu/drm/rockchip/Kconfig              |    8 +
 drivers/gpu/drm/rockchip/Makefile             |    1 +
 drivers/gpu/drm/rockchip/rockchip_drm_dsi.c   | 2133 +++++++++++++++++
 drivers/mfd/Kconfig                           |    6 +
 drivers/mfd/rk808.c                           |   26 +
 drivers/misc/5v_en.c                          |  156 ++
 drivers/misc/Kconfig                          |    8 +
 drivers/misc/Makefile                         |    1 +
 .../net/ethernet/stmicro/stmmac/dwmac-rk.c    |   10 +
 drivers/net/ethernet/stmicro/stmmac/stmmac.h  |    2 +
 .../net/ethernet/stmicro/stmmac/stmmac_main.c |   43 +
 .../wireless/rockchip_wlan/rtl8723bu/Makefile |    6 +-
 .../rtl8723bu/os_dep/linux/rtw_android.c      |    8 +-
 drivers/rtc/rtc-hym8563.c                     |   39 +-
 drivers/spi/Kconfig                           |    9 +
 drivers/spi/Makefile                          |    3 +
 drivers/spi/wk2xxx.h                          |  176 ++
 drivers/spi/wk2xxx_spi.c                      | 1784 ++++++++++++++
 hm3399_mkernel.sh                             |    6 +
 hm3399_v2r0_mkernel.sh                        |    6 +
 hm3399_v2r0_mkernel_for_edp.sh                |    6 +
 include/linux/mfd/rk808.h                     |    5 +
 sound/soc/codecs/Kconfig                      |    5 +
 sound/soc/codecs/Makefile                     |    2 +
 sound/soc/codecs/es8388.c                     |  932 +++++++
 sound/soc/codecs/es8388.h                     |   81 +
 41 files changed, 10572 insertions(+), 26 deletions(-)
 create mode 100755 arch/arm64/boot/dts/rockchip/hm3399-ad-board-edp-linux.dts
 create mode 100755 arch/arm64/boot/dts/rockchip/hm3399-ad-board-lvds-linux.dts
 create mode 100755 arch/arm64/boot/dts/rockchip/hm3399-ad-board.dtsi
 create mode 100755 arch/arm64/boot/dts/rockchip/hm3399-board.dtsi
 create mode 100755 arch/arm64/boot/dts/rockchip/hm3399-linux.dtsi
 create mode 100755 arch/arm64/boot/dts/rockchip/hm3399_v2r0-ad-board-edp-linux.dts
 create mode 100755 arch/arm64/boot/dts/rockchip/hm3399_v2r0-ad-board-lvds-linux.dts
 create mode 100755 arch/arm64/boot/dts/rockchip/hm3399_v2r0-ad-board.dtsi
 create mode 100755 arch/arm64/boot/dts/rockchip/hm3399_v2r0-board.dtsi
 create mode 100755 arch/arm64/boot/dts/rockchip/hm3399_v2r0-linux.dtsi
 create mode 100755 arch/arm64/boot/dts/rockchip/rk3399-hm3399.dts
 mode change 100644 => 100755 arch/arm64/boot/dts/rockchip/rk3399.dtsi
 create mode 100755 arch/arm64/configs/hm3399_linux_defconfig
 create mode 100755 arch/arm64/configs/hm3399_v2r0_linux_defconfig
 mode change 100644 => 100755 drivers/gpu/drm/rockchip/Kconfig
 mode change 100644 => 100755 drivers/gpu/drm/rockchip/Makefile
 create mode 100755 drivers/gpu/drm/rockchip/rockchip_drm_dsi.c
 mode change 100644 => 100755 drivers/mfd/Kconfig
 mode change 100644 => 100755 drivers/mfd/rk808.c
 create mode 100755 drivers/misc/5v_en.c
 mode change 100644 => 100755 drivers/misc/Kconfig
 mode change 100644 => 100755 drivers/misc/Makefile
 mode change 100644 => 100755 drivers/net/ethernet/stmicro/stmmac/dwmac-rk.c
 mode change 100644 => 100755 drivers/net/ethernet/stmicro/stmmac/stmmac.h
 mode change 100644 => 100755 drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
 mode change 100644 => 100755 drivers/net/wireless/rockchip_wlan/rtl8723bu/Makefile
 mode change 100644 => 100755 drivers/rtc/rtc-hym8563.c
 mode change 100644 => 100755 drivers/spi/Kconfig
 mode change 100644 => 100755 drivers/spi/Makefile
 create mode 100755 drivers/spi/wk2xxx.h
 create mode 100755 drivers/spi/wk2xxx_spi.c
 create mode 100755 hm3399_mkernel.sh
 create mode 100755 hm3399_v2r0_mkernel.sh
 create mode 100755 hm3399_v2r0_mkernel_for_edp.sh
 mode change 100644 => 100755 include/linux/mfd/rk808.h
 mode change 100644 => 100755 sound/soc/codecs/Kconfig
 mode change 100644 => 100755 sound/soc/codecs/Makefile
 create mode 100755 sound/soc/codecs/es8388.c
 create mode 100755 sound/soc/codecs/es8388.h

diff --git a/arch/arm64/boot/dts/rockchip/Makefile b/arch/arm64/boot/dts/rockchip/Makefile
index 2c3a023a..3c4fcb21 100644
--- a/arch/arm64/boot/dts/rockchip/Makefile
+++ b/arch/arm64/boot/dts/rockchip/Makefile
@@ -14,6 +14,7 @@ dtb-$(CONFIG_ARCH_ROCKCHIP) += \
 	rk3399-nanopi4-rev21.dtb \
 	rk3399-nanopi-m4v2.dtb \
 	rk3399-nanopi4-rev22.dtb \
+	rk3399-hm3399.dtb \
 	rk3399-helios64.dtb \
 	rk3399-firefly.dtb \
 	rk3399-roc-pc.dtb
diff --git a/arch/arm64/boot/dts/rockchip/hm3399-ad-board-edp-linux.dts b/arch/arm64/boot/dts/rockchip/hm3399-ad-board-edp-linux.dts
new file mode 100755
index 00000000..75ff3645
--- /dev/null
+++ b/arch/arm64/boot/dts/rockchip/hm3399-ad-board-edp-linux.dts
@@ -0,0 +1,235 @@
+/*
+ * Copyright (c) 2019 Fuzhou Rockchip Electronics Co., Ltd
+ *
+ * This file is dual-licensed: you can use it either under the terms
+ * of the GPL or the X11 license, at your option. Note that this dual
+ * licensing only applies to this file, and not this project as a
+ * whole.
+ *
+ *  a) This file is free software; you can redistribute it and/or
+ *     modify it under the terms of the GNU General Public License as
+ *     published by the Free Software Foundation; either version 2 of the
+ *     License, or (at your option) any later version.
+ *
+ *     This file is distributed in the hope that it will be useful,
+ *     but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *     GNU General Public License for more details.
+ *
+ * Or, alternatively,
+ *
+ *  b) Permission is hereby granted, free of charge, to any person
+ *     obtaining a copy of this software and associated documentation
+ *     files (the "Software"), to deal in the Software without
+ *     restriction, including without limitation the rights to use,
+ *     copy, modify, merge, publish, distribute, sublicense, and/or
+ *     sell copies of the Software, and to permit persons to whom the
+ *     Software is furnished to do so, subject to the following
+ *     conditions:
+ *
+ *     The above copyright notice and this permission notice shall be
+ *     included in all copies or substantial portions of the Software.
+ *
+ *     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ *     EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
+ *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ *     NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+ *     HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ *     WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ *     FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ *     OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+/dts-v1/;
+
+#include "hm3399-ad-board.dtsi"
+#include "hm3399-linux.dtsi"
+#include <dt-bindings/input/input.h>
+
+/ {
+	model = "Rockchip RK3399 Excavator Board (Linux Opensource)";
+	compatible = "rockchip,hm3399-ad-board-edp-linux", "rockchip,rk3399";
+
+	vcc_lcd: vcc-lcd {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc_lcd";
+		gpio = <&gpio1 3 GPIO_ACTIVE_HIGH>; 
+		startup-delay-us = <10000>;
+		enable-active-high;
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		regulator-boot-on;
+		vin-supply = <&vcc5v0_sys>;
+	};
+
+	vccadc_ref: vccadc-ref {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc1v8_sys";
+		regulator-always-on;
+		regulator-boot-on;
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+	};
+
+	panel: panel {
+		compatible = "simple-panel";
+		backlight = <&backlight>;
+		power-supply = <&vcc_lcd>;
+//		enable-gpios = <&gpio4 21 GPIO_ACTIVE_HIGH>;
+		prepare-delay-ms = <150>;
+		enable-delay-ms = <20>;
+//		pinctrl-0 = <&lcd_en>;
+
+		display-timings {
+			native-mode = <&timing0>;
+
+			timing0: timing0 {
+				clock-frequency = <140000000>;
+				hactive = <1920>;
+				vactive = <1080>;
+				hback-porch = <80>;
+				hfront-porch = <48>;
+				vback-porch = <23>;
+				vfront-porch = <3>;
+				hsync-len = <32>;
+				vsync-len = <5>;
+				hsync-active = <0>;
+				vsync-active = <0>;
+				de-active = <0>;
+				pixelclk-active = <0>;
+			};
+		};
+
+		ports {
+			panel_in: endpoint {
+				remote-endpoint = <&edp_out>;
+			};
+		};
+	};
+
+//	ext_cam_clk: external-camera-clock {
+//		compatible = "fixed-clock";
+//		clock-frequency = <27000000>;
+//		clock-output-names = "CLK_CAMERA_27MHZ";
+//		#clock-cells = <0>;
+//	};
+
+	test_power: test-power {
+		status = "okay";
+	};
+};
+
+&backlight {
+	status = "okay";
+	pwms = <&pwm1 0 25000 0>;
+//	enable-gpios = <&gpio4 22 GPIO_ACTIVE_HIGH>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&lcd_en>;
+	enable-gpios = <&gpio4 21 GPIO_ACTIVE_HIGH>;
+};
+
+&pwm1 {
+	status = "okay";
+};
+
+&display_subsystem {
+	status = "okay";
+};
+
+&edp {
+	status = "okay";
+	force-hpd;
+
+	ports {
+		port@1 {
+			reg = <1>;
+
+			edp_out: endpoint {
+				remote-endpoint = <&panel_in>;
+			};
+		};
+	};
+};
+
+&edp_in_vopb {
+	status = "disabled";
+};
+
+&hdmi {
+	pinctrl-names = "default";
+	pinctrl-0 = <&hdmi_i2c_xfer>, <&hdmi_cec>;
+	#address-cells = <1>;
+	#size-cells = <0>;
+	#sound-dai-cells = <0>;
+	status = "okay";
+};
+
+&hdmi_in_vopl {
+	status = "disabled";
+};
+
+&i2c1 {
+	status = "okay";
+};
+
+&i2c4 {
+	status = "okay";
+};
+
+&isp0_mmu {
+	status = "okay";
+};
+
+&isp1_mmu {
+	status = "okay";
+};
+
+&pcie_phy {
+	status = "okay";
+};
+
+&pcie0 {
+	status = "okay";
+};
+
+&route_edp {
+	status = "okay";
+};
+
+
+
+&saradc {
+	vref-supply = <&vccadc_ref>;
+};
+
+&vopb {
+	assigned-clocks = <&cru DCLK_VOP0_DIV>;
+	assigned-clock-parents = <&cru PLL_CPLL>;
+	status = "okay";
+};
+
+&vopb_mmu {
+	status = "okay";
+};
+
+&vopl {
+	assigned-clocks = <&cru DCLK_VOP0_DIV>;
+	assigned-clock-parents = <&cru PLL_CPLL>;
+	status = "okay";
+};
+
+&vopl_mmu {
+	status = "okay";
+};
+
+&pinctrl {
+	lcd-panel {
+		lcd_en: lcd-en {
+			rockchip,pins = <4 21 RK_FUNC_GPIO &pcfg_pull_up>;
+		};
+	};
+};
+
+/* DON'T PUT ANYTHING BELOW HERE.  PUT IT ABOVE PINCTRL */
+/* DON'T PUT ANYTHING BELOW HERE.  PUT IT ABOVE PINCTRL */
+/* DON'T PUT ANYTHING BELOW HERE.  PUT IT ABOVE PINCTRL */
diff --git a/arch/arm64/boot/dts/rockchip/hm3399-ad-board-lvds-linux.dts b/arch/arm64/boot/dts/rockchip/hm3399-ad-board-lvds-linux.dts
new file mode 100755
index 00000000..605c3535
--- /dev/null
+++ b/arch/arm64/boot/dts/rockchip/hm3399-ad-board-lvds-linux.dts
@@ -0,0 +1,231 @@
+/*
+ * Copyright (c) 2016 Fuzhou Rockchip Electronics Co., Ltd
+ *
+ * This file is dual-licensed: you can use it either under the terms
+ * of the GPL or the X11 license, at your option. Note that this dual
+ * licensing only applies to this file, and not this project as a
+ * whole.
+ *
+ *  a) This file is free software; you can redistribute it and/or
+ *     modify it under the terms of the GNU General Public License as
+ *     published by the Free Software Foundation; either version 2 of the
+ *     License, or (at your option) any later version.
+ *
+ *     This file is distributed in the hope that it will be useful,
+ *     but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *     GNU General Public License for more details.
+ *
+ * Or, alternatively,
+ *
+ *  b) Permission is hereby granted, free of charge, to any person
+ *     obtaining a copy of this software and associated documentation
+ *     files (the "Software"), to deal in the Software without
+ *     restriction, including without limitation the rights to use,
+ *     copy, modify, merge, publish, distribute, sublicense, and/or
+ *     sell copies of the Software, and to permit persons to whom the
+ *     Software is furnished to do so, subject to the following
+ *     conditions:
+ *
+ *     The above copyright notice and this permission notice shall be
+ *     included in all copies or substantial portions of the Software.
+ *
+ *     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ *     EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
+ *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ *     NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+ *     HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ *     WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ *     FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ *     OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+/dts-v1/;
+
+#include "hm3399-ad-board.dtsi"
+#include "hm3399-linux.dtsi"
+#include <dt-bindings/input/input.h>
+
+/ {
+	model = "Rockchip RK3399 Excavator Board edp (Android)";
+	compatible = "rockchip,hm3399-ad-board-lvds-linux", "rockchip,rk3399";
+	vcc_lcd: vcc-lcd {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc_lcd";
+		gpio = <&gpio4 26 GPIO_ACTIVE_HIGH>;  //lcd_3v3_en gpio1_A3
+		startup-delay-us = <20000>;
+		enable-active-high;
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		regulator-boot-on;
+		vin-supply = <&vcc5v0_sys>;
+		status = "okay";
+	};
+	
+	vccadc_ref: vccadc-ref {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc1v8_sys";
+		regulator-always-on;
+		regulator-boot-on;
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+	};
+	
+};
+
+&dsi {
+	compatible = "rockchip,rk3399-dsi";
+	status = "okay";
+
+	panel@0 {
+		compatible = "simple-panel-dsi";
+		reg = <0>;
+		backlight = <&backlight>;
+		power-supply = <&vcc_lcd>;
+
+		dsi,flags = <(MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_BURST |
+			      MIPI_DSI_MODE_LPM | MIPI_DSI_MODE_EOT_PACKET)>;
+		dsi,format = <MIPI_DSI_FMT_RGB888>;
+		dsi,lanes = <4>;
+
+	panel-init-sequence = [
+ 			29 00 06 14 01 08 00 00 00
+ 			29 00 06 3c 01 0c 00 0a 00
+ 			29 00 06 64 01 0c 00 00 00
+ 			29 00 06 68 01 0c 00 00 00
+ 			29 00 06 6c 01 0c 00 00 00
+ 			29 00 06 70 01 0c 00 00 00
+ 			29 00 06 34 01 1f 00 00 00
+ 			29 00 06 10 02 1f 00 00 00
+ 			29 00 06 04 01 01 00 00 00
+ 			29 00 06 04 02 01 00 00 00
+ 			29 00 06 50 04 00 01 f0 03
+ 			29 00 06 54 04 14 00 64 00
+ 			29 00 06 58 04 80 07 a0 00
+ 			29 00 06 5c 04 0a 00 19 00
+ 			29 00 06 60 04 38 04 0a 00
+ 			29 00 06 64 04 01 00 00 00
+ 			29 00 06 a0 04 06 c0 00 00
+ 			29 00 06 04 05 04 00 00 00
+ 			29 00 06 80 04 00 01 02 03
+ 			29 00 06 84 04 04 07 05 08
+ 			29 00 06 88 04 09 0a 0e 0f
+ 			29 00 06 8c 04 0b 0c 0d 10
+ 			29 00 06 90 04 16 17 11 12
+ 			29 00 06 94 04 13 14 15 1b
+ 			29 14 06 98 04 18 19 1a 06
+ 			29 78 06 9c 04 33 04 00 00
+ 		];
+
+ 		display-timings {
+ 			native-mode = <&timing0>;
+
+ 			timing0: timing0 {
+ 				clock-frequency = <148500000>;
+ 				hactive = <1920>;
+ 				vactive = <1080>;
+ 				hback-porch = <100>;
+ 				hsync-len = <20>;
+ 				hfront-porch = <160>;
+ 				vback-porch = <25>;
+ 				vfront-porch = <10>;
+ 				vsync-len = <10>;
+ 				hsync-active = <0>;
+ 				vsync-active = <0>;
+ 				de-active = <0>;
+ 				pixelclk-active = <0>;
+ 			};
+ 		};
+	};
+};
+
+&dsi {
+	compatible = "rockchip,rk3399-dsi";
+	prepare-delay-ms = <50>;
+	enable-delay-ms = <50>;
+	enable-gpios = <&gpio1 4 GPIO_ACTIVE_HIGH>;//LVDS_PWR_EN
+	reset-gpios = <&gpio4 25 GPIO_ACTIVE_LOW>;//LVDS_RESX
+//	snps,bit-rate-per-lane = <320000000>;	// 900Mbps
+	status = "okay";
+};
+
+
+&backlight {
+	status = "okay";
+	pwms = <&pwm0 0 25000 0>;
+	enable-gpios = <&gpio4 30 GPIO_ACTIVE_HIGH>;  //edp_lcdbl gpio4_c6
+};
+
+&pwm0 {	
+	status = "okay";
+};
+
+&route_dsi{
+	status = "disabled";
+};
+
+&hdmi_in_vopb {
+	status = "disabled";
+};
+
+&dsi_in_vopl {
+	status = "disabled";
+};
+
+&route_hdmi { 
+	status = "disabled"; 
+};
+
+&hdmi_sound {
+	status = "okay";
+};
+
+&hdmi {
+	pinctrl-names = "default";
+	pinctrl-0 = <&hdmi_i2c_xfer>, <&hdmi_cec>;
+	#address-cells = <1>;
+	#size-cells = <0>;
+	#sound-dai-cells = <0>;
+	status = "okay";
+};
+
+&vopb_mmu {
+	status = "okay";
+};
+
+&vopl_mmu {
+	status = "okay";
+};
+
+&saradc {
+	vref-supply = <&vccadc_ref>;
+};
+
+&vopb {
+	assigned-clocks = <&cru DCLK_VOP0_DIV>;
+	assigned-clock-parents = <&cru PLL_CPLL>;
+	status = "okay";
+};
+
+&vopl {
+	assigned-clocks = <&cru DCLK_VOP1_DIV>;
+	assigned-clock-parents = <&cru PLL_VPLL>;
+	status = "okay";
+};
+
+&pinctrl {
+	lcd-panel {
+		lcd_panel_lvds_pwr_en: lcd-panel-lvds-pwr-en {
+			rockchip,pins = <1 4 RK_FUNC_GPIO &pcfg_pull_down>;
+		};
+
+		lcd_panel_pwr_en: lcd-panel-pwr-en {
+			rockchip,pins = <4 26 RK_FUNC_GPIO &pcfg_pull_down>;
+		};
+	
+		lcd_panel_reset: lcd-panel-reset {
+			rockchip,pins = <4 25 RK_FUNC_GPIO &pcfg_pull_up>;
+		};
+	};
+};
+
diff --git a/arch/arm64/boot/dts/rockchip/hm3399-ad-board.dtsi b/arch/arm64/boot/dts/rockchip/hm3399-ad-board.dtsi
new file mode 100755
index 00000000..53bc62cd
--- /dev/null
+++ b/arch/arm64/boot/dts/rockchip/hm3399-ad-board.dtsi
@@ -0,0 +1,417 @@
+/*
+ * Copyright (c) 2016 Fuzhou Rockchip Electronics Co., Ltd
+ *
+ * This file is dual-licensed: you can use it either under the terms
+ * of the GPL or the X11 license, at your option. Note that this dual
+ * licensing only applies to this file, and not this project as a
+ * whole.
+ *
+ *  a) This file is free software; you can redistribute it and/or
+ *     modify it under the terms of the GNU General Public License as
+ *     published by the Free Software Foundation; either version 2 of the
+ *     License, or (at your option) any later version.
+ *
+ *     This file is distributed in the hope that it will be useful,
+ *     but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *     GNU General Public License for more details.
+ *
+ * Or, alternatively,
+ *
+ *  b) Permission is hereby granted, free of charge, to any person
+ *     obtaining a copy of this software and associated documentation
+ *     files (the "Software"), to deal in the Software without
+ *     restriction, including without limitation the rights to use,
+ *     copy, modify, merge, publish, distribute, sublicense, and/or
+ *     sell copies of the Software, and to permit persons to whom the
+ *     Software is furnished to do so, subject to the following
+ *     conditions:
+ *
+ *     The above copyright notice and this permission notice shall be
+ *     included in all copies or substantial portions of the Software.
+ *
+ *     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ *     EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
+ *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ *     NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+ *     HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ *     WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ *     FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ *     OTHER DEALINGS IN THE SOFTWARE.
+ */
+#include <dt-bindings/pwm/pwm.h>
+#include <dt-bindings/input/input.h>
+#include "hm3399-board.dtsi"
+
+/ {
+	compatible = "rockchip,rk3399-sapphire-excavator", "rockchip,rk3399";
+	
+	test-power {
+		status = "okay";
+	};
+
+	leds {
+		status = "okay";
+		compatible = "gpio-leds";
+		power_led: power {
+			label = "powerled";
+			linux,default-trigger = "ir-power-click";
+			default-state = "on";
+			gpios = <&gpio2 28 GPIO_ACTIVE_HIGH>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&led_power>;
+		};
+    	};
+
+	es8388_sound{
+		status = "okay";
+		compatible = "simple-audio-card";
+		simple-audio-card,format = "i2s";
+		simple-audio-card,name = "rockchip,es8388-codec";
+		simple-audio-card,mclk-fs = <256>;
+		simple-audio-card,cpu {
+			sound-dai = <&i2s0>;
+			system-clock-frequency = <11289600>;
+		};
+		simple-audio-card,codec {
+			sound-dai = <&es8388>;
+			system-clock-frequency = <11289600>;
+		};
+	};
+	
+
+    	spdif_sound: spdif-sound {
+		status = "disabled";
+		compatible = "simple-audio-card";
+		simple-audio-card,name = "ROCKCHIP,SPDIF";
+		simple-audio-card,cpu {
+			sound-dai = <&spdif>;
+		};
+		simple-audio-card,codec {
+			sound-dai = <&spdif_out>;
+		};
+	};
+
+	spdif_out: spdif-out {
+		status = "disabled";
+		compatible = "linux,spdif-dit";
+		#sound-dai-cells = <0>;
+	};
+
+	sdio_pwrseq: sdio-pwrseq {
+		compatible = "mmc-pwrseq-simple";
+		clocks = <&rk808 1>;
+		clock-names = "ext_clock";
+		pinctrl-names = "default";
+		pinctrl-0 = <&wifi_enable_h>;
+
+		/*
+		 * On the module itself this is one of these (depending
+		 * on the actual card populated):
+		 * - SDIO_RESET_L_WL_REG_ON
+		 * - PDN (power down when low)
+		 */
+		reset-gpios = <&gpio0 10 GPIO_ACTIVE_LOW>; /* GPIO0_B2 */
+	};
+
+	wireless-wlan {
+		compatible = "wlan-platdata";
+		rockchip,grf = <&grf>;
+		wifi_chip_type = "ap6335";
+		sdio_vref = <1800>;
+		WIFI,host_wake_irq = <&gpio0 3 GPIO_ACTIVE_HIGH>; /* GPIO0_a3 */
+		status = "okay";
+	};
+
+	wireless-bluetooth {
+		compatible = "bluetooth-platdata";
+		clocks = <&rk808 1>;
+		clock-names = "ext_clock";
+		//wifi-bt-power-toggle;
+		uart_rts_gpios = <&gpio2 19 GPIO_ACTIVE_LOW>; /* GPIO2_C3 */
+		pinctrl-names = "default", "rts_gpio";
+		pinctrl-0 = <&uart0_rts>;
+		pinctrl-1 = <&uart0_gpios>;
+		//BT,power_gpio  = <&gpio3 19 GPIO_ACTIVE_HIGH>; /* GPIOx_xx */
+		BT,reset_gpio    = <&gpio0 9 GPIO_ACTIVE_HIGH>; /* GPIO0_B1 */
+		BT,wake_gpio     = <&gpio2 26 GPIO_ACTIVE_HIGH>; /* GPIO2_D2 */
+		BT,wake_host_irq = <&gpio0 4 GPIO_ACTIVE_HIGH>; /* GPIO0_A4 */
+		status = "okay";
+	};
+};
+
+&dfi {
+	status = "okay";
+};
+
+&dmc {
+	status = "disabled";
+	center-supply = <&vdd_center>;
+	upthreshold = <40>;
+	downdifferential = <20>;
+	system-status-freq = <
+		/*system status         freq(KHz)*/
+		SYS_STATUS_NORMAL       800000
+		SYS_STATUS_REBOOT       528000
+		SYS_STATUS_SUSPEND      200000
+		SYS_STATUS_VIDEO_1080P  200000
+		SYS_STATUS_VIDEO_4K     600000
+		SYS_STATUS_VIDEO_4K_10B 800000
+		SYS_STATUS_PERFORMANCE  800000
+		SYS_STATUS_BOOST        400000
+		SYS_STATUS_DUALVIEW     600000
+		SYS_STATUS_ISP          600000
+	>;
+	vop-bw-dmc-freq = <
+	/* min_bw(MB/s) max_bw(MB/s) freq(KHz) */
+		0       762      200000
+		763     1893     400000
+		1894    3012     528000
+		3013    99999    800000
+	>;
+	auto-min-freq = <200000>;
+};
+
+
+
+&dmc_opp_table {
+	compatible = "operating-points-v2";
+
+	opp-200000000 {
+		opp-hz = /bits/ 64 <200000000>;
+		opp-microvolt = <900000>;
+		status = "disabled";
+	};
+	opp-300000000 {
+		opp-hz = /bits/ 64 <300000000>;
+		opp-microvolt = <900000>;
+		status = "disabled";
+	};
+	opp-400000000 {
+		opp-hz = /bits/ 64 <400000000>;
+		opp-microvolt = <900000>;
+		status = "disabled";
+	};
+	opp-416000000 {
+		opp-hz = /bits/ 64 <416000000>;
+		opp-microvolt = <900000>;
+	};
+	opp-528000000 {
+		opp-hz = /bits/ 64 <528000000>;
+		opp-microvolt = <900000>;
+		status = "disabled";
+	};
+	opp-600000000 {
+		opp-hz = /bits/ 64 <600000000>;
+		opp-microvolt = <900000>;
+		status = "disabled";
+	};
+	opp-800000000 {
+		opp-hz = /bits/ 64 <800000000>;
+		opp-microvolt = <900000>;
+		status = "disabled";
+	};
+	opp-856000000 {
+		opp-hz = /bits/ 64 <856000000>;
+		opp-microvolt = <900000>;
+	};
+	opp-928000000 {
+		opp-hz = /bits/ 64 <928000000>;
+		opp-microvolt = <900000>;
+		status = "disabled";
+	};
+	opp-1056000000 {
+		opp-hz = /bits/ 64 <1056000000>;
+		opp-microvolt = <900000>;
+		status = "disabled";
+	};
+};
+
+
+&spdif {
+	status = "disabled";
+	pinctrl-0 = <&spdif_bus>;
+	i2c-scl-rising-time-ns = <450>;
+	i2c-scl-falling-time-ns = <15>;
+	#sound-dai-cells = <0>;
+};
+
+
+
+&i2s0 {
+	status = "okay";
+};
+
+&i2c1 {
+	status = "okay";
+	i2c-scl-rising-time-ns = <300>;
+	i2c-scl-falling-time-ns = <15>;
+
+	es8388: es8388@10 {
+		#sound-dai-cells = <0>;
+		compatible = "everest,es8388";
+		reg = <0x10>;
+		clocks = <&cru SCLK_I2S_8CH_OUT>;
+		clock-names = "mclk";
+		pinctrl-names = "default";
+		pinctrl-0 = <&i2s_8ch_mclk &hpdet_int>;
+    	        //pinctrl-0 = <&i2s_8ch_mclk>;
+		spk-con-gpio = <&gpio1 1 GPIO_ACTIVE_LOW>;
+		hp-det-gpio = <&gpio4 24 GPIO_ACTIVE_HIGH>;//insert=GPIO_ACTIVE_HIGH  
+
+		status = "okay";
+	};
+};
+
+
+&i2c3 {
+	status = "disabled";
+};
+
+
+&spi2 {
+	status = "okay";
+	max-freq = <48000000>;   //spi internal clk, don't modify
+	pinctrl-names = "default";  //pinctrl according to you board
+	pinctrl-0 = <&spi2_clk &spi2_tx &spi2_rx &spi2_cs0>;
+	
+	spi_wk2xxx: spi_wk2xxx@00{
+		status = "okay";
+		compatible = "wkmic,wk2124spi";
+		reg = <0x00>;
+		spi-max-frequency = <10000000>;
+		//spi-cpha;      not support
+		//spi-cpol; 	//if the property is here it is 1:clk is high, else 0:clk is low  when idle
+        reset-gpio = <&gpio2 6 GPIO_ACTIVE_HIGH>;//gpio2_a6  todo
+        irq_gpio = <&gpio2 7 IRQ_TYPE_EDGE_FALLING>;//gpio2_a6
+	};
+};
+
+&pwm3 {
+	status = "okay";
+	pinctrl-names = "default";
+	interrupts = <GIC_SPI 61 IRQ_TYPE_LEVEL_HIGH 0>;
+	compatible = "rockchip,remotectl-pwm";
+	remote_pwm_id = <3>;
+	handle_cpu_id = <1>;
+	//remote_support_psci = <1>;
+	
+	ir_key1 {
+		rockchip,usercode = <0xbd02>;
+		rockchip,key_table =
+			<0x31	KEY_REPLY>,
+			<0x2f	KEY_BACK>,
+			<0x35	KEY_UP>,
+			<0x2d	KEY_DOWN>,
+			<0x66	KEY_LEFT>,
+			<0x3e	KEY_RIGHT>,
+			<0x3a	KEY_HOME>,
+			<0xba	KEY_POWER>,
+			<0x29	KEY_MENU>,
+			<0x22	KEY_VOLUMEUP>,
+			<0x73	KEY_VOLUMEDOWN>;
+	};
+
+	ir_key2 {
+		rockchip,usercode = <0xfe01>;
+		rockchip,key_table =
+			<0xec	KEY_ENTER>,
+			<0xe6	KEY_BACK>,
+			<0xe9	KEY_UP>,
+			<0xe5	KEY_DOWN>,
+			<0xae	KEY_LEFT>,
+			<0xaf	KEY_RIGHT>,
+			<0xee	KEY_HOME>,
+			<0xbf	KEY_POWER>,
+			<0xb3	KEY_MENU>,
+			<0x0a	KEY_VOLUMEUP>,
+			<0x0b	KEY_VOLUMEDOWN>,
+
+			<0xb1	KEY_1>,
+			<0xf2	KEY_2>,
+			<0xf3	KEY_3>,
+			<0xb5	KEY_4>,
+			<0xf6	KEY_5>,
+			<0xf7	KEY_6>,
+			<0xb9	KEY_7>,
+			<0xfa	KEY_8>,
+			<0xfb	KEY_9>,
+			<0xfe	KEY_0>,
+
+			<0xbe	KEY_MUTE>,
+			<0xff	388>,
+
+			<0xbd	KEY_BACKSPACE>;
+			
+	};
+
+};
+&uart0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&uart0_xfer &uart0_cts>;
+	status = "okay";
+};
+
+&uart4 {
+	status = "okay";
+};
+
+&saradc {
+	status = "okay";
+};
+
+&rockchip_suspend {
+	status = "okay";
+	rockchip,sleep-debug-en = <1>;
+	rockchip,sleep-mode-config = <
+		(0
+		| RKPM_SLP_ARMPD
+		| RKPM_SLP_PERILPPD
+		| RKPM_SLP_DDR_RET
+		| RKPM_SLP_PLLPD
+		| RKPM_SLP_CENTER_PD
+		| RKPM_SLP_AP_PWROFF
+		)
+		>;
+	rockchip,wakeup-config = <
+		(0
+		| RKPM_GPIO_WKUP_EN
+		| RKPM_PWM_WKUP_EN
+		)
+		>;
+		rockchip,pwm-regulator-config = <
+		(0
+		| PWM2_REGULATOR_EN
+		)
+		>;
+		rockchip,power-ctrl =
+		<&gpio1 17 GPIO_ACTIVE_HIGH>,
+		<&gpio1 14 GPIO_ACTIVE_HIGH>;
+};
+
+&pinctrl {
+	sdio-pwrseq {
+		wifi_enable_h: wifi-enable-h {
+			rockchip,pins =
+				<0 10 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+	};
+
+	wireless-bluetooth {
+		uart0_gpios: uart0-gpios {
+			rockchip,pins =
+				<2 19 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+	};
+	leds {
+		led_power: led-power {
+			rockchip,pins = <2 28 RK_FUNC_GPIO &pcfg_pull_none>;//GPIO2_D4
+		};
+	};
+
+	es8388-gpios{
+		hpdet_int: hpdet-int {
+			rockchip,pins = <4 24 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+	};
+};
diff --git a/arch/arm64/boot/dts/rockchip/hm3399-board.dtsi b/arch/arm64/boot/dts/rockchip/hm3399-board.dtsi
new file mode 100755
index 00000000..ba9408d0
--- /dev/null
+++ b/arch/arm64/boot/dts/rockchip/hm3399-board.dtsi
@@ -0,0 +1,791 @@
+/*
+ * Copyright (c) 2016 Fuzhou Rockchip Electronics Co., Ltd
+ *
+ * This file is dual-licensed: you can use it either under the terms
+ * of the GPL or the X11 license, at your option. Note that this dual
+ * licensing only applies to this file, and not this project as a
+ * whole.
+ *
+ *  a) This file is free software; you can redistribute it and/or
+ *     modify it under the terms of the GNU General Public License as
+ *     published by the Free Software Foundation; either version 2 of the
+ *     License, or (at your option) any later version.
+ *
+ *     This file is distributed in the hope that it will be useful,
+ *     but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *     GNU General Public License for more details.
+ *
+ * Or, alternatively,
+ *
+ *  b) Permission is hereby granted, free of charge, to any person
+ *     obtaining a copy of this software and associated documentation
+ *     files (the "Software"), to deal in the Software without
+ *     restriction, including without limitation the rights to use,
+ *     copy, modify, merge, publish, distribute, sublicense, and/or
+ *     sell copies of the Software, and to permit persons to whom the
+ *     Software is furnished to do so, subject to the following
+ *     conditions:
+ *
+ *     The above copyright notice and this permission notice shall be
+ *     included in all copies or substantial portions of the Software.
+ *
+ *     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ *     EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
+ *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ *     NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+ *     HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ *     WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ *     FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ *     OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include "dt-bindings/pwm/pwm.h"
+#include "rk3399.dtsi"
+#include "rk3399-opp.dtsi"
+
+/ {
+	compatible = "rockchip,rk3399-sapphire", "rockchip,rk3399";
+
+	backlight: backlight {
+		status = "disabled";
+		compatible = "pwm-backlight";
+		pwms = <&pwm0 0 25000 0>;
+		brightness-levels = <
+			  0   1   2   3   4   5   6   7
+			  8   9  10  11  12  13  14  15
+			 16  17  18  19  20  21  22  23
+			 24  25  26  27  28  29  30  31
+			 32  33  34  35  36  37  38  39
+			 40  41  42  43  44  45  46  47
+			 48  49  50  51  52  53  54  55
+			 56  57  58  59  60  61  62  63
+			 64  65  66  67  68  69  70  71
+			 72  73  74  75  76  77  78  79
+			 80  81  82  83  84  85  86  87
+			 88  89  90  91  92  93  94  95
+			 96  97  98  99 100 101 102 103
+			104 105 106 107 108 109 110 111
+			112 113 114 115 116 117 118 119
+			120 121 122 123 124 125 126 127
+			128 129 130 131 132 133 134 135
+			136 137 138 139 140 141 142 143
+			144 145 146 147 148 149 150 151
+			152 153 154 155 156 157 158 159
+			160 161 162 163 164 165 166 167
+			168 169 170 171 172 173 174 175
+			176 177 178 179 180 181 182 183
+			184 185 186 187 188 189 190 191
+			192 193 194 195 196 197 198 199
+			200 201 202 203 204 205 206 207
+			208 209 210 211 212 213 214 215
+			216 217 218 219 220 221 222 223
+			224 225 226 227 228 229 230 231
+			232 233 234 235 236 237 238 239
+			240 241 242 243 244 245 246 247
+			248 249 250 251 252 253 254 255>;
+		default-brightness-level = <200>;
+	};
+
+	clkin_gmac: external-gmac-clock {
+		compatible = "fixed-clock";
+		clock-frequency = <125000000>;
+		clock-output-names = "clkin_gmac";
+		#clock-cells = <0>;
+	};
+
+	dw_hdmi_audio: dw-hdmi-audio {
+		status = "disabled";
+		compatible = "rockchip,dw-hdmi-audio";
+		#sound-dai-cells = <0>;
+	};
+
+	dp_sound: dp-sound {
+		status = "disabled";
+		compatible = "rockchip,cdndp-sound";
+		rockchip,cpu = <&spdif>;
+		rockchip,codec = <&cdn_dp 1>;
+	};
+
+	hdmi_sound: hdmi-sound {
+		status = "disabled";
+		compatible = "simple-audio-card";
+		simple-audio-card,format = "i2s";
+		simple-audio-card,mclk-fs = <256>;
+		simple-audio-card,name = "rockchip,hdmi";
+
+		simple-audio-card,cpu {
+			sound-dai = <&i2s2>;
+		};
+		simple-audio-card,codec {
+			sound-dai = <&hdmi>;
+		};
+	};
+
+	sdio_pwrseq: sdio-pwrseq {
+		compatible = "mmc-pwrseq-simple";
+		clocks = <&rk808 1>;
+		clock-names = "ext_clock";
+		pinctrl-names = "default";
+		pinctrl-0 = <&wifi_enable_h>;
+
+		/*
+		 * On the module itself this is one of these (depending
+		 * on the actual card populated):
+		 * - SDIO_RESET_L_WL_REG_ON
+		 * - PDN (power down when low)
+		 */
+		reset-gpios = <&gpio0 10 GPIO_ACTIVE_LOW>; /* GPIO0_B2 */
+	};
+
+	vcc3v3_sys: vcc3v3-sys {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc3v3_sys";
+		regulator-always-on;
+		regulator-boot-on;
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+	};
+
+	vcc5v0_host: vcc5v0-host-regulator {
+		compatible = "regulator-fixed";
+		gpio = <&gpio4 29 GPIO_ACTIVE_LOW>;//HUB_RST   GPIO4_D5
+		pinctrl-names = "default";
+		pinctrl-0 = <&host_vbus_drv>;
+		regulator-name = "vcc5v0_host";
+		regulator-always-on;
+	};
+
+	vcc5v0_sys: vcc5v0-sys {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc5v0_sys";
+		regulator-always-on;
+		regulator-boot-on;
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+	};
+
+	vcc_sd: vcc-sd {
+		compatible = "regulator-fixed";
+		enable-active-high;
+		gpio = <&gpio0 1 GPIO_ACTIVE_HIGH>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&vcc_sd_h>;
+		regulator-name = "vcc_sd";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+	};
+
+	5v_power_en {
+		compatible = "5v_en";
+		pinctrl-names = "default";
+		pinctrl-0 = <&pwr4g_pin &rst4g_pin>;
+		//hub_rst = <&gpio4 GPIO_D0 GPIO_ACTIVE_LOW>;
+		//pwr_led_en = <&gpio7 GPIO_B4 GPIO_ACTIVE_LOW>;
+		pwr_en_4g = <&gpio1 24 GPIO_ACTIVE_HIGH>;//gpio1_d0
+		rst_4g = <&gpio4 28 GPIO_ACTIVE_HIGH>;//gpio4_d4
+		status = "okay";
+	};
+
+	vdd_log: vdd-log {
+		compatible = "pwm-regulator";
+		pwms = <&pwm2 0 25000 1>;
+		regulator-name = "vdd_log";
+		regulator-min-microvolt = <800000>;
+		regulator-max-microvolt = <1400000>;
+		regulator-always-on;
+		regulator-boot-on;
+
+		/* for rockchip boot on */
+		rockchip,pwm_id= <2>;
+		rockchip,pwm_voltage = <900000>;
+	};
+	
+	vcc3v3_pcie: vcc3v3-pcie-regulator {
+		compatible = "regulator-fixed";
+		enable-active-high;
+		regulator-always-on;
+		regulator-boot-on;
+	//	gpio = <&gpio1 18 GPIO_ACTIVE_HIGH>;
+	//	pinctrl-names = "default";
+	//	pinctrl-0 = <&pcie_drv>;
+		regulator-name = "vcc3v3_pcie";
+	};
+};
+
+&cdn_dp {
+	status = "okay";
+	extcon = <&fusb0>;
+	phys = <&tcphy0_dp>;
+};
+
+&cpu_l0 {
+	cpu-supply = <&vdd_cpu_l>;
+};
+
+&cpu_l1 {
+	cpu-supply = <&vdd_cpu_l>;
+};
+
+&cpu_l2 {
+	cpu-supply = <&vdd_cpu_l>;
+};
+
+&cpu_l3 {
+	cpu-supply = <&vdd_cpu_l>;
+};
+
+&cpu_b0 {
+	cpu-supply = <&vdd_cpu_b>;
+};
+
+&cpu_b1 {
+	cpu-supply = <&vdd_cpu_b>;
+};
+
+&emmc_phy {
+	status = "okay";
+};
+
+&gmac {
+	phy-supply = <&vcc_phy>;
+	phy-mode = "rgmii";
+	clock_in_out = "input";
+	snps,reset-gpio = <&gpio3 15 GPIO_ACTIVE_LOW>;//PHY_RST GPIO3_B7
+	snps,reset-active-low;
+	snps,reset-delays-us = <0 10000 50000>;
+	assigned-clocks = <&cru SCLK_RMII_SRC>;
+	assigned-clock-parents = <&clkin_gmac>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&rgmii_pins>;
+	tx_delay = <0x28>;
+	rx_delay = <0x11>;
+	status = "okay";
+};
+
+&gpu {
+	status = "okay";
+	mali-supply = <&vdd_gpu>;
+};
+
+&i2c0 {
+	status = "okay";
+	i2c-scl-rising-time-ns = <168>;
+	i2c-scl-falling-time-ns = <4>;
+	clock-frequency = <400000>;
+
+	vdd_cpu_b: syr827@40 {
+		compatible = "silergy,syr827";
+		reg = <0x40>;
+		vin-supply = <&vcc5v0_sys>;
+		regulator-compatible = "fan53555-reg";
+		pinctrl-names = "default";
+		pinctrl-0 = <&vsel1_gpio>;
+		vsel-gpios = <&gpio1 17 GPIO_ACTIVE_HIGH>;
+		regulator-name = "vdd_cpu_b";
+		regulator-min-microvolt = <712500>;
+		regulator-max-microvolt = <1500000>;
+		regulator-ramp-delay = <1000>;
+		fcs,suspend-voltage-selector = <1>;
+		regulator-always-on;
+		regulator-boot-on;
+		regulator-initial-state = <3>;
+			regulator-state-mem {
+			regulator-off-in-suspend;
+		};
+	};
+
+	vdd_gpu: syr828@41 {
+		compatible = "silergy,syr828";
+		reg = <0x41>;
+		vin-supply = <&vcc5v0_sys>;
+		regulator-compatible = "fan53555-reg";
+		pinctrl-names = "default";
+		pinctrl-0 = <&vsel2_gpio>;
+		vsel-gpios = <&gpio1 14 GPIO_ACTIVE_HIGH>;
+		regulator-name = "vdd_gpu";
+		regulator-min-microvolt = <712500>;
+		regulator-max-microvolt = <1500000>;
+		regulator-ramp-delay = <1000>;
+		fcs,suspend-voltage-selector = <1>;
+		regulator-always-on;
+		regulator-boot-on;
+		regulator-initial-state = <3>;
+			regulator-state-mem {
+			regulator-off-in-suspend;
+		};
+	};
+
+    hym8563: hym8563@51 {
+            compatible = "haoyu,hym8563";
+            reg = <0x51>;
+            #clock-cells = <0>;
+    };
+
+	rk808: pmic@1b {
+		compatible = "rockchip,rk808";
+		reg = <0x1b>;
+		interrupt-parent = <&gpio1>;
+		interrupts = <21 IRQ_TYPE_LEVEL_LOW>;//PMIC_INT_L GPIO1_C5
+		pinctrl-names = "default";
+		pinctrl-0 = <&pmic_int_l>;
+		rockchip,system-power-controller;
+		wakeup-source;
+		#clock-cells = <1>;
+		clock-output-names = "rk808-clkout1", "rk808-clkout2";
+
+		poweroff_signal-gpios = <&gpio0 11 GPIO_ACTIVE_LOW>;//PWR_EN  GPIO0_B3
+		poweroff,signal-active-low;
+			
+		vcc1-supply = <&vcc3v3_sys>;
+		vcc2-supply = <&vcc3v3_sys>;
+		vcc3-supply = <&vcc3v3_sys>;
+		vcc4-supply = <&vcc3v3_sys>;
+		vcc6-supply = <&vcc3v3_sys>;
+		vcc7-supply = <&vcc3v3_sys>;
+		vcc8-supply = <&vcc3v3_sys>;
+		vcc9-supply = <&vcc3v3_sys>;
+		vcc10-supply = <&vcc3v3_sys>;
+		vcc11-supply = <&vcc3v3_sys>;
+		vcc12-supply = <&vcc3v3_sys>;
+		vddio-supply = <&vcc_3v0>;
+
+		regulators {
+			vdd_center: DCDC_REG1 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <750000>;
+				regulator-max-microvolt = <1350000>;
+				regulator-ramp-delay = <6001>;
+				regulator-name = "vdd_center";
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+
+			vdd_cpu_l: DCDC_REG2 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <750000>;
+				regulator-max-microvolt = <1350000>;
+				regulator-ramp-delay = <6001>;
+				regulator-name = "vdd_cpu_l";
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+
+			vcc_ddr: DCDC_REG3 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-name = "vcc_ddr";
+				regulator-state-mem {
+					regulator-on-in-suspend;
+				};
+			};
+
+			vcc_1v8: DCDC_REG4 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-name = "vcc_1v8";
+				regulator-state-mem {
+					regulator-on-in-suspend;
+					regulator-suspend-microvolt = <1800000>;
+				};
+			};
+
+			vcc1v8_dvp: LDO_REG1 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-name = "vcc1v8_dvp";
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+
+			vcc3v0_tp: LDO_REG2 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <3000000>;
+				regulator-max-microvolt = <3000000>;
+				regulator-name = "vcc3v0_tp";
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+
+			vcc1v8_pmu: LDO_REG3 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-name = "vcc1v8_pmu";
+				regulator-state-mem {
+					regulator-on-in-suspend;
+					regulator-suspend-microvolt = <1800000>;
+				};
+			};
+
+			vccio_sd: LDO_REG4 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <3000000>;
+				regulator-name = "vccio_sd";
+				regulator-state-mem {
+					regulator-on-in-suspend;
+					regulator-suspend-microvolt = <3000000>;
+				};
+			};
+
+			vcc_phy: LDO_REG5 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <3000000>;
+				regulator-max-microvolt = <3000000>;
+				regulator-name = "vcca3v0_codec";
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+
+			vcc_1v5: LDO_REG6 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <1500000>;
+				regulator-max-microvolt = <1500000>;
+				regulator-name = "vcc_1v5";
+				regulator-state-mem {
+					regulator-on-in-suspend;
+					regulator-suspend-microvolt = <1500000>;
+				};
+			};
+
+			vcca1v8_codec: LDO_REG7 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-name = "vcca1v8_codec";
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+
+			vcc_3v0: LDO_REG8 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <3000000>;
+				regulator-max-microvolt = <3000000>;
+				regulator-name = "vcc_3v0";
+				regulator-state-mem {
+					regulator-on-in-suspend;
+					regulator-suspend-microvolt = <3000000>;
+				};
+			};
+
+			vcc3v3_s3: SWITCH_REG1 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-name = "vcc3v3_s3";
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+
+			vcc3v3_s0: SWITCH_REG2 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-name = "vcc3v3_s0";
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+		};
+	};
+};
+
+&i2c4 {
+	status = "okay";
+	i2c-scl-rising-time-ns = <475>;
+	i2c-scl-falling-time-ns = <26>;
+
+	fusb0: fusb30x@22 {
+		compatible = "fairchild,fusb302";
+		reg = <0x22>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&fusb0_int &fusb0_vbus>;
+		int-n-gpios = <&gpio1 2 GPIO_ACTIVE_HIGH>;//GPIO1_A2
+		vbus-5v-gpios = <&gpio1 20 GPIO_ACTIVE_HIGH>;//GPIO1_C4
+		status = "okay";
+	};
+};
+
+&i2s0 {
+	status = "okay";
+	rockchip,i2s-broken-burst-len;
+	rockchip,playback-channels = <8>;
+	rockchip,capture-channels = <8>;
+	#sound-dai-cells = <0>;
+};
+
+&i2s1 {
+	status = "okay";
+	rockchip,i2s-broken-burst-len;
+	rockchip,playback-channels = <8>;
+	rockchip,capture-channels = <8>;
+	#sound-dai-cells = <0>;
+};
+
+&i2s2 {
+	#sound-dai-cells = <0>;
+	status = "okay";
+};
+
+&io_domains {
+	status = "okay";
+
+	bt656-supply = <&vcc_3v0>;		/* bt656_gpio2ab_ms */
+	audio-supply = <&vcca1v8_codec>;	/* audio_gpio3d4a_ms */
+	sdmmc-supply = <&vccio_sd>;		/* sdmmc_gpio4b_ms */
+	gpio1830-supply = <&vcc_3v0>;		/* gpio1833_gpio4cd_ms */
+};
+
+&pcie_phy {
+	status = "disabled";
+};
+
+&pcie0 {
+	assigned-clocks = <&cru SCLK_PCIEPHY_REF>;
+	assigned-clock-parents = <&cru SCLK_PCIEPHY_REF100M>;
+	assigned-clock-rates = <100000000>;
+	//ep-gpios = <&gpio4 25 GPIO_ACTIVE_HIGH>;
+	num-lanes = <4>;
+//	pinctrl-names = "default";
+	//pinctrl-0 = <&pcie_clkreqn>;
+	phy-supply = <&vcc3v3_pcie>;
+	status = "disabled";
+};
+
+&pmu_io_domains {
+	status = "okay";
+	pmu1830-supply = <&vcc_3v0>;
+};
+
+&pwm0 {
+	status = "disabled";
+};
+
+&pwm1 {
+	status = "disabled";
+};
+
+&pwm2 {
+	status = "okay";
+};
+
+&sdhci {
+	bus-width = <8>;
+	mmc-hs400-1_8v;
+	supports-emmc;
+	non-removable;
+	keep-power-in-suspend;
+	mmc-hs400-enhanced-strobe;
+	status = "okay";
+};
+
+&sdio0 {
+	clock-frequency = <50000000>;
+	clock-freq-min-max = <200000 50000000>;
+	supports-sdio;
+	bus-width = <4>;
+	disable-wp;
+	cap-sd-highspeed;
+	cap-sdio-irq;
+	keep-power-in-suspend;
+	mmc-pwrseq = <&sdio_pwrseq>;
+	non-removable;
+	num-slots = <1>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&sdio0_bus4 &sdio0_cmd &sdio0_clk>;
+	sd-uhs-sdr104;
+	status = "okay";
+};
+
+&sdmmc {
+	clock-frequency = <150000000>;
+	clock-freq-min-max = <100000 150000000>;
+	supports-sd;
+	bus-width = <4>;
+	cap-mmc-highspeed;
+	cap-sd-highspeed;
+	disable-wp;
+	num-slots = <1>;
+	//sd-uhs-sdr104;
+	vmmc-supply = <&vcc_sd>;
+	vqmmc-supply = <&vccio_sd>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&sdmmc_clk &sdmmc_cmd &sdmmc_cd &sdmmc_bus4>;
+	status = "okay";
+};
+
+&saradc {
+	status = "okay";
+};
+
+&tcphy0 {
+	extcon = <&fusb0>;
+	status = "okay";
+};
+
+&tcphy1 {
+	status = "okay";
+};
+
+&tsadc {
+	/* tshut mode 0:CRU 1:GPIO */
+	rockchip,hw-tshut-mode = <1>;
+	/* tshut polarity 0:LOW 1:HIGH */
+	rockchip,hw-tshut-polarity = <1>;
+	status = "okay";
+};
+
+&u2phy0 {
+	status = "okay";
+	extcon = <&fusb0>;
+
+	u2phy0_otg: otg-port {
+		status = "okay";
+	};
+
+	u2phy0_host: host-port {
+		phy-supply = <&vcc5v0_host>;
+		status = "okay";
+	};
+};
+
+&u2phy1 {
+	status = "okay";
+
+	u2phy1_otg: otg-port {
+		status = "okay";
+	};
+
+	u2phy1_host: host-port {
+		phy-supply = <&vcc5v0_host>;
+		status = "okay";
+	};
+};
+
+&uart2 {
+	status = "okay";
+};
+
+&uart4 {
+	status = "okay";
+};
+
+&spi1 {
+	status = "disabled";
+};
+
+&spi2 {
+	status = "okay";
+};
+
+
+
+&usbdrd3_0 {
+	status = "okay";
+	extcon = <&fusb0>;
+};
+
+&usbdrd3_1 {
+	status = "okay";
+};
+
+&usbdrd_dwc3_0 {
+	status = "okay";
+};
+
+&usbdrd_dwc3_1 {
+	status = "okay";
+	dr_mode = "host";
+};
+
+&usb_host0_ehci {
+	status = "okay";
+};
+
+&usb_host0_ohci {
+	status = "okay";
+};
+
+&usb_host1_ehci {
+	status = "okay";
+};
+
+&usb_host1_ohci {
+	status = "okay";
+};
+
+&pinctrl {
+	pmic {
+		pmic_int_l: pmic-int-l {
+			rockchip,pins =
+				<1 21 RK_FUNC_GPIO &pcfg_pull_up>;
+		};
+		vsel1_gpio: vsel1-gpio {
+			rockchip,pins =
+				<1 17 RK_FUNC_GPIO &pcfg_pull_down>;
+		};
+		vsel2_gpio: vsel2-gpio {
+			rockchip,pins =
+				<1 14 RK_FUNC_GPIO &pcfg_pull_down>;
+		};
+	};
+
+/*
+    pcie {
+		pcie_drv: pcie-drv {
+			rockchip,pins =
+				<1 18 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+	};
+*/
+	usb2 {
+		host_vbus_drv: host-vbus-drv {
+			rockchip,pins =
+				<4 29 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+	};
+
+	vcc_sd {
+		vcc_sd_h: vcc-sd-h {
+			rockchip,pins =
+				<0 1 RK_FUNC_GPIO &pcfg_pull_up>;
+		};
+	};
+
+	fusb30x {
+		fusb0_int: fusb0-int {
+			rockchip,pins = <1 2 RK_FUNC_GPIO &pcfg_pull_up>;
+		};			
+		fusb0_vbus: fusb0-vbus {
+			rockchip,pins = <1 20 RK_FUNC_GPIO &pcfg_pull_up>;
+		};
+	};
+	five_en {
+		pwr4g_pin: pwr4g-pin {
+			rockchip,pins = <1 24 RK_FUNC_GPIO &pcfg_pull_up>;
+		};
+
+		rst4g_pin: rst4g-pin {
+			rockchip,pins = <4 28 RK_FUNC_GPIO &pcfg_pull_up>;
+		};
+	};
+};
diff --git a/arch/arm64/boot/dts/rockchip/hm3399-linux.dtsi b/arch/arm64/boot/dts/rockchip/hm3399-linux.dtsi
new file mode 100755
index 00000000..955c3aeb
--- /dev/null
+++ b/arch/arm64/boot/dts/rockchip/hm3399-linux.dtsi
@@ -0,0 +1,191 @@
+/*
+ * Copyright (c) 2019 Fuzhou Rockchip Electronics Co., Ltd
+ *
+ * This file is dual-licensed: you can use it either under the terms
+ * of the GPL or the X11 license, at your option. Note that this dual
+ * licensing only applies to this file, and not this project as a
+ * whole.
+ *
+ *  a) This file is free software; you can redistribute it and/or
+ *     modify it under the terms of the GNU General Public License as
+ *     published by the Free Software Foundation; either version 2 of the
+ *     License, or (at your option) any later version.
+ *
+ *     This file is distributed in the hope that it will be useful,
+ *     but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *     GNU General Public License for more details.
+ *
+ * Or, alternatively,
+ *
+ *  b) Permission is hereby granted, free of charge, to any person
+ *     obtaining a copy of this software and associated documentation
+ *     files (the "Software"), to deal in the Software without
+ *     restriction, including without limitation the rights to use,
+ *     copy, modify, merge, publish, distribute, sublicense, and/or
+ *     sell copies of the Software, and to permit persons to whom the
+ *     Software is furnished to do so, subject to the following
+ *     conditions:
+ *
+ *     The above copyright notice and this permission notice shall be
+ *     included in all copies or substantial portions of the Software.
+ *
+ *     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ *     EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
+ *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ *     NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+ *     HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ *     WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ *     FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ *     OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include <dt-bindings/display/drm_mipi_dsi.h>
+#include "rk3399-vop-clk-set.dtsi"
+
+/ {
+	compatible = "rockchip,linux", "rockchip,rk3399";
+
+	chosen {
+		bootargs = "earlycon=uart8250,mmio32,0xff1a0000 swiotlb=1 console=ttyFIQ0 rw root=PARTUUID=614e0000-0000 rootfstype=ext4 rootwait coherent_pool=1m";
+	};
+
+	reserved-memory {
+		#address-cells = <2>;
+		#size-cells = <2>;
+		ranges;
+
+		drm_logo: drm-logo@00000000 {
+			compatible = "rockchip,drm-logo";
+			reg = <0x0 0x0 0x0 0x0>;
+		};
+
+		ramoops_mem: region@110000 {
+			reg = <0x0 0x110000 0x0 0xf0000>;
+			reg-names = "ramoops_mem";
+		};
+	};
+
+	ramoops: ramoops {
+		compatible = "ramoops";
+		record-size = <0x0 0x40000>;
+		console-size = <0x0 0x80000>;
+		ftrace-size = <0x0 0x00000>;
+		pmsg-size = <0x0 0x00000>;
+		memory-region = <&ramoops_mem>;
+	};
+
+	fiq_debugger: fiq-debugger {
+		compatible = "rockchip,fiq-debugger";
+		rockchip,serial-id = <2>;
+		rockchip,signal-irq = <182>;
+		rockchip,wake-irq = <0>;
+		rockchip,irq-mode-enable = <1>;  /* If enable uart uses irq instead of fiq */
+		rockchip,baudrate = <1500000>;  /* Only 115200 and 1500000 */
+		pinctrl-names = "default";
+		pinctrl-0 = <&uart2c_xfer>;
+	};
+
+	rk_key: rockchip-key {
+		compatible = "rockchip,key";
+		status = "okay";
+		io-channels = <&saradc 1>;
+		power-key {
+			gpios = <&gpio0 5 GPIO_ACTIVE_LOW>;
+			linux,code = <116>;
+			label = "power";
+			gpio-key,wakeup;
+		};
+
+	};
+
+	rga: rga@ff680000 {
+		compatible = "rockchip,rga2";
+		dev_mode = <1>;
+		reg = <0x0 0xff680000 0x0 0x1000>;
+		interrupts = <GIC_SPI 55 IRQ_TYPE_LEVEL_HIGH 0>;
+		clocks = <&cru ACLK_RGA>, <&cru HCLK_RGA>, <&cru SCLK_RGA_CORE>;
+		clock-names = "aclk_rga", "hclk_rga", "clk_rga";
+		power-domains = <&power RK3399_PD_RGA>;
+		dma-coherent;
+		status = "okay";
+	};
+};
+
+&display_subsystem {
+	status = "okay";
+
+	ports = <&vopb_out>, <&vopl_out>;
+	logo-memory-region = <&drm_logo>;
+
+	route {
+		route_hdmi: route-hdmi {
+			status = "disabled";
+			logo,uboot = "logo.bmp";
+			logo,kernel = "logo_kernel.bmp";
+			logo,mode = "center";
+			charge_logo,mode = "center";
+			connect = <&vopb_out_hdmi>;
+		};
+
+		route_dsi: route-dsi {
+			status = "disabled";
+			logo,uboot = "logo.bmp";
+			logo,kernel = "logo_kernel.bmp";
+			logo,mode = "center";
+			charge_logo,mode = "center";
+			connect = <&vopb_out_dsi>;
+		};
+
+		route_dsi1: route-dsi1 {
+			status = "disabled";
+			logo,uboot = "logo.bmp";
+			logo,kernel = "logo_kernel.bmp";
+			logo,mode = "center";
+			charge_logo,mode = "center";
+			connect = <&vopl_out_dsi1>;
+		};
+
+		route_edp: route-edp {
+			status = "disabled";
+			logo,uboot = "logo.bmp";
+			logo,kernel = "logo_kernel.bmp";
+			logo,mode = "center";
+			charge_logo,mode = "center";
+			connect = <&vopb_out_edp>;
+		};
+	};
+};
+
+/* HACK: keep MALI version on linux */
+&gpu_power_model {
+	// for DDK r14.
+	voltage = <900>;
+	frequency = <500>;
+	static-power = <300>;
+	dynamic-power = <396>;
+};
+
+&pvtm {
+	status = "okay";
+};
+
+&rkvdec {
+	status = "okay";
+	/* 0 means ion, 1 means drm */
+	//allocator = <0>;
+};
+
+&uart2 {
+	status = "disabled";
+};
+
+&vpu {
+	status = "okay";
+	/* 0 means ion, 1 means drm */
+	//allocator = <0>;
+};
+
+&pinctrl {
+	
+};
diff --git a/arch/arm64/boot/dts/rockchip/hm3399_v2r0-ad-board-edp-linux.dts b/arch/arm64/boot/dts/rockchip/hm3399_v2r0-ad-board-edp-linux.dts
new file mode 100755
index 00000000..1bd0f9b6
--- /dev/null
+++ b/arch/arm64/boot/dts/rockchip/hm3399_v2r0-ad-board-edp-linux.dts
@@ -0,0 +1,235 @@
+/*
+ * Copyright (c) 2019 Fuzhou Rockchip Electronics Co., Ltd
+ *
+ * This file is dual-licensed: you can use it either under the terms
+ * of the GPL or the X11 license, at your option. Note that this dual
+ * licensing only applies to this file, and not this project as a
+ * whole.
+ *
+ *  a) This file is free software; you can redistribute it and/or
+ *     modify it under the terms of the GNU General Public License as
+ *     published by the Free Software Foundation; either version 2 of the
+ *     License, or (at your option) any later version.
+ *
+ *     This file is distributed in the hope that it will be useful,
+ *     but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *     GNU General Public License for more details.
+ *
+ * Or, alternatively,
+ *
+ *  b) Permission is hereby granted, free of charge, to any person
+ *     obtaining a copy of this software and associated documentation
+ *     files (the "Software"), to deal in the Software without
+ *     restriction, including without limitation the rights to use,
+ *     copy, modify, merge, publish, distribute, sublicense, and/or
+ *     sell copies of the Software, and to permit persons to whom the
+ *     Software is furnished to do so, subject to the following
+ *     conditions:
+ *
+ *     The above copyright notice and this permission notice shall be
+ *     included in all copies or substantial portions of the Software.
+ *
+ *     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ *     EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
+ *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ *     NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+ *     HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ *     WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ *     FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ *     OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+/dts-v1/;
+
+#include "hm3399_v2r0-ad-board.dtsi"
+#include "hm3399_v2r0-linux.dtsi"
+#include <dt-bindings/input/input.h>
+
+/ {
+	model = "Rockchip RK3399 Excavator Board (Linux Opensource)";
+	compatible = "rockchip,hm3399-ad-board-edp-linux", "rockchip,rk3399";
+
+	vcc_lcd: vcc-lcd {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc_lcd";
+		gpio = <&gpio1 3 GPIO_ACTIVE_HIGH>; 
+		startup-delay-us = <10000>;
+		enable-active-high;
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		regulator-boot-on;
+		vin-supply = <&vcc5v0_sys>;
+	};
+
+	vccadc_ref: vccadc-ref {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc1v8_sys";
+		regulator-always-on;
+		regulator-boot-on;
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+	};
+
+	panel: panel {
+		compatible = "simple-panel";
+		backlight = <&backlight>;
+		power-supply = <&vcc_lcd>;
+//		enable-gpios = <&gpio4 21 GPIO_ACTIVE_HIGH>;
+		prepare-delay-ms = <150>;
+		enable-delay-ms = <20>;
+//		pinctrl-0 = <&lcd_en>;
+
+		display-timings {
+			native-mode = <&timing0>;
+
+			timing0: timing0 {
+				clock-frequency = <140000000>;
+				hactive = <1920>;
+				vactive = <1080>;
+				hback-porch = <80>;
+				hfront-porch = <48>;
+				vback-porch = <23>;
+				vfront-porch = <3>;
+				hsync-len = <32>;
+				vsync-len = <5>;
+				hsync-active = <0>;
+				vsync-active = <0>;
+				de-active = <0>;
+				pixelclk-active = <0>;
+			};
+		};
+
+		ports {
+			panel_in: endpoint {
+				remote-endpoint = <&edp_out>;
+			};
+		};
+	};
+
+//	ext_cam_clk: external-camera-clock {
+//		compatible = "fixed-clock";
+//		clock-frequency = <27000000>;
+//		clock-output-names = "CLK_CAMERA_27MHZ";
+//		#clock-cells = <0>;
+//	};
+
+	test_power: test-power {
+		status = "okay";
+	};
+};
+
+&backlight {
+	status = "okay";
+	pwms = <&pwm1 0 25000 0>;
+//	enable-gpios = <&gpio4 22 GPIO_ACTIVE_HIGH>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&lcd_en>;
+	enable-gpios = <&gpio4 21 GPIO_ACTIVE_HIGH>;
+};
+
+&pwm1 {
+	status = "okay";
+};
+
+&display_subsystem {
+	status = "okay";
+};
+
+&edp {
+	status = "okay";
+	force-hpd;
+
+	ports {
+		port@1 {
+			reg = <1>;
+
+			edp_out: endpoint {
+				remote-endpoint = <&panel_in>;
+			};
+		};
+	};
+};
+
+&edp_in_vopb {
+	status = "disabled";
+};
+
+&hdmi {
+	pinctrl-names = "default";
+	pinctrl-0 = <&hdmi_i2c_xfer>, <&hdmi_cec>;
+	#address-cells = <1>;
+	#size-cells = <0>;
+	#sound-dai-cells = <0>;
+	status = "okay";
+};
+
+&hdmi_in_vopl {
+	status = "disabled";
+};
+
+&i2c1 {
+	status = "okay";
+};
+
+&i2c4 {
+	status = "okay";
+};
+
+&isp0_mmu {
+	status = "okay";
+};
+
+&isp1_mmu {
+	status = "okay";
+};
+
+&pcie_phy {
+	status = "okay";
+};
+
+&pcie0 {
+	status = "okay";
+};
+
+&route_edp {
+	status = "okay";
+};
+
+
+
+&saradc {
+	vref-supply = <&vccadc_ref>;
+};
+
+&vopb {
+	assigned-clocks = <&cru DCLK_VOP0_DIV>;
+	assigned-clock-parents = <&cru PLL_CPLL>;
+	status = "okay";
+};
+
+&vopb_mmu {
+	status = "okay";
+};
+
+&vopl {
+	assigned-clocks = <&cru DCLK_VOP0_DIV>;
+	assigned-clock-parents = <&cru PLL_CPLL>;
+	status = "okay";
+};
+
+&vopl_mmu {
+	status = "okay";
+};
+
+&pinctrl {
+	lcd-panel {
+		lcd_en: lcd-en {
+			rockchip,pins = <4 21 RK_FUNC_GPIO &pcfg_pull_up>;
+		};
+	};
+};
+
+/* DON'T PUT ANYTHING BELOW HERE.  PUT IT ABOVE PINCTRL */
+/* DON'T PUT ANYTHING BELOW HERE.  PUT IT ABOVE PINCTRL */
+/* DON'T PUT ANYTHING BELOW HERE.  PUT IT ABOVE PINCTRL */
diff --git a/arch/arm64/boot/dts/rockchip/hm3399_v2r0-ad-board-lvds-linux.dts b/arch/arm64/boot/dts/rockchip/hm3399_v2r0-ad-board-lvds-linux.dts
new file mode 100755
index 00000000..4260cb36
--- /dev/null
+++ b/arch/arm64/boot/dts/rockchip/hm3399_v2r0-ad-board-lvds-linux.dts
@@ -0,0 +1,231 @@
+/*
+ * Copyright (c) 2016 Fuzhou Rockchip Electronics Co., Ltd
+ *
+ * This file is dual-licensed: you can use it either under the terms
+ * of the GPL or the X11 license, at your option. Note that this dual
+ * licensing only applies to this file, and not this project as a
+ * whole.
+ *
+ *  a) This file is free software; you can redistribute it and/or
+ *     modify it under the terms of the GNU General Public License as
+ *     published by the Free Software Foundation; either version 2 of the
+ *     License, or (at your option) any later version.
+ *
+ *     This file is distributed in the hope that it will be useful,
+ *     but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *     GNU General Public License for more details.
+ *
+ * Or, alternatively,
+ *
+ *  b) Permission is hereby granted, free of charge, to any person
+ *     obtaining a copy of this software and associated documentation
+ *     files (the "Software"), to deal in the Software without
+ *     restriction, including without limitation the rights to use,
+ *     copy, modify, merge, publish, distribute, sublicense, and/or
+ *     sell copies of the Software, and to permit persons to whom the
+ *     Software is furnished to do so, subject to the following
+ *     conditions:
+ *
+ *     The above copyright notice and this permission notice shall be
+ *     included in all copies or substantial portions of the Software.
+ *
+ *     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ *     EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
+ *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ *     NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+ *     HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ *     WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ *     FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ *     OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+/dts-v1/;
+
+#include "hm3399_v2r0-ad-board.dtsi"
+#include "hm3399_v2r0-linux.dtsi"
+#include <dt-bindings/input/input.h>
+
+/ {
+	model = "Rockchip RK3399 Excavator Board edp (Android)";
+	compatible = "rockchip,hm3399-ad-board-lvds-linux", "rockchip,rk3399";
+	vcc_lcd: vcc-lcd {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc_lcd";
+		gpio = <&gpio4 26 GPIO_ACTIVE_HIGH>;  //lcd_3v3_en gpio1_A3
+		startup-delay-us = <20000>;
+		enable-active-high;
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		regulator-boot-on;
+		vin-supply = <&vcc5v0_sys>;
+		status = "okay";
+	};
+	
+	vccadc_ref: vccadc-ref {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc1v8_sys";
+		regulator-always-on;
+		regulator-boot-on;
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+	};
+	
+};
+
+&dsi {
+	compatible = "rockchip,rk3399-dsi";
+	status = "okay";
+
+	panel@0 {
+		compatible = "simple-panel-dsi";
+		reg = <0>;
+		backlight = <&backlight>;
+		power-supply = <&vcc_lcd>;
+
+		dsi,flags = <(MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_BURST |
+			      MIPI_DSI_MODE_LPM | MIPI_DSI_MODE_EOT_PACKET)>;
+		dsi,format = <MIPI_DSI_FMT_RGB888>;
+		dsi,lanes = <4>;
+
+	panel-init-sequence = [
+ 			29 00 06 14 01 08 00 00 00
+ 			29 00 06 3c 01 0c 00 0a 00
+ 			29 00 06 64 01 0c 00 00 00
+ 			29 00 06 68 01 0c 00 00 00
+ 			29 00 06 6c 01 0c 00 00 00
+ 			29 00 06 70 01 0c 00 00 00
+ 			29 00 06 34 01 1f 00 00 00
+ 			29 00 06 10 02 1f 00 00 00
+ 			29 00 06 04 01 01 00 00 00
+ 			29 00 06 04 02 01 00 00 00
+ 			29 00 06 50 04 00 01 f0 03
+ 			29 00 06 54 04 14 00 64 00
+ 			29 00 06 58 04 80 07 a0 00
+ 			29 00 06 5c 04 0a 00 19 00
+ 			29 00 06 60 04 38 04 0a 00
+ 			29 00 06 64 04 01 00 00 00
+ 			29 00 06 a0 04 06 c0 00 00
+ 			29 00 06 04 05 04 00 00 00
+ 			29 00 06 80 04 00 01 02 03
+ 			29 00 06 84 04 04 07 05 08
+ 			29 00 06 88 04 09 0a 0e 0f
+ 			29 00 06 8c 04 0b 0c 0d 10
+ 			29 00 06 90 04 16 17 11 12
+ 			29 00 06 94 04 13 14 15 1b
+ 			29 14 06 98 04 18 19 1a 06
+ 			29 78 06 9c 04 33 04 00 00
+ 		];
+
+ 		display-timings {
+ 			native-mode = <&timing0>;
+
+ 			timing0: timing0 {
+ 				clock-frequency = <148500000>;
+ 				hactive = <1920>;
+ 				vactive = <1080>;
+ 				hback-porch = <100>;
+ 				hsync-len = <20>;
+ 				hfront-porch = <160>;
+ 				vback-porch = <25>;
+ 				vfront-porch = <10>;
+ 				vsync-len = <10>;
+ 				hsync-active = <0>;
+ 				vsync-active = <0>;
+ 				de-active = <0>;
+ 				pixelclk-active = <0>;
+ 			};
+ 		};
+	};
+};
+
+&dsi {
+	compatible = "rockchip,rk3399-dsi";
+	prepare-delay-ms = <50>;
+	enable-delay-ms = <50>;
+	enable-gpios = <&gpio1 4 GPIO_ACTIVE_HIGH>;//LVDS_PWR_EN
+	reset-gpios = <&gpio4 25 GPIO_ACTIVE_LOW>;//LVDS_RESX
+//	snps,bit-rate-per-lane = <320000000>;	// 900Mbps
+	status = "okay";
+};
+
+
+&backlight {
+	status = "okay";
+	pwms = <&pwm0 0 25000 0>;
+	enable-gpios = <&gpio4 30 GPIO_ACTIVE_HIGH>;  //edp_lcdbl gpio4_c6
+};
+
+&pwm0 {	
+	status = "okay";
+};
+
+&route_dsi{
+	status = "disabled";
+};
+
+&hdmi_in_vopb {
+	status = "disabled";
+};
+
+&dsi_in_vopl {
+	status = "disabled";
+};
+
+&route_hdmi { 
+	status = "disabled"; 
+};
+
+&hdmi_sound {
+	status = "okay";
+};
+
+&hdmi {
+	pinctrl-names = "default";
+	pinctrl-0 = <&hdmi_i2c_xfer>, <&hdmi_cec>;
+	#address-cells = <1>;
+	#size-cells = <0>;
+	#sound-dai-cells = <0>;
+	status = "okay";
+};
+
+&vopb_mmu {
+	status = "okay";
+};
+
+&vopl_mmu {
+	status = "okay";
+};
+
+&saradc {
+	vref-supply = <&vccadc_ref>;
+};
+
+&vopb {
+	assigned-clocks = <&cru DCLK_VOP0_DIV>;
+	assigned-clock-parents = <&cru PLL_CPLL>;
+	status = "okay";
+};
+
+&vopl {
+	assigned-clocks = <&cru DCLK_VOP1_DIV>;
+	assigned-clock-parents = <&cru PLL_VPLL>;
+	status = "okay";
+};
+
+&pinctrl {
+	lcd-panel {
+		lcd_panel_lvds_pwr_en: lcd-panel-lvds-pwr-en {
+			rockchip,pins = <1 4 RK_FUNC_GPIO &pcfg_pull_down>;
+		};
+
+		lcd_panel_pwr_en: lcd-panel-pwr-en {
+			rockchip,pins = <4 26 RK_FUNC_GPIO &pcfg_pull_down>;
+		};
+	
+		lcd_panel_reset: lcd-panel-reset {
+			rockchip,pins = <4 25 RK_FUNC_GPIO &pcfg_pull_up>;
+		};
+	};
+};
+
diff --git a/arch/arm64/boot/dts/rockchip/hm3399_v2r0-ad-board.dtsi b/arch/arm64/boot/dts/rockchip/hm3399_v2r0-ad-board.dtsi
new file mode 100755
index 00000000..c594edde
--- /dev/null
+++ b/arch/arm64/boot/dts/rockchip/hm3399_v2r0-ad-board.dtsi
@@ -0,0 +1,447 @@
+/*
+ * Copyright (c) 2016 Fuzhou Rockchip Electronics Co., Ltd
+ *
+ * This file is dual-licensed: you can use it either under the terms
+ * of the GPL or the X11 license, at your option. Note that this dual
+ * licensing only applies to this file, and not this project as a
+ * whole.
+ *
+ *  a) This file is free software; you can redistribute it and/or
+ *     modify it under the terms of the GNU General Public License as
+ *     published by the Free Software Foundation; either version 2 of the
+ *     License, or (at your option) any later version.
+ *
+ *     This file is distributed in the hope that it will be useful,
+ *     but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *     GNU General Public License for more details.
+ *
+ * Or, alternatively,
+ *
+ *  b) Permission is hereby granted, free of charge, to any person
+ *     obtaining a copy of this software and associated documentation
+ *     files (the "Software"), to deal in the Software without
+ *     restriction, including without limitation the rights to use,
+ *     copy, modify, merge, publish, distribute, sublicense, and/or
+ *     sell copies of the Software, and to permit persons to whom the
+ *     Software is furnished to do so, subject to the following
+ *     conditions:
+ *
+ *     The above copyright notice and this permission notice shall be
+ *     included in all copies or substantial portions of the Software.
+ *
+ *     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ *     EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
+ *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ *     NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+ *     HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ *     WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ *     FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ *     OTHER DEALINGS IN THE SOFTWARE.
+ */
+#include <dt-bindings/pwm/pwm.h>
+#include <dt-bindings/input/input.h>
+#include "hm3399_v2r0-board.dtsi"
+
+/ {
+	compatible = "rockchip,rk3399-sapphire-excavator", "rockchip,rk3399";
+	
+	test-power {
+		status = "okay";
+	};
+
+	leds {
+		status = "okay";
+		compatible = "gpio-leds";
+			power_led: power {
+				label = "powerled";
+				linux,default-trigger = "ir-power-click";
+				default-state = "on";
+				gpios = <&gpio1 0 GPIO_ACTIVE_HIGH>;
+				pinctrl-names = "default";
+				pinctrl-0 = <&led_power>;
+			};
+			work_led: work {
+				label = "workled";
+				linux,default-trigger = "ir-power-click";
+				default-state = "off";
+				gpios = <&gpio1 13 GPIO_ACTIVE_HIGH>;
+				pinctrl-names = "default";
+				pinctrl-0 = <&led_work>;
+			};
+    	};
+
+	es8388_sound{
+		status = "okay";
+		compatible = "simple-audio-card";
+		simple-audio-card,format = "i2s";
+		simple-audio-card,name = "rockchip,es8388-codec";
+		simple-audio-card,mclk-fs = <256>;
+		simple-audio-card,cpu {
+			sound-dai = <&i2s0>;
+			system-clock-frequency = <11289600>;
+		};
+		simple-audio-card,codec {
+			sound-dai = <&es8388>;
+			system-clock-frequency = <11289600>;
+		};
+	};
+	
+
+    	spdif_sound: spdif-sound {
+		status = "disabled";
+		compatible = "simple-audio-card";
+		simple-audio-card,name = "ROCKCHIP,SPDIF";
+		simple-audio-card,cpu {
+			sound-dai = <&spdif>;
+		};
+		simple-audio-card,codec {
+			sound-dai = <&spdif_out>;
+		};
+	};
+
+	spdif_out: spdif-out {
+		status = "disabled";
+		compatible = "linux,spdif-dit";
+		#sound-dai-cells = <0>;
+	};
+
+	sdio_pwrseq: sdio-pwrseq {
+		compatible = "mmc-pwrseq-simple";
+		clocks = <&rk808 1>;
+		clock-names = "ext_clock";
+		pinctrl-names = "default";
+		pinctrl-0 = <&wifi_enable_h>;
+
+		/*
+		 * On the module itself this is one of these (depending
+		 * on the actual card populated):
+		 * - SDIO_RESET_L_WL_REG_ON
+		 * - PDN (power down when low)
+		 */
+		reset-gpios = <&gpio2 27 GPIO_ACTIVE_HIGH>; /* GPIO2_D3 */
+	};
+
+	wireless-wlan {
+		compatible = "wlan-platdata";
+		rockchip,grf = <&grf>;
+		wifi_chip_type = "ap6335";
+		sdio_vref = <1800>;
+		WIFI,host_wake_irq = <&gpio0 3 GPIO_ACTIVE_HIGH>; /* GPIO0_a3 */
+		status = "okay";
+	};
+
+	wireless-bluetooth {
+		compatible = "bluetooth-platdata";
+		clocks = <&rk808 1>;
+		clock-names = "ext_clock";
+		//wifi-bt-power-toggle;
+		uart_rts_gpios = <&gpio2 19 GPIO_ACTIVE_LOW>; /* GPIO2_C3 */
+		pinctrl-names = "default", "rts_gpio";
+		pinctrl-0 = <&uart0_rts>;
+		pinctrl-1 = <&uart0_gpios>;
+		//BT,power_gpio  = <&gpio3 19 GPIO_ACTIVE_HIGH>; /* GPIOx_xx */
+		BT,reset_gpio    = <&gpio0 9 GPIO_ACTIVE_HIGH>; /* GPIO0_B1 */
+		BT,wake_gpio     = <&gpio2 26 GPIO_ACTIVE_HIGH>; /* GPIO2_D2 */
+		BT,wake_host_irq = <&gpio0 4 GPIO_ACTIVE_HIGH>; /* GPIO0_A4 */
+		status = "disabled";
+	};
+};
+
+&dfi {
+	status = "okay";
+};
+
+&dmc {
+	status = "disabled";
+	center-supply = <&vdd_center>;
+	upthreshold = <40>;
+	downdifferential = <20>;
+	system-status-freq = <
+		/*system status         freq(KHz)*/
+		SYS_STATUS_NORMAL       800000
+		SYS_STATUS_REBOOT       528000
+		SYS_STATUS_SUSPEND      200000
+		SYS_STATUS_VIDEO_1080P  200000
+		SYS_STATUS_VIDEO_4K     600000
+		SYS_STATUS_VIDEO_4K_10B 800000
+		SYS_STATUS_PERFORMANCE  800000
+		SYS_STATUS_BOOST        400000
+		SYS_STATUS_DUALVIEW     600000
+		SYS_STATUS_ISP          600000
+	>;
+	vop-bw-dmc-freq = <
+	/* min_bw(MB/s) max_bw(MB/s) freq(KHz) */
+		0       762      200000
+		763     1893     400000
+		1894    3012     528000
+		3013    99999    800000
+	>;
+	auto-min-freq = <200000>;
+};
+
+
+
+&dmc_opp_table {
+	compatible = "operating-points-v2";
+
+	opp-200000000 {
+		opp-hz = /bits/ 64 <200000000>;
+		opp-microvolt = <900000>;
+		status = "disabled";
+	};
+	opp-300000000 {
+		opp-hz = /bits/ 64 <300000000>;
+		opp-microvolt = <900000>;
+		status = "disabled";
+	};
+	opp-400000000 {
+		opp-hz = /bits/ 64 <400000000>;
+		opp-microvolt = <900000>;
+		status = "disabled";
+	};
+	opp-416000000 {
+		opp-hz = /bits/ 64 <416000000>;
+		opp-microvolt = <900000>;
+	};
+	opp-528000000 {
+		opp-hz = /bits/ 64 <528000000>;
+		opp-microvolt = <900000>;
+		status = "disabled";
+	};
+	opp-600000000 {
+		opp-hz = /bits/ 64 <600000000>;
+		opp-microvolt = <900000>;
+		status = "disabled";
+	};
+	opp-800000000 {
+		opp-hz = /bits/ 64 <800000000>;
+		opp-microvolt = <900000>;
+		status = "disabled";
+	};
+	opp-856000000 {
+		opp-hz = /bits/ 64 <856000000>;
+		opp-microvolt = <900000>;
+	};
+	opp-928000000 {
+		opp-hz = /bits/ 64 <928000000>;
+		opp-microvolt = <900000>;
+		status = "disabled";
+	};
+	opp-1056000000 {
+		opp-hz = /bits/ 64 <1056000000>;
+		opp-microvolt = <900000>;
+		status = "disabled";
+	};
+};
+
+
+&spdif {
+	status = "disabled";
+	pinctrl-0 = <&spdif_bus>;
+	i2c-scl-rising-time-ns = <450>;
+	i2c-scl-falling-time-ns = <15>;
+	#sound-dai-cells = <0>;
+};
+
+
+
+&i2s0 {
+	status = "okay";
+};
+
+&i2c1 {
+	status = "okay";
+	i2c-scl-rising-time-ns = <300>;
+	i2c-scl-falling-time-ns = <15>;
+
+	es8388: es8388@10 {
+		#sound-dai-cells = <0>;
+		compatible = "everest,es8388";
+		reg = <0x10>;
+		clocks = <&cru SCLK_I2S_8CH_OUT>;
+		clock-names = "mclk";
+		pinctrl-names = "default";
+		pinctrl-0 = <&i2s_8ch_mclk &hpdet_int>;
+    	        //pinctrl-0 = <&i2s_8ch_mclk>;
+		spk-con-gpio = <&gpio1 1 GPIO_ACTIVE_LOW>;
+		hp-det-gpio = <&gpio4 24 GPIO_ACTIVE_HIGH>;//insert=GPIO_ACTIVE_HIGH  
+
+		status = "okay";
+	};
+};
+
+
+&i2c3 {
+	status = "disabled";
+};
+
+
+&spi2 {
+	status = "okay";
+	max-freq = <48000000>;   //spi internal clk, don't modify
+	pinctrl-names = "default";  //pinctrl according to you board
+	pinctrl-0 = <&spi2_clk &spi2_tx &spi2_rx &spi2_cs0>;
+	
+	spi_wk2xxx: spi_wk2xxx@00{
+		status = "okay";
+		compatible = "wkmic,wk2124spi";
+		reg = <0x00>;
+		spi-max-frequency = <10000000>;
+		//spi-cpha;      not support
+		//spi-cpol; 	//if the property is here it is 1:clk is high, else 0:clk is low  when idle
+        reset-gpio = <&gpio2 6 GPIO_ACTIVE_HIGH>;//gpio2_a6  todo
+        irq_gpio = <&gpio2 7 IRQ_TYPE_EDGE_FALLING>;//gpio2_a6
+	};
+};
+
+&pwm3 {
+	status = "okay";
+	pinctrl-names = "default";
+	interrupts = <GIC_SPI 61 IRQ_TYPE_LEVEL_HIGH 0>;
+	compatible = "rockchip,remotectl-pwm";
+	remote_pwm_id = <3>;
+	handle_cpu_id = <1>;
+	//remote_support_psci = <1>;
+	
+	ir_key1 {
+		rockchip,usercode = <0xbd02>;
+		rockchip,key_table =
+			<0x31	KEY_REPLY>,
+			<0x2f	KEY_BACK>,
+			<0x35	KEY_UP>,
+			<0x2d	KEY_DOWN>,
+			<0x66	KEY_LEFT>,
+			<0x3e	KEY_RIGHT>,
+			<0x3a	KEY_HOME>,
+			<0xba	KEY_POWER>,
+			<0x29	KEY_MENU>,
+			<0x22	KEY_VOLUMEUP>,
+			<0x73	KEY_VOLUMEDOWN>;
+	};
+
+	ir_key2 {
+		rockchip,usercode = <0xfe01>;
+		rockchip,key_table =
+			<0xec	KEY_ENTER>,
+			<0xe6	KEY_BACK>,
+			<0xe9	KEY_UP>,
+			<0xe5	KEY_DOWN>,
+			<0xae	KEY_LEFT>,
+			<0xaf	KEY_RIGHT>,
+			<0xee	KEY_HOME>,
+			<0xbf	KEY_POWER>,
+			<0xb3	KEY_MENU>,
+			<0x0a	KEY_VOLUMEUP>,
+			<0x0b	KEY_VOLUMEDOWN>,
+
+			<0xb1	KEY_1>,
+			<0xf2	KEY_2>,
+			<0xf3	KEY_3>,
+			<0xb5	KEY_4>,
+			<0xf6	KEY_5>,
+			<0xf7	KEY_6>,
+			<0xb9	KEY_7>,
+			<0xfa	KEY_8>,
+			<0xfb	KEY_9>,
+			<0xfe	KEY_0>,
+
+			<0xbe	KEY_MUTE>,
+			<0xff	388>,
+
+			<0xbd	KEY_BACKSPACE>;
+			
+	};
+
+	ir_key3 {
+			rockchip,usercode = <0xf700>;
+			rockchip,key_table =
+				<0xf1	KEY_POWER>,
+				<0xf3	KEY_MUTE>,
+				
+				<0xf9	KEY_ENTER>,
+				<0xfe	KEY_UP>,
+				<0xfa	KEY_DOWN>,
+				<0xff	KEY_LEFT>,
+				<0xfd	KEY_RIGHT>,
+				
+				<0xfb	KEY_MENU>,
+				<0xf6	KEY_BACK>,
+				<0xf5	KEY_HOME>,
+				<0xf7	KEY_VOLUMEUP>,
+				<0xf2	KEY_VOLUMEDOWN>;		
+		};
+
+};
+&uart0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&uart0_xfer &uart0_cts>;
+	status = "okay";
+};
+
+&uart4 {
+	status = "okay";
+};
+
+&saradc {
+	status = "okay";
+};
+
+&rockchip_suspend {
+	status = "okay";
+	rockchip,sleep-debug-en = <1>;
+	rockchip,sleep-mode-config = <
+		(0
+		| RKPM_SLP_ARMPD
+		| RKPM_SLP_PERILPPD
+		| RKPM_SLP_DDR_RET
+		| RKPM_SLP_PLLPD
+		| RKPM_SLP_CENTER_PD
+		| RKPM_SLP_AP_PWROFF
+		)
+		>;
+	rockchip,wakeup-config = <
+		(0
+		| RKPM_GPIO_WKUP_EN
+		| RKPM_PWM_WKUP_EN
+		)
+		>;
+		rockchip,pwm-regulator-config = <
+		(0
+		| PWM2_REGULATOR_EN
+		)
+		>;
+		rockchip,power-ctrl =
+		<&gpio1 17 GPIO_ACTIVE_HIGH>,
+		<&gpio1 14 GPIO_ACTIVE_HIGH>;
+};
+
+&pinctrl {
+	sdio-pwrseq {
+		wifi_enable_h: wifi-enable-h {
+			rockchip,pins =
+				<2 27 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+	};
+
+	wireless-bluetooth {
+		uart0_gpios: uart0-gpios {
+			rockchip,pins =
+				<2 19 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+	};
+	leds {
+		led_power: led-power {
+			rockchip,pins = <1 0 RK_FUNC_GPIO &pcfg_pull_none>;//GPIO1_A0
+		};
+		led_work: led-work {
+			rockchip,pins = <1 13 RK_FUNC_GPIO &pcfg_pull_none>;//GPIO1_B5
+		};
+	};
+
+	es8388-gpios{
+		hpdet_int: hpdet-int {
+			rockchip,pins = <4 24 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+	};
+};
diff --git a/arch/arm64/boot/dts/rockchip/hm3399_v2r0-board.dtsi b/arch/arm64/boot/dts/rockchip/hm3399_v2r0-board.dtsi
new file mode 100755
index 00000000..ba9408d0
--- /dev/null
+++ b/arch/arm64/boot/dts/rockchip/hm3399_v2r0-board.dtsi
@@ -0,0 +1,791 @@
+/*
+ * Copyright (c) 2016 Fuzhou Rockchip Electronics Co., Ltd
+ *
+ * This file is dual-licensed: you can use it either under the terms
+ * of the GPL or the X11 license, at your option. Note that this dual
+ * licensing only applies to this file, and not this project as a
+ * whole.
+ *
+ *  a) This file is free software; you can redistribute it and/or
+ *     modify it under the terms of the GNU General Public License as
+ *     published by the Free Software Foundation; either version 2 of the
+ *     License, or (at your option) any later version.
+ *
+ *     This file is distributed in the hope that it will be useful,
+ *     but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *     GNU General Public License for more details.
+ *
+ * Or, alternatively,
+ *
+ *  b) Permission is hereby granted, free of charge, to any person
+ *     obtaining a copy of this software and associated documentation
+ *     files (the "Software"), to deal in the Software without
+ *     restriction, including without limitation the rights to use,
+ *     copy, modify, merge, publish, distribute, sublicense, and/or
+ *     sell copies of the Software, and to permit persons to whom the
+ *     Software is furnished to do so, subject to the following
+ *     conditions:
+ *
+ *     The above copyright notice and this permission notice shall be
+ *     included in all copies or substantial portions of the Software.
+ *
+ *     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ *     EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
+ *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ *     NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+ *     HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ *     WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ *     FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ *     OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include "dt-bindings/pwm/pwm.h"
+#include "rk3399.dtsi"
+#include "rk3399-opp.dtsi"
+
+/ {
+	compatible = "rockchip,rk3399-sapphire", "rockchip,rk3399";
+
+	backlight: backlight {
+		status = "disabled";
+		compatible = "pwm-backlight";
+		pwms = <&pwm0 0 25000 0>;
+		brightness-levels = <
+			  0   1   2   3   4   5   6   7
+			  8   9  10  11  12  13  14  15
+			 16  17  18  19  20  21  22  23
+			 24  25  26  27  28  29  30  31
+			 32  33  34  35  36  37  38  39
+			 40  41  42  43  44  45  46  47
+			 48  49  50  51  52  53  54  55
+			 56  57  58  59  60  61  62  63
+			 64  65  66  67  68  69  70  71
+			 72  73  74  75  76  77  78  79
+			 80  81  82  83  84  85  86  87
+			 88  89  90  91  92  93  94  95
+			 96  97  98  99 100 101 102 103
+			104 105 106 107 108 109 110 111
+			112 113 114 115 116 117 118 119
+			120 121 122 123 124 125 126 127
+			128 129 130 131 132 133 134 135
+			136 137 138 139 140 141 142 143
+			144 145 146 147 148 149 150 151
+			152 153 154 155 156 157 158 159
+			160 161 162 163 164 165 166 167
+			168 169 170 171 172 173 174 175
+			176 177 178 179 180 181 182 183
+			184 185 186 187 188 189 190 191
+			192 193 194 195 196 197 198 199
+			200 201 202 203 204 205 206 207
+			208 209 210 211 212 213 214 215
+			216 217 218 219 220 221 222 223
+			224 225 226 227 228 229 230 231
+			232 233 234 235 236 237 238 239
+			240 241 242 243 244 245 246 247
+			248 249 250 251 252 253 254 255>;
+		default-brightness-level = <200>;
+	};
+
+	clkin_gmac: external-gmac-clock {
+		compatible = "fixed-clock";
+		clock-frequency = <125000000>;
+		clock-output-names = "clkin_gmac";
+		#clock-cells = <0>;
+	};
+
+	dw_hdmi_audio: dw-hdmi-audio {
+		status = "disabled";
+		compatible = "rockchip,dw-hdmi-audio";
+		#sound-dai-cells = <0>;
+	};
+
+	dp_sound: dp-sound {
+		status = "disabled";
+		compatible = "rockchip,cdndp-sound";
+		rockchip,cpu = <&spdif>;
+		rockchip,codec = <&cdn_dp 1>;
+	};
+
+	hdmi_sound: hdmi-sound {
+		status = "disabled";
+		compatible = "simple-audio-card";
+		simple-audio-card,format = "i2s";
+		simple-audio-card,mclk-fs = <256>;
+		simple-audio-card,name = "rockchip,hdmi";
+
+		simple-audio-card,cpu {
+			sound-dai = <&i2s2>;
+		};
+		simple-audio-card,codec {
+			sound-dai = <&hdmi>;
+		};
+	};
+
+	sdio_pwrseq: sdio-pwrseq {
+		compatible = "mmc-pwrseq-simple";
+		clocks = <&rk808 1>;
+		clock-names = "ext_clock";
+		pinctrl-names = "default";
+		pinctrl-0 = <&wifi_enable_h>;
+
+		/*
+		 * On the module itself this is one of these (depending
+		 * on the actual card populated):
+		 * - SDIO_RESET_L_WL_REG_ON
+		 * - PDN (power down when low)
+		 */
+		reset-gpios = <&gpio0 10 GPIO_ACTIVE_LOW>; /* GPIO0_B2 */
+	};
+
+	vcc3v3_sys: vcc3v3-sys {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc3v3_sys";
+		regulator-always-on;
+		regulator-boot-on;
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+	};
+
+	vcc5v0_host: vcc5v0-host-regulator {
+		compatible = "regulator-fixed";
+		gpio = <&gpio4 29 GPIO_ACTIVE_LOW>;//HUB_RST   GPIO4_D5
+		pinctrl-names = "default";
+		pinctrl-0 = <&host_vbus_drv>;
+		regulator-name = "vcc5v0_host";
+		regulator-always-on;
+	};
+
+	vcc5v0_sys: vcc5v0-sys {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc5v0_sys";
+		regulator-always-on;
+		regulator-boot-on;
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+	};
+
+	vcc_sd: vcc-sd {
+		compatible = "regulator-fixed";
+		enable-active-high;
+		gpio = <&gpio0 1 GPIO_ACTIVE_HIGH>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&vcc_sd_h>;
+		regulator-name = "vcc_sd";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+	};
+
+	5v_power_en {
+		compatible = "5v_en";
+		pinctrl-names = "default";
+		pinctrl-0 = <&pwr4g_pin &rst4g_pin>;
+		//hub_rst = <&gpio4 GPIO_D0 GPIO_ACTIVE_LOW>;
+		//pwr_led_en = <&gpio7 GPIO_B4 GPIO_ACTIVE_LOW>;
+		pwr_en_4g = <&gpio1 24 GPIO_ACTIVE_HIGH>;//gpio1_d0
+		rst_4g = <&gpio4 28 GPIO_ACTIVE_HIGH>;//gpio4_d4
+		status = "okay";
+	};
+
+	vdd_log: vdd-log {
+		compatible = "pwm-regulator";
+		pwms = <&pwm2 0 25000 1>;
+		regulator-name = "vdd_log";
+		regulator-min-microvolt = <800000>;
+		regulator-max-microvolt = <1400000>;
+		regulator-always-on;
+		regulator-boot-on;
+
+		/* for rockchip boot on */
+		rockchip,pwm_id= <2>;
+		rockchip,pwm_voltage = <900000>;
+	};
+	
+	vcc3v3_pcie: vcc3v3-pcie-regulator {
+		compatible = "regulator-fixed";
+		enable-active-high;
+		regulator-always-on;
+		regulator-boot-on;
+	//	gpio = <&gpio1 18 GPIO_ACTIVE_HIGH>;
+	//	pinctrl-names = "default";
+	//	pinctrl-0 = <&pcie_drv>;
+		regulator-name = "vcc3v3_pcie";
+	};
+};
+
+&cdn_dp {
+	status = "okay";
+	extcon = <&fusb0>;
+	phys = <&tcphy0_dp>;
+};
+
+&cpu_l0 {
+	cpu-supply = <&vdd_cpu_l>;
+};
+
+&cpu_l1 {
+	cpu-supply = <&vdd_cpu_l>;
+};
+
+&cpu_l2 {
+	cpu-supply = <&vdd_cpu_l>;
+};
+
+&cpu_l3 {
+	cpu-supply = <&vdd_cpu_l>;
+};
+
+&cpu_b0 {
+	cpu-supply = <&vdd_cpu_b>;
+};
+
+&cpu_b1 {
+	cpu-supply = <&vdd_cpu_b>;
+};
+
+&emmc_phy {
+	status = "okay";
+};
+
+&gmac {
+	phy-supply = <&vcc_phy>;
+	phy-mode = "rgmii";
+	clock_in_out = "input";
+	snps,reset-gpio = <&gpio3 15 GPIO_ACTIVE_LOW>;//PHY_RST GPIO3_B7
+	snps,reset-active-low;
+	snps,reset-delays-us = <0 10000 50000>;
+	assigned-clocks = <&cru SCLK_RMII_SRC>;
+	assigned-clock-parents = <&clkin_gmac>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&rgmii_pins>;
+	tx_delay = <0x28>;
+	rx_delay = <0x11>;
+	status = "okay";
+};
+
+&gpu {
+	status = "okay";
+	mali-supply = <&vdd_gpu>;
+};
+
+&i2c0 {
+	status = "okay";
+	i2c-scl-rising-time-ns = <168>;
+	i2c-scl-falling-time-ns = <4>;
+	clock-frequency = <400000>;
+
+	vdd_cpu_b: syr827@40 {
+		compatible = "silergy,syr827";
+		reg = <0x40>;
+		vin-supply = <&vcc5v0_sys>;
+		regulator-compatible = "fan53555-reg";
+		pinctrl-names = "default";
+		pinctrl-0 = <&vsel1_gpio>;
+		vsel-gpios = <&gpio1 17 GPIO_ACTIVE_HIGH>;
+		regulator-name = "vdd_cpu_b";
+		regulator-min-microvolt = <712500>;
+		regulator-max-microvolt = <1500000>;
+		regulator-ramp-delay = <1000>;
+		fcs,suspend-voltage-selector = <1>;
+		regulator-always-on;
+		regulator-boot-on;
+		regulator-initial-state = <3>;
+			regulator-state-mem {
+			regulator-off-in-suspend;
+		};
+	};
+
+	vdd_gpu: syr828@41 {
+		compatible = "silergy,syr828";
+		reg = <0x41>;
+		vin-supply = <&vcc5v0_sys>;
+		regulator-compatible = "fan53555-reg";
+		pinctrl-names = "default";
+		pinctrl-0 = <&vsel2_gpio>;
+		vsel-gpios = <&gpio1 14 GPIO_ACTIVE_HIGH>;
+		regulator-name = "vdd_gpu";
+		regulator-min-microvolt = <712500>;
+		regulator-max-microvolt = <1500000>;
+		regulator-ramp-delay = <1000>;
+		fcs,suspend-voltage-selector = <1>;
+		regulator-always-on;
+		regulator-boot-on;
+		regulator-initial-state = <3>;
+			regulator-state-mem {
+			regulator-off-in-suspend;
+		};
+	};
+
+    hym8563: hym8563@51 {
+            compatible = "haoyu,hym8563";
+            reg = <0x51>;
+            #clock-cells = <0>;
+    };
+
+	rk808: pmic@1b {
+		compatible = "rockchip,rk808";
+		reg = <0x1b>;
+		interrupt-parent = <&gpio1>;
+		interrupts = <21 IRQ_TYPE_LEVEL_LOW>;//PMIC_INT_L GPIO1_C5
+		pinctrl-names = "default";
+		pinctrl-0 = <&pmic_int_l>;
+		rockchip,system-power-controller;
+		wakeup-source;
+		#clock-cells = <1>;
+		clock-output-names = "rk808-clkout1", "rk808-clkout2";
+
+		poweroff_signal-gpios = <&gpio0 11 GPIO_ACTIVE_LOW>;//PWR_EN  GPIO0_B3
+		poweroff,signal-active-low;
+			
+		vcc1-supply = <&vcc3v3_sys>;
+		vcc2-supply = <&vcc3v3_sys>;
+		vcc3-supply = <&vcc3v3_sys>;
+		vcc4-supply = <&vcc3v3_sys>;
+		vcc6-supply = <&vcc3v3_sys>;
+		vcc7-supply = <&vcc3v3_sys>;
+		vcc8-supply = <&vcc3v3_sys>;
+		vcc9-supply = <&vcc3v3_sys>;
+		vcc10-supply = <&vcc3v3_sys>;
+		vcc11-supply = <&vcc3v3_sys>;
+		vcc12-supply = <&vcc3v3_sys>;
+		vddio-supply = <&vcc_3v0>;
+
+		regulators {
+			vdd_center: DCDC_REG1 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <750000>;
+				regulator-max-microvolt = <1350000>;
+				regulator-ramp-delay = <6001>;
+				regulator-name = "vdd_center";
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+
+			vdd_cpu_l: DCDC_REG2 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <750000>;
+				regulator-max-microvolt = <1350000>;
+				regulator-ramp-delay = <6001>;
+				regulator-name = "vdd_cpu_l";
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+
+			vcc_ddr: DCDC_REG3 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-name = "vcc_ddr";
+				regulator-state-mem {
+					regulator-on-in-suspend;
+				};
+			};
+
+			vcc_1v8: DCDC_REG4 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-name = "vcc_1v8";
+				regulator-state-mem {
+					regulator-on-in-suspend;
+					regulator-suspend-microvolt = <1800000>;
+				};
+			};
+
+			vcc1v8_dvp: LDO_REG1 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-name = "vcc1v8_dvp";
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+
+			vcc3v0_tp: LDO_REG2 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <3000000>;
+				regulator-max-microvolt = <3000000>;
+				regulator-name = "vcc3v0_tp";
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+
+			vcc1v8_pmu: LDO_REG3 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-name = "vcc1v8_pmu";
+				regulator-state-mem {
+					regulator-on-in-suspend;
+					regulator-suspend-microvolt = <1800000>;
+				};
+			};
+
+			vccio_sd: LDO_REG4 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <3000000>;
+				regulator-name = "vccio_sd";
+				regulator-state-mem {
+					regulator-on-in-suspend;
+					regulator-suspend-microvolt = <3000000>;
+				};
+			};
+
+			vcc_phy: LDO_REG5 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <3000000>;
+				regulator-max-microvolt = <3000000>;
+				regulator-name = "vcca3v0_codec";
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+
+			vcc_1v5: LDO_REG6 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <1500000>;
+				regulator-max-microvolt = <1500000>;
+				regulator-name = "vcc_1v5";
+				regulator-state-mem {
+					regulator-on-in-suspend;
+					regulator-suspend-microvolt = <1500000>;
+				};
+			};
+
+			vcca1v8_codec: LDO_REG7 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-name = "vcca1v8_codec";
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+
+			vcc_3v0: LDO_REG8 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <3000000>;
+				regulator-max-microvolt = <3000000>;
+				regulator-name = "vcc_3v0";
+				regulator-state-mem {
+					regulator-on-in-suspend;
+					regulator-suspend-microvolt = <3000000>;
+				};
+			};
+
+			vcc3v3_s3: SWITCH_REG1 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-name = "vcc3v3_s3";
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+
+			vcc3v3_s0: SWITCH_REG2 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-name = "vcc3v3_s0";
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+		};
+	};
+};
+
+&i2c4 {
+	status = "okay";
+	i2c-scl-rising-time-ns = <475>;
+	i2c-scl-falling-time-ns = <26>;
+
+	fusb0: fusb30x@22 {
+		compatible = "fairchild,fusb302";
+		reg = <0x22>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&fusb0_int &fusb0_vbus>;
+		int-n-gpios = <&gpio1 2 GPIO_ACTIVE_HIGH>;//GPIO1_A2
+		vbus-5v-gpios = <&gpio1 20 GPIO_ACTIVE_HIGH>;//GPIO1_C4
+		status = "okay";
+	};
+};
+
+&i2s0 {
+	status = "okay";
+	rockchip,i2s-broken-burst-len;
+	rockchip,playback-channels = <8>;
+	rockchip,capture-channels = <8>;
+	#sound-dai-cells = <0>;
+};
+
+&i2s1 {
+	status = "okay";
+	rockchip,i2s-broken-burst-len;
+	rockchip,playback-channels = <8>;
+	rockchip,capture-channels = <8>;
+	#sound-dai-cells = <0>;
+};
+
+&i2s2 {
+	#sound-dai-cells = <0>;
+	status = "okay";
+};
+
+&io_domains {
+	status = "okay";
+
+	bt656-supply = <&vcc_3v0>;		/* bt656_gpio2ab_ms */
+	audio-supply = <&vcca1v8_codec>;	/* audio_gpio3d4a_ms */
+	sdmmc-supply = <&vccio_sd>;		/* sdmmc_gpio4b_ms */
+	gpio1830-supply = <&vcc_3v0>;		/* gpio1833_gpio4cd_ms */
+};
+
+&pcie_phy {
+	status = "disabled";
+};
+
+&pcie0 {
+	assigned-clocks = <&cru SCLK_PCIEPHY_REF>;
+	assigned-clock-parents = <&cru SCLK_PCIEPHY_REF100M>;
+	assigned-clock-rates = <100000000>;
+	//ep-gpios = <&gpio4 25 GPIO_ACTIVE_HIGH>;
+	num-lanes = <4>;
+//	pinctrl-names = "default";
+	//pinctrl-0 = <&pcie_clkreqn>;
+	phy-supply = <&vcc3v3_pcie>;
+	status = "disabled";
+};
+
+&pmu_io_domains {
+	status = "okay";
+	pmu1830-supply = <&vcc_3v0>;
+};
+
+&pwm0 {
+	status = "disabled";
+};
+
+&pwm1 {
+	status = "disabled";
+};
+
+&pwm2 {
+	status = "okay";
+};
+
+&sdhci {
+	bus-width = <8>;
+	mmc-hs400-1_8v;
+	supports-emmc;
+	non-removable;
+	keep-power-in-suspend;
+	mmc-hs400-enhanced-strobe;
+	status = "okay";
+};
+
+&sdio0 {
+	clock-frequency = <50000000>;
+	clock-freq-min-max = <200000 50000000>;
+	supports-sdio;
+	bus-width = <4>;
+	disable-wp;
+	cap-sd-highspeed;
+	cap-sdio-irq;
+	keep-power-in-suspend;
+	mmc-pwrseq = <&sdio_pwrseq>;
+	non-removable;
+	num-slots = <1>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&sdio0_bus4 &sdio0_cmd &sdio0_clk>;
+	sd-uhs-sdr104;
+	status = "okay";
+};
+
+&sdmmc {
+	clock-frequency = <150000000>;
+	clock-freq-min-max = <100000 150000000>;
+	supports-sd;
+	bus-width = <4>;
+	cap-mmc-highspeed;
+	cap-sd-highspeed;
+	disable-wp;
+	num-slots = <1>;
+	//sd-uhs-sdr104;
+	vmmc-supply = <&vcc_sd>;
+	vqmmc-supply = <&vccio_sd>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&sdmmc_clk &sdmmc_cmd &sdmmc_cd &sdmmc_bus4>;
+	status = "okay";
+};
+
+&saradc {
+	status = "okay";
+};
+
+&tcphy0 {
+	extcon = <&fusb0>;
+	status = "okay";
+};
+
+&tcphy1 {
+	status = "okay";
+};
+
+&tsadc {
+	/* tshut mode 0:CRU 1:GPIO */
+	rockchip,hw-tshut-mode = <1>;
+	/* tshut polarity 0:LOW 1:HIGH */
+	rockchip,hw-tshut-polarity = <1>;
+	status = "okay";
+};
+
+&u2phy0 {
+	status = "okay";
+	extcon = <&fusb0>;
+
+	u2phy0_otg: otg-port {
+		status = "okay";
+	};
+
+	u2phy0_host: host-port {
+		phy-supply = <&vcc5v0_host>;
+		status = "okay";
+	};
+};
+
+&u2phy1 {
+	status = "okay";
+
+	u2phy1_otg: otg-port {
+		status = "okay";
+	};
+
+	u2phy1_host: host-port {
+		phy-supply = <&vcc5v0_host>;
+		status = "okay";
+	};
+};
+
+&uart2 {
+	status = "okay";
+};
+
+&uart4 {
+	status = "okay";
+};
+
+&spi1 {
+	status = "disabled";
+};
+
+&spi2 {
+	status = "okay";
+};
+
+
+
+&usbdrd3_0 {
+	status = "okay";
+	extcon = <&fusb0>;
+};
+
+&usbdrd3_1 {
+	status = "okay";
+};
+
+&usbdrd_dwc3_0 {
+	status = "okay";
+};
+
+&usbdrd_dwc3_1 {
+	status = "okay";
+	dr_mode = "host";
+};
+
+&usb_host0_ehci {
+	status = "okay";
+};
+
+&usb_host0_ohci {
+	status = "okay";
+};
+
+&usb_host1_ehci {
+	status = "okay";
+};
+
+&usb_host1_ohci {
+	status = "okay";
+};
+
+&pinctrl {
+	pmic {
+		pmic_int_l: pmic-int-l {
+			rockchip,pins =
+				<1 21 RK_FUNC_GPIO &pcfg_pull_up>;
+		};
+		vsel1_gpio: vsel1-gpio {
+			rockchip,pins =
+				<1 17 RK_FUNC_GPIO &pcfg_pull_down>;
+		};
+		vsel2_gpio: vsel2-gpio {
+			rockchip,pins =
+				<1 14 RK_FUNC_GPIO &pcfg_pull_down>;
+		};
+	};
+
+/*
+    pcie {
+		pcie_drv: pcie-drv {
+			rockchip,pins =
+				<1 18 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+	};
+*/
+	usb2 {
+		host_vbus_drv: host-vbus-drv {
+			rockchip,pins =
+				<4 29 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+	};
+
+	vcc_sd {
+		vcc_sd_h: vcc-sd-h {
+			rockchip,pins =
+				<0 1 RK_FUNC_GPIO &pcfg_pull_up>;
+		};
+	};
+
+	fusb30x {
+		fusb0_int: fusb0-int {
+			rockchip,pins = <1 2 RK_FUNC_GPIO &pcfg_pull_up>;
+		};			
+		fusb0_vbus: fusb0-vbus {
+			rockchip,pins = <1 20 RK_FUNC_GPIO &pcfg_pull_up>;
+		};
+	};
+	five_en {
+		pwr4g_pin: pwr4g-pin {
+			rockchip,pins = <1 24 RK_FUNC_GPIO &pcfg_pull_up>;
+		};
+
+		rst4g_pin: rst4g-pin {
+			rockchip,pins = <4 28 RK_FUNC_GPIO &pcfg_pull_up>;
+		};
+	};
+};
diff --git a/arch/arm64/boot/dts/rockchip/hm3399_v2r0-linux.dtsi b/arch/arm64/boot/dts/rockchip/hm3399_v2r0-linux.dtsi
new file mode 100755
index 00000000..955c3aeb
--- /dev/null
+++ b/arch/arm64/boot/dts/rockchip/hm3399_v2r0-linux.dtsi
@@ -0,0 +1,191 @@
+/*
+ * Copyright (c) 2019 Fuzhou Rockchip Electronics Co., Ltd
+ *
+ * This file is dual-licensed: you can use it either under the terms
+ * of the GPL or the X11 license, at your option. Note that this dual
+ * licensing only applies to this file, and not this project as a
+ * whole.
+ *
+ *  a) This file is free software; you can redistribute it and/or
+ *     modify it under the terms of the GNU General Public License as
+ *     published by the Free Software Foundation; either version 2 of the
+ *     License, or (at your option) any later version.
+ *
+ *     This file is distributed in the hope that it will be useful,
+ *     but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *     GNU General Public License for more details.
+ *
+ * Or, alternatively,
+ *
+ *  b) Permission is hereby granted, free of charge, to any person
+ *     obtaining a copy of this software and associated documentation
+ *     files (the "Software"), to deal in the Software without
+ *     restriction, including without limitation the rights to use,
+ *     copy, modify, merge, publish, distribute, sublicense, and/or
+ *     sell copies of the Software, and to permit persons to whom the
+ *     Software is furnished to do so, subject to the following
+ *     conditions:
+ *
+ *     The above copyright notice and this permission notice shall be
+ *     included in all copies or substantial portions of the Software.
+ *
+ *     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ *     EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
+ *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ *     NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+ *     HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ *     WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ *     FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ *     OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include <dt-bindings/display/drm_mipi_dsi.h>
+#include "rk3399-vop-clk-set.dtsi"
+
+/ {
+	compatible = "rockchip,linux", "rockchip,rk3399";
+
+	chosen {
+		bootargs = "earlycon=uart8250,mmio32,0xff1a0000 swiotlb=1 console=ttyFIQ0 rw root=PARTUUID=614e0000-0000 rootfstype=ext4 rootwait coherent_pool=1m";
+	};
+
+	reserved-memory {
+		#address-cells = <2>;
+		#size-cells = <2>;
+		ranges;
+
+		drm_logo: drm-logo@00000000 {
+			compatible = "rockchip,drm-logo";
+			reg = <0x0 0x0 0x0 0x0>;
+		};
+
+		ramoops_mem: region@110000 {
+			reg = <0x0 0x110000 0x0 0xf0000>;
+			reg-names = "ramoops_mem";
+		};
+	};
+
+	ramoops: ramoops {
+		compatible = "ramoops";
+		record-size = <0x0 0x40000>;
+		console-size = <0x0 0x80000>;
+		ftrace-size = <0x0 0x00000>;
+		pmsg-size = <0x0 0x00000>;
+		memory-region = <&ramoops_mem>;
+	};
+
+	fiq_debugger: fiq-debugger {
+		compatible = "rockchip,fiq-debugger";
+		rockchip,serial-id = <2>;
+		rockchip,signal-irq = <182>;
+		rockchip,wake-irq = <0>;
+		rockchip,irq-mode-enable = <1>;  /* If enable uart uses irq instead of fiq */
+		rockchip,baudrate = <1500000>;  /* Only 115200 and 1500000 */
+		pinctrl-names = "default";
+		pinctrl-0 = <&uart2c_xfer>;
+	};
+
+	rk_key: rockchip-key {
+		compatible = "rockchip,key";
+		status = "okay";
+		io-channels = <&saradc 1>;
+		power-key {
+			gpios = <&gpio0 5 GPIO_ACTIVE_LOW>;
+			linux,code = <116>;
+			label = "power";
+			gpio-key,wakeup;
+		};
+
+	};
+
+	rga: rga@ff680000 {
+		compatible = "rockchip,rga2";
+		dev_mode = <1>;
+		reg = <0x0 0xff680000 0x0 0x1000>;
+		interrupts = <GIC_SPI 55 IRQ_TYPE_LEVEL_HIGH 0>;
+		clocks = <&cru ACLK_RGA>, <&cru HCLK_RGA>, <&cru SCLK_RGA_CORE>;
+		clock-names = "aclk_rga", "hclk_rga", "clk_rga";
+		power-domains = <&power RK3399_PD_RGA>;
+		dma-coherent;
+		status = "okay";
+	};
+};
+
+&display_subsystem {
+	status = "okay";
+
+	ports = <&vopb_out>, <&vopl_out>;
+	logo-memory-region = <&drm_logo>;
+
+	route {
+		route_hdmi: route-hdmi {
+			status = "disabled";
+			logo,uboot = "logo.bmp";
+			logo,kernel = "logo_kernel.bmp";
+			logo,mode = "center";
+			charge_logo,mode = "center";
+			connect = <&vopb_out_hdmi>;
+		};
+
+		route_dsi: route-dsi {
+			status = "disabled";
+			logo,uboot = "logo.bmp";
+			logo,kernel = "logo_kernel.bmp";
+			logo,mode = "center";
+			charge_logo,mode = "center";
+			connect = <&vopb_out_dsi>;
+		};
+
+		route_dsi1: route-dsi1 {
+			status = "disabled";
+			logo,uboot = "logo.bmp";
+			logo,kernel = "logo_kernel.bmp";
+			logo,mode = "center";
+			charge_logo,mode = "center";
+			connect = <&vopl_out_dsi1>;
+		};
+
+		route_edp: route-edp {
+			status = "disabled";
+			logo,uboot = "logo.bmp";
+			logo,kernel = "logo_kernel.bmp";
+			logo,mode = "center";
+			charge_logo,mode = "center";
+			connect = <&vopb_out_edp>;
+		};
+	};
+};
+
+/* HACK: keep MALI version on linux */
+&gpu_power_model {
+	// for DDK r14.
+	voltage = <900>;
+	frequency = <500>;
+	static-power = <300>;
+	dynamic-power = <396>;
+};
+
+&pvtm {
+	status = "okay";
+};
+
+&rkvdec {
+	status = "okay";
+	/* 0 means ion, 1 means drm */
+	//allocator = <0>;
+};
+
+&uart2 {
+	status = "disabled";
+};
+
+&vpu {
+	status = "okay";
+	/* 0 means ion, 1 means drm */
+	//allocator = <0>;
+};
+
+&pinctrl {
+	
+};
diff --git a/arch/arm64/boot/dts/rockchip/rk3399-hm3399.dts b/arch/arm64/boot/dts/rockchip/rk3399-hm3399.dts
new file mode 100755
index 00000000..e888746a
--- /dev/null
+++ b/arch/arm64/boot/dts/rockchip/rk3399-hm3399.dts
@@ -0,0 +1,235 @@
+/*
+ * Copyright (c) 2019 Fuzhou Rockchip Electronics Co., Ltd
+ *
+ * This file is dual-licensed: you can use it either under the terms
+ * of the GPL or the X11 license, at your option. Note that this dual
+ * licensing only applies to this file, and not this project as a
+ * whole.
+ *
+ *  a) This file is free software; you can redistribute it and/or
+ *     modify it under the terms of the GNU General Public License as
+ *     published by the Free Software Foundation; either version 2 of the
+ *     License, or (at your option) any later version.
+ *
+ *     This file is distributed in the hope that it will be useful,
+ *     but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *     GNU General Public License for more details.
+ *
+ * Or, alternatively,
+ *
+ *  b) Permission is hereby granted, free of charge, to any person
+ *     obtaining a copy of this software and associated documentation
+ *     files (the "Software"), to deal in the Software without
+ *     restriction, including without limitation the rights to use,
+ *     copy, modify, merge, publish, distribute, sublicense, and/or
+ *     sell copies of the Software, and to permit persons to whom the
+ *     Software is furnished to do so, subject to the following
+ *     conditions:
+ *
+ *     The above copyright notice and this permission notice shall be
+ *     included in all copies or substantial portions of the Software.
+ *
+ *     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ *     EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
+ *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ *     NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+ *     HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ *     WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ *     FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ *     OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+/dts-v1/;
+
+#include "hm3399_v2r0-ad-board.dtsi"
+#include "hm3399_v2r0-linux.dtsi"
+#include <dt-bindings/input/input.h>
+
+/ {
+	model = "Rockchip RK3399 Excavator Board (Linux Opensource)";
+	compatible = "rockchip,hm3399-ad-board-edp-linux", "rockchip,rk3399";
+
+	vcc_lcd: vcc-lcd {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc_lcd";
+		gpio = <&gpio1 3 GPIO_ACTIVE_HIGH>; 
+		startup-delay-us = <10000>;
+		enable-active-high;
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		regulator-boot-on;
+		vin-supply = <&vcc5v0_sys>;
+	};
+
+	vccadc_ref: vccadc-ref {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc1v8_sys";
+		regulator-always-on;
+		regulator-boot-on;
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+	};
+
+	panel: panel {
+		compatible = "simple-panel";
+		backlight = <&backlight>;
+		power-supply = <&vcc_lcd>;
+//		enable-gpios = <&gpio4 21 GPIO_ACTIVE_HIGH>;
+		prepare-delay-ms = <150>;
+		enable-delay-ms = <20>;
+//		pinctrl-0 = <&lcd_en>;
+
+		display-timings {
+			native-mode = <&timing0>;
+
+			timing0: timing0 {
+				clock-frequency = <140000000>;
+				hactive = <1920>;
+				vactive = <1080>;
+				hback-porch = <80>;
+				hfront-porch = <48>;
+				vback-porch = <23>;
+				vfront-porch = <3>;
+				hsync-len = <32>;
+				vsync-len = <5>;
+				hsync-active = <0>;
+				vsync-active = <0>;
+				de-active = <0>;
+				pixelclk-active = <0>;
+			};
+		};
+
+		ports {
+			panel_in: endpoint {
+				remote-endpoint = <&edp_out>;
+			};
+		};
+	};
+
+//	ext_cam_clk: external-camera-clock {
+//		compatible = "fixed-clock";
+//		clock-frequency = <27000000>;
+//		clock-output-names = "CLK_CAMERA_27MHZ";
+//		#clock-cells = <0>;
+//	};
+
+	test_power: test-power {
+		status = "okay";
+	};
+};
+
+&backlight {
+	status = "okay";
+	pwms = <&pwm1 0 25000 0>;
+//	enable-gpios = <&gpio4 22 GPIO_ACTIVE_HIGH>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&lcd_en>;
+	enable-gpios = <&gpio4 21 GPIO_ACTIVE_HIGH>;
+};
+
+&pwm1 {
+	status = "okay";
+};
+
+&display_subsystem {
+	status = "okay";
+};
+
+&edp {
+	status = "disabled";
+	force-hpd;
+
+	ports {
+		port@1 {
+			reg = <1>;
+
+			edp_out: endpoint {
+				remote-endpoint = <&panel_in>;
+			};
+		};
+	};
+};
+
+&edp_in_vopb {
+	status = "disabled";
+};
+
+&hdmi {
+	pinctrl-names = "default";
+	pinctrl-0 = <&hdmi_i2c_xfer>, <&hdmi_cec>;
+	#address-cells = <1>;
+	#size-cells = <0>;
+	#sound-dai-cells = <0>;
+	status = "okay";
+};
+
+&hdmi_in_vopl {
+	status = "disabled";
+};
+
+&i2c1 {
+	status = "okay";
+};
+
+&i2c4 {
+	status = "okay";
+};
+
+&isp0_mmu {
+	status = "okay";
+};
+
+&isp1_mmu {
+	status = "okay";
+};
+
+&pcie_phy {
+	status = "okay";
+};
+
+&pcie0 {
+	status = "okay";
+};
+
+&route_edp {
+	status = "okay";
+};
+
+
+
+&saradc {
+	vref-supply = <&vccadc_ref>;
+};
+
+&vopb {
+	assigned-clocks = <&cru DCLK_VOP0_DIV>;
+	assigned-clock-parents = <&cru PLL_CPLL>;
+	status = "okay";
+};
+
+&vopb_mmu {
+	status = "okay";
+};
+
+&vopl {
+	assigned-clocks = <&cru DCLK_VOP0_DIV>;
+	assigned-clock-parents = <&cru PLL_CPLL>;
+	status = "okay";
+};
+
+&vopl_mmu {
+	status = "okay";
+};
+
+&pinctrl {
+	lcd-panel {
+		lcd_en: lcd-en {
+			rockchip,pins = <4 21 RK_FUNC_GPIO &pcfg_pull_up>;
+		};
+	};
+};
+
+/* DON'T PUT ANYTHING BELOW HERE.  PUT IT ABOVE PINCTRL */
+/* DON'T PUT ANYTHING BELOW HERE.  PUT IT ABOVE PINCTRL */
+/* DON'T PUT ANYTHING BELOW HERE.  PUT IT ABOVE PINCTRL */
diff --git a/arch/arm64/boot/dts/rockchip/rk3399.dtsi b/arch/arm64/boot/dts/rockchip/rk3399.dtsi
old mode 100644
new mode 100755
index 07304d00..664fde48
--- a/arch/arm64/boot/dts/rockchip/rk3399.dtsi
+++ b/arch/arm64/boot/dts/rockchip/rk3399.dtsi
@@ -1705,6 +1705,7 @@
 	};
 
 	watchdog@ff848000 {
+		status = "okay";
 		compatible = "snps,dw-wdt";
 		reg = <0x0 0xff848000 0x0 0x100>;
 		clocks = <&cru PCLK_WDT>;
@@ -2677,7 +2678,7 @@
 		spdif {
 			spdif_bus: spdif-bus {
 				rockchip,pins =
-					<4 21 RK_FUNC_1 &pcfg_pull_none>;
+					<2 28 RK_FUNC_1 &pcfg_pull_none>;
 			};
 
 			spdif_bus_1: spdif-bus-1 {
@@ -2893,7 +2894,7 @@
 		uarthdcp {
 			uarthdcp_xfer: uarthdcp-xfer {
 				rockchip,pins =
-					<4 21 RK_FUNC_2 &pcfg_pull_up>,
+				//	<4 21 RK_FUNC_2 &pcfg_pull_up>,
 					<4 22 RK_FUNC_2 &pcfg_pull_none>;
 			};
 		};
@@ -2926,10 +2927,10 @@
 					<4 22 RK_FUNC_1 &pcfg_pull_none>;
 			};
 
-			pwm1_pin_pull_down: pwm1-pin-pull-down {
-				rockchip,pins =
-					<4 22 RK_FUNC_1 &pcfg_pull_down>;
-			};
+			//pwm1_pin_pull_down: pwm1-pin-pull-down {
+		//		rockchip,pins =
+		//			<4 22 RK_FUNC_1 &pcfg_pull_down>;
+		//	};
 		};
 
 		pwm2 {
diff --git a/arch/arm64/configs/hm3399_linux_defconfig b/arch/arm64/configs/hm3399_linux_defconfig
new file mode 100755
index 00000000..4284485f
--- /dev/null
+++ b/arch/arm64/configs/hm3399_linux_defconfig
@@ -0,0 +1,566 @@
+CONFIG_DEFAULT_HOSTNAME="localhost"
+CONFIG_SYSVIPC=y
+CONFIG_FHANDLE=y
+CONFIG_NO_HZ=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_LOG_BUF_SHIFT=18
+CONFIG_CGROUPS=y
+CONFIG_CGROUP_FREEZER=y
+CONFIG_CGROUP_DEVICE=y
+CONFIG_CPUSETS=y
+CONFIG_CGROUP_CPUACCT=y
+CONFIG_CGROUP_SCHED=y
+CONFIG_CFS_BANDWIDTH=y
+CONFIG_NAMESPACES=y
+CONFIG_USER_NS=y
+CONFIG_DEFAULT_USE_ENERGY_AWARE=y
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_EMBEDDED=y
+# CONFIG_COMPAT_BRK is not set
+CONFIG_PROFILING=y
+CONFIG_MODULES=y
+CONFIG_MODULE_FORCE_LOAD=y
+CONFIG_MODULE_UNLOAD=y
+CONFIG_MODULE_FORCE_UNLOAD=y
+CONFIG_PARTITION_ADVANCED=y
+CONFIG_ARCH_ROCKCHIP=y
+CONFIG_PCI=y
+CONFIG_PCI_MSI=y
+CONFIG_PCIE_ROCKCHIP=y
+CONFIG_PCIEPORTBUS=y
+CONFIG_PCIEASPM_POWERSAVE=y
+# CONFIG_ARM64_ERRATUM_826319 is not set
+# CONFIG_ARM64_ERRATUM_827319 is not set
+# CONFIG_ARM64_ERRATUM_824069 is not set
+# CONFIG_ARM64_ERRATUM_819472 is not set
+# CONFIG_ARM64_ERRATUM_832075 is not set
+# CONFIG_CAVIUM_ERRATUM_22375 is not set
+# CONFIG_CAVIUM_ERRATUM_23154 is not set
+CONFIG_SCHED_MC=y
+CONFIG_NR_CPUS=8
+CONFIG_PREEMPT_VOLUNTARY=y
+CONFIG_HZ_1000=y
+# CONFIG_COMPACTION is not set
+CONFIG_DEFAULT_MMAP_MIN_ADDR=32768
+CONFIG_ZSMALLOC=y
+CONFIG_SECCOMP=y
+CONFIG_ARMV8_DEPRECATED=y
+CONFIG_SWP_EMULATION=y
+CONFIG_CP15_BARRIER_EMULATION=y
+CONFIG_SETEND_EMULATION=y
+# CONFIG_EFI is not set
+CONFIG_COMPAT=y
+CONFIG_PM_DEBUG=y
+CONFIG_PM_ADVANCED_DEBUG=y
+CONFIG_WQ_POWER_EFFICIENT_DEFAULT=y
+CONFIG_CPU_IDLE=y
+CONFIG_ARM_CPUIDLE=y
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_DEFAULT_GOV_INTERACTIVE=y
+CONFIG_CPU_FREQ_GOV_PERFORMANCE=y
+CONFIG_CPU_FREQ_GOV_POWERSAVE=y
+CONFIG_CPU_FREQ_GOV_USERSPACE=y
+CONFIG_CPU_FREQ_GOV_ONDEMAND=y
+CONFIG_CPU_FREQ_GOV_CONSERVATIVE=y
+CONFIG_CPUFREQ_DT=y
+CONFIG_ARM_ROCKCHIP_CPUFREQ=y
+CONFIG_NET=y
+CONFIG_PACKET=y
+CONFIG_UNIX=y
+CONFIG_XFRM_USER=y
+CONFIG_NET_KEY=y
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+CONFIG_IP_ADVANCED_ROUTER=y
+CONFIG_IP_MROUTE=y
+CONFIG_SYN_COOKIES=y
+# CONFIG_INET_XFRM_MODE_TRANSPORT is not set
+# CONFIG_INET_XFRM_MODE_TUNNEL is not set
+# CONFIG_INET_XFRM_MODE_BEET is not set
+# CONFIG_INET_LRO is not set
+# CONFIG_INET_DIAG is not set
+# CONFIG_INET6_XFRM_MODE_TRANSPORT is not set
+# CONFIG_INET6_XFRM_MODE_TUNNEL is not set
+# CONFIG_INET6_XFRM_MODE_BEET is not set
+# CONFIG_IPV6_SIT is not set
+# CONFIG_ANDROID_PARANOID_NETWORK is not set
+CONFIG_BT=y
+CONFIG_BT_RFCOMM=y
+CONFIG_BT_HIDP=y
+CONFIG_BT_HCIBTUSB=y
+CONFIG_BT_HCIUART=y
+CONFIG_BT_HCIUART_ATH3K=y
+CONFIG_BT_HCIUART_LL=y
+CONFIG_BT_HCIBFUSB=y
+CONFIG_BT_HCIVHCI=y
+CONFIG_BT_MRVL=y
+CONFIG_BT_MRVL_SDIO=y
+CONFIG_NL80211_TESTMODE=y
+CONFIG_CFG80211_DEBUGFS=y
+CONFIG_CFG80211_WEXT=y
+CONFIG_MAC80211_LEDS=y
+CONFIG_MAC80211_DEBUGFS=y
+CONFIG_MAC80211_DEBUG_MENU=y
+CONFIG_MAC80211_VERBOSE_DEBUG=y
+CONFIG_RFKILL=y
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+CONFIG_DEBUG_DEVRES=y
+CONFIG_CONNECTOR=y
+CONFIG_ZRAM=y
+CONFIG_BLK_DEV_LOOP=y
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=1
+CONFIG_BLK_DEV_NVME=y
+CONFIG_ROCKCHIP_SCR=y
+CONFIG_SRAM=y
+CONFIG_SCSI=y
+CONFIG_BLK_DEV_SD=y
+CONFIG_BLK_DEV_SR=y
+CONFIG_SCSI_SCAN_ASYNC=y
+CONFIG_SCSI_SPI_ATTRS=y
+CONFIG_MD=y
+CONFIG_NETDEVICES=y
+# CONFIG_NET_VENDOR_3COM is not set
+# CONFIG_NET_VENDOR_ADAPTEC is not set
+# CONFIG_NET_VENDOR_AGERE is not set
+# CONFIG_NET_VENDOR_ALTEON is not set
+# CONFIG_NET_VENDOR_AMD is not set
+# CONFIG_NET_VENDOR_ARC is not set
+# CONFIG_NET_VENDOR_ATHEROS is not set
+# CONFIG_NET_CADENCE is not set
+# CONFIG_NET_VENDOR_BROADCOM is not set
+# CONFIG_NET_VENDOR_BROCADE is not set
+# CONFIG_NET_VENDOR_CAVIUM is not set
+# CONFIG_NET_VENDOR_CHELSIO is not set
+# CONFIG_NET_VENDOR_CISCO is not set
+# CONFIG_NET_VENDOR_DEC is not set
+# CONFIG_NET_VENDOR_DLINK is not set
+# CONFIG_NET_VENDOR_EMULEX is not set
+# CONFIG_NET_VENDOR_EZCHIP is not set
+# CONFIG_NET_VENDOR_EXAR is not set
+# CONFIG_NET_VENDOR_HISILICON is not set
+# CONFIG_NET_VENDOR_HP is not set
+# CONFIG_NET_VENDOR_INTEL is not set
+# CONFIG_NET_VENDOR_MARVELL is not set
+# CONFIG_NET_VENDOR_MELLANOX is not set
+# CONFIG_NET_VENDOR_MICREL is not set
+# CONFIG_NET_VENDOR_MICROCHIP is not set
+# CONFIG_NET_VENDOR_MYRI is not set
+# CONFIG_NET_VENDOR_NATSEMI is not set
+# CONFIG_NET_VENDOR_NVIDIA is not set
+# CONFIG_NET_VENDOR_OKI is not set
+# CONFIG_NET_PACKET_ENGINE is not set
+# CONFIG_NET_VENDOR_QLOGIC is not set
+# CONFIG_NET_VENDOR_QUALCOMM is not set
+# CONFIG_NET_VENDOR_REALTEK is not set
+# CONFIG_NET_VENDOR_RENESAS is not set
+# CONFIG_NET_VENDOR_RDC is not set
+# CONFIG_NET_VENDOR_ROCKER is not set
+# CONFIG_NET_VENDOR_SAMSUNG is not set
+# CONFIG_NET_VENDOR_SEEQ is not set
+# CONFIG_NET_VENDOR_SILAN is not set
+# CONFIG_NET_VENDOR_SIS is not set
+# CONFIG_NET_VENDOR_SMSC is not set
+CONFIG_STMMAC_ETH=y
+# CONFIG_NET_VENDOR_SUN is not set
+# CONFIG_NET_VENDOR_SYNOPSYS is not set
+# CONFIG_NET_VENDOR_TEHUTI is not set
+# CONFIG_NET_VENDOR_TI is not set
+# CONFIG_NET_VENDOR_VIA is not set
+# CONFIG_NET_VENDOR_WIZNET is not set
+CONFIG_ROCKCHIP_PHY=y
+CONFIG_PPP=y
+CONFIG_PPP_BSDCOMP=y
+CONFIG_PPP_DEFLATE=y
+CONFIG_PPP_FILTER=y
+CONFIG_PPP_MPPE=y
+CONFIG_PPP_MULTILINK=y
+CONFIG_PPPOE=y
+CONFIG_PPPOLAC=y
+CONFIG_PPPOPNS=y
+CONFIG_PPP_ASYNC=y
+CONFIG_PPP_SYNC_TTY=y
+CONFIG_SLIP=y
+CONFIG_SLIP_COMPRESSED=y
+CONFIG_USB_RTL8150=y
+CONFIG_USB_RTL8152=y
+CONFIG_USB_NET_CDC_MBIM=y
+# CONFIG_USB_NET_NET1080 is not set
+# CONFIG_USB_NET_CDC_SUBSET is not set
+# CONFIG_USB_NET_ZAURUS is not set
+CONFIG_LIBERTAS_THINFIRM=y
+CONFIG_USB_NET_RNDIS_WLAN=y
+CONFIG_WL_ROCKCHIP=y
+CONFIG_WIFI_BUILD_MODULE=y
+CONFIG_WIFI_LOAD_DRIVER_WHEN_KERNEL_BOOTUP=y
+CONFIG_AP6XXX=m
+CONFIG_RTL8188EU=m
+CONFIG_MWIFIEX=m
+CONFIG_MWIFIEX_SDIO=m
+CONFIG_INPUT_FF_MEMLESS=y
+# CONFIG_INPUT_MOUSEDEV is not set
+CONFIG_INPUT_EVDEV=y
+CONFIG_KEYBOARD_ADC=y
+# CONFIG_KEYBOARD_ATKBD is not set
+CONFIG_KEYBOARD_GPIO=y
+CONFIG_KEYBOARD_GPIO_POLLED=y
+CONFIG_KEYBOARD_ROCKCHIP=y
+CONFIG_KEYBOARD_CROS_EC=y
+# CONFIG_MOUSE_PS2 is not set
+CONFIG_MOUSE_CYAPA=y
+CONFIG_MOUSE_ELAN_I2C=y
+CONFIG_INPUT_TOUCHSCREEN=y
+CONFIG_TOUCHSCREEN_ATMEL_MXT=y
+CONFIG_TOUCHSCREEN_GSLX680_VR=y
+CONFIG_TOUCHSCREEN_GSL3673=y
+CONFIG_TOUCHSCREEN_GT9XX=y
+CONFIG_TOUCHSCREEN_ELAN=y
+CONFIG_TOUCHSCREEN_USB_COMPOSITE=y
+CONFIG_TOUCHSCREEN_GT1X=y
+CONFIG_ROCKCHIP_REMOTECTL=y
+CONFIG_ROCKCHIP_REMOTECTL_PWM=y
+CONFIG_INPUT_MISC=y
+CONFIG_INPUT_RK8XX_PWRKEY=y
+CONFIG_INPUT_UINPUT=y
+CONFIG_INPUT_GPIO=y
+# CONFIG_SERIO is not set
+CONFIG_VT_HW_CONSOLE_BINDING=y
+CONFIG_DEVPTS_MULTIPLE_INSTANCES=y
+# CONFIG_LEGACY_PTYS is not set
+# CONFIG_DEVKMEM is not set
+CONFIG_SERIAL_8250=y
+CONFIG_SERIAL_8250_CONSOLE=y
+# CONFIG_SERIAL_8250_PCI is not set
+CONFIG_SERIAL_8250_NR_UARTS=5
+CONFIG_SERIAL_8250_RUNTIME_UARTS=5
+CONFIG_SERIAL_8250_DW=y
+CONFIG_SERIAL_OF_PLATFORM=y
+CONFIG_HW_RANDOM=y
+CONFIG_TCG_TPM=y
+CONFIG_TCG_TIS_I2C_INFINEON=y
+CONFIG_I2C_CHARDEV=y
+CONFIG_I2C_MUX=y
+CONFIG_I2C_RK3X=y
+CONFIG_I2C_CROS_EC_TUNNEL=y
+CONFIG_SPI=y
+CONFIG_SPI_BITBANG=y
+CONFIG_SPI_ROCKCHIP=y
+CONFIG_SPI_SPIDEV=y
+CONFIG_DEBUG_GPIO=y
+CONFIG_GPIO_SYSFS=y
+CONFIG_GPIO_GENERIC_PLATFORM=y
+CONFIG_GPIO_RK8XX=y
+CONFIG_BATTERY_SBS=y
+CONFIG_CHARGER_GPIO=y
+CONFIG_CHARGER_BQ24735=y
+CONFIG_BATTERY_RK817=y
+CONFIG_CHARGER_RK817=y
+CONFIG_POWER_RESET_GPIO=y
+CONFIG_POWER_RESET_GPIO_RESTART=y
+CONFIG_SYSCON_REBOOT_MODE=y
+CONFIG_POWER_AVS=y
+CONFIG_ROCKCHIP_IODOMAIN=y
+CONFIG_THERMAL=y
+CONFIG_THERMAL_WRITABLE_TRIPS=y
+CONFIG_THERMAL_DEFAULT_GOV_POWER_ALLOCATOR=y
+CONFIG_THERMAL_GOV_FAIR_SHARE=y
+CONFIG_THERMAL_GOV_STEP_WISE=y
+CONFIG_CPU_THERMAL=y
+CONFIG_DEVFREQ_THERMAL=y
+CONFIG_ROCKCHIP_THERMAL=y
+CONFIG_WATCHDOG=y
+CONFIG_DW_WATCHDOG=y
+CONFIG_MFD_CROS_EC=y
+CONFIG_MFD_CROS_EC_SPI=y
+CONFIG_MFD_RK808=y
+CONFIG_SEND_POWEROFF_SIGNAL=y
+CONFIG_MFD_TPS6586X=y
+CONFIG_FUSB_30X=y
+CONFIG_REGULATOR=y
+CONFIG_REGULATOR_DEBUG=y
+CONFIG_REGULATOR_FIXED_VOLTAGE=y
+CONFIG_REGULATOR_ACT8865=y
+CONFIG_REGULATOR_FAN53555=y
+CONFIG_REGULATOR_GPIO=y
+CONFIG_REGULATOR_LP8752=y
+CONFIG_REGULATOR_MP8865=y
+CONFIG_REGULATOR_PWM=y
+CONFIG_REGULATOR_RK808=y
+CONFIG_REGULATOR_RK818=y
+CONFIG_REGULATOR_TPS6586X=y
+CONFIG_REGULATOR_XZ3216=y
+CONFIG_MEDIA_SUPPORT=y
+CONFIG_MEDIA_CAMERA_SUPPORT=y
+CONFIG_MEDIA_RC_SUPPORT=y
+CONFIG_MEDIA_CEC_SUPPORT=y
+CONFIG_MEDIA_CONTROLLER=y
+CONFIG_VIDEO_V4L2_SUBDEV_API=y
+# CONFIG_IR_RC5_DECODER is not set
+# CONFIG_IR_RC6_DECODER is not set
+# CONFIG_IR_JVC_DECODER is not set
+# CONFIG_IR_SONY_DECODER is not set
+# CONFIG_IR_SANYO_DECODER is not set
+# CONFIG_IR_SHARP_DECODER is not set
+# CONFIG_IR_MCE_KBD_DECODER is not set
+# CONFIG_IR_XMP_DECODER is not set
+CONFIG_MEDIA_USB_SUPPORT=y
+CONFIG_USB_VIDEO_CLASS=y
+# CONFIG_USB_VIDEO_CLASS_INPUT_EVDEV is not set
+# CONFIG_USB_GSPCA is not set
+CONFIG_V4L_PLATFORM_DRIVERS=y
+CONFIG_SOC_CAMERA=y
+CONFIG_VIDEO_ROCKCHIP_ISP1=y
+CONFIG_V4L_MEM2MEM_DRIVERS=y
+CONFIG_VIDEO_ROCKCHIP_RGA=y
+# CONFIG_MEDIA_SUBDRV_AUTOSELECT is not set
+# CONFIG_VIDEO_IR_I2C is not set
+CONFIG_VIDEO_TC35874X=y
+CONFIG_VIDEO_OV4689=y
+CONFIG_VIDEO_OV13850=y
+CONFIG_VIDEO_VM149C=y
+# CONFIG_DVB_AU8522_V4L is not set
+# CONFIG_DVB_TUNER_DIB0070 is not set
+# CONFIG_DVB_TUNER_DIB0090 is not set
+# CONFIG_VGA_ARB is not set
+CONFIG_DRM=y
+CONFIG_DRM_LOAD_EDID_FIRMWARE=y
+CONFIG_DRM_DMA_SYNC=y
+CONFIG_DRM_ROCKCHIP=y
+CONFIG_ROCKCHIP_DRM_DEBUG=y
+CONFIG_ROCKCHIP_CDN_DP=y
+CONFIG_ROCKCHIP_DW_HDMI=y
+CONFIG_ROCKCHIP_DW_MIPI_DSI=y
+CONFIG_DRM_ROCKCHIP_DSI=y
+CONFIG_ROCKCHIP_ANALOGIX_DP=y
+CONFIG_ROCKCHIP_INNO_HDMI=y
+CONFIG_ROCKCHIP_LVDS=y
+CONFIG_ROCKCHIP_DRM_TVE=y
+CONFIG_ROCKCHIP_RGB=y
+CONFIG_DRM_PANEL_SIMPLE=y
+CONFIG_DRM_DW_HDMI_I2S_AUDIO=y
+CONFIG_DRM_DW_HDMI_CEC=y
+CONFIG_MALI400=y
+CONFIG_MALI450=y
+# CONFIG_MALI400_PROFILING is not set
+CONFIG_MALI_SHARED_INTERRUPTS=y
+CONFIG_MALI_DT=y
+CONFIG_MALI_DEVFREQ=y
+CONFIG_MALI_MIDGARD_FOR_LINUX=y
+CONFIG_MALI_MIDGARD=y
+CONFIG_MALI_EXPERT=y
+CONFIG_MALI_PLATFORM_THIRDPARTY=y
+CONFIG_MALI_PLATFORM_THIRDPARTY_NAME="rk"
+CONFIG_MALI_DEBUG=y
+CONFIG_MALI_PWRSOFT_765=y
+CONFIG_MALI_BIFROST_FOR_LINUX=y
+CONFIG_BACKLIGHT_LCD_SUPPORT=y
+# CONFIG_LCD_CLASS_DEVICE is not set
+CONFIG_BACKLIGHT_CLASS_DEVICE=y
+CONFIG_BACKLIGHT_PWM=y
+CONFIG_ROCKCHIP_RGA2=y
+CONFIG_RK_VCODEC=y
+CONFIG_ROCKCHIP_MPP_SERVICE=y
+CONFIG_ROCKCHIP_MPP_DEVICE=y
+CONFIG_SOUND=y
+CONFIG_SND=y
+CONFIG_SND_SEQUENCER=y
+CONFIG_SND_SEQ_DUMMY=y
+CONFIG_SND_HRTIMER=y
+CONFIG_SND_DYNAMIC_MINORS=y
+# CONFIG_SND_SUPPORT_OLD_API is not set
+# CONFIG_SND_PCI is not set
+# CONFIG_SND_SPI is not set
+CONFIG_SND_USB_AUDIO=y
+CONFIG_SND_SOC=y
+CONFIG_SND_SOC_ROCKCHIP=y
+CONFIG_SND_SOC_ROCKCHIP_SPDIF=y
+CONFIG_SND_SOC_ROCKCHIP_MAX98090=y
+CONFIG_SND_SOC_ROCKCHIP_MULTICODECS=y
+CONFIG_SND_SOC_ROCKCHIP_RT5645=y
+CONFIG_SND_SOC_ES8316=y
+CONFIG_SND_SOC_ES8388=y
+CONFIG_SND_SOC_RK3328=y
+CONFIG_SND_SOC_RK817=y
+CONFIG_SND_SOC_RT5616=y
+CONFIG_SND_SOC_RT5640=y
+CONFIG_SND_SOC_RT5651=y
+CONFIG_SND_SOC_SPDIF=y
+CONFIG_SND_SIMPLE_CARD=y
+CONFIG_HID_BATTERY_STRENGTH=y
+CONFIG_HIDRAW=y
+CONFIG_UHID=y
+CONFIG_HID_KENSINGTON=y
+CONFIG_HID_MULTITOUCH=y
+CONFIG_USB_HIDDEV=y
+CONFIG_I2C_HID=y
+CONFIG_USB_ANNOUNCE_NEW_DEVICES=y
+# CONFIG_USB_DEFAULT_PERSIST is not set
+CONFIG_USB_OTG=y
+CONFIG_USB_MON=y
+CONFIG_USB_XHCI_HCD=y
+CONFIG_USB_EHCI_HCD=y
+CONFIG_USB_EHCI_ROOT_HUB_TT=y
+CONFIG_USB_EHCI_HCD_PLATFORM=y
+CONFIG_USB_OHCI_HCD=y
+# CONFIG_USB_OHCI_HCD_PCI is not set
+CONFIG_USB_OHCI_HCD_PLATFORM=y
+CONFIG_USB_ACM=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_UAS=y
+CONFIG_USB_DWC3=y
+# CONFIG_USB_DWC3_PCI is not set
+CONFIG_USB_DWC2=y
+CONFIG_USB_SERIAL=y
+CONFIG_USB_SERIAL_GENERIC=y
+CONFIG_USB_SERIAL_CP210X=y
+CONFIG_USB_SERIAL_FTDI_SIO=y
+CONFIG_USB_SERIAL_KEYSPAN=y
+CONFIG_USB_SERIAL_PL2303=y
+CONFIG_USB_SERIAL_OTI6858=y
+CONFIG_USB_SERIAL_QUALCOMM=y
+CONFIG_USB_SERIAL_SIERRAWIRELESS=y
+CONFIG_USB_SERIAL_OPTION=y
+CONFIG_USB_GADGET=y
+CONFIG_USB_GADGET_DEBUG_FILES=y
+CONFIG_USB_GADGET_VBUS_DRAW=500
+CONFIG_USB_CONFIGFS=y
+CONFIG_USB_CONFIGFS_ACM=y
+CONFIG_USB_CONFIGFS_MASS_STORAGE=y
+CONFIG_USB_CONFIGFS_F_FS=y
+CONFIG_USB_CONFIGFS_UEVENT=y
+CONFIG_MMC=y
+CONFIG_MMC_BLOCK_MINORS=32
+CONFIG_MMC_TEST=y
+CONFIG_MMC_SDHCI=y
+CONFIG_MMC_SDHCI_PLTFM=y
+CONFIG_MMC_SDHCI_OF_ARASAN=y
+CONFIG_MMC_DW=y
+CONFIG_MMC_DW_ROCKCHIP=y
+CONFIG_NEW_LEDS=y
+CONFIG_LEDS_CLASS=y
+CONFIG_LEDS_GPIO=y
+CONFIG_LEDS_IS31FL32XX=y
+CONFIG_SWITCH=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_DRV_HYM8563=y
+CONFIG_DMADEVICES=y
+CONFIG_PL330_DMA=y
+CONFIG_STAGING=y
+CONFIG_SENSORS_ISL29018=y
+CONFIG_TSL2583=y
+# CONFIG_ANDROID_TIMED_OUTPUT is not set
+CONFIG_FIQ_DEBUGGER=y
+CONFIG_FIQ_DEBUGGER_NO_SLEEP=y
+CONFIG_FIQ_DEBUGGER_CONSOLE=y
+CONFIG_FIQ_DEBUGGER_CONSOLE_DEFAULT_ENABLE=y
+CONFIG_COMMON_CLK_RK808=y
+CONFIG_MAILBOX=y
+CONFIG_ROCKCHIP_IOMMU=y
+CONFIG_ROCKCHIP_PM_DOMAINS=y
+CONFIG_ROCKCHIP_PVTM=y
+CONFIG_ROCKCHIP_SUSPEND_MODE=y
+CONFIG_PM_DEVFREQ=y
+CONFIG_DEVFREQ_GOV_PERFORMANCE=y
+CONFIG_DEVFREQ_GOV_POWERSAVE=y
+CONFIG_DEVFREQ_GOV_USERSPACE=y
+CONFIG_ARM_ROCKCHIP_DMC_DEVFREQ=y
+CONFIG_PM_DEVFREQ_EVENT=y
+CONFIG_MEMORY=y
+CONFIG_IIO=y
+CONFIG_IIO_BUFFER=y
+CONFIG_IIO_KFIFO_BUF=y
+CONFIG_IIO_TRIGGER=y
+CONFIG_ROCKCHIP_SARADC=y
+CONFIG_SENSORS_TSL2563=y
+CONFIG_IIO_SYSFS_TRIGGER=y
+CONFIG_PWM=y
+CONFIG_PWM_ROCKCHIP=y
+CONFIG_PHY_ROCKCHIP_USB=y
+CONFIG_PHY_ROCKCHIP_INNO_USB2=y
+CONFIG_PHY_ROCKCHIP_INNO_USB3=y
+CONFIG_PHY_ROCKCHIP_EMMC=y
+CONFIG_PHY_ROCKCHIP_DP=y
+CONFIG_PHY_ROCKCHIP_INNO_MIPI_DPHY=y
+CONFIG_PHY_ROCKCHIP_INNO_HDMI_PHY=y
+CONFIG_PHY_ROCKCHIP_INNO_VIDEO_COMBO_PHY=y
+CONFIG_PHY_ROCKCHIP_TYPEC=y
+CONFIG_PHY_ROCKCHIP_PCIE=y
+CONFIG_ANDROID=y
+CONFIG_NVMEM=y
+CONFIG_ROCKCHIP_EFUSE=y
+CONFIG_RK_HEADSET=y
+CONFIG_ROCKCHIP_SIP=y
+# CONFIG_ACPI is not set
+CONFIG_EXT4_FS=y
+CONFIG_EXT4_FS_POSIX_ACL=y
+CONFIG_EXT4_FS_SECURITY=y
+CONFIG_XFS_FS=y
+# CONFIG_DNOTIFY is not set
+CONFIG_FUSE_FS=y
+CONFIG_ISO9660_FS=y
+CONFIG_JOLIET=y
+CONFIG_ZISOFS=y
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=936
+CONFIG_FAT_DEFAULT_IOCHARSET="utf8"
+CONFIG_NTFS_FS=y
+CONFIG_TMPFS=y
+CONFIG_TMPFS_POSIX_ACL=y
+CONFIG_SQUASHFS=y
+CONFIG_PSTORE=y
+CONFIG_PSTORE_CONSOLE=y
+CONFIG_PSTORE_RAM=y
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3_ACL=y
+CONFIG_NFS_V4=y
+CONFIG_NFS_SWAP=y
+CONFIG_NLS_DEFAULT="utf8"
+CONFIG_NLS_CODEPAGE_437=y
+CONFIG_NLS_CODEPAGE_936=y
+CONFIG_NLS_ASCII=y
+CONFIG_NLS_ISO8859_1=y
+CONFIG_NLS_UTF8=y
+CONFIG_PRINTK_TIME=y
+CONFIG_DYNAMIC_DEBUG=y
+CONFIG_DEBUG_INFO=y
+CONFIG_MAGIC_SYSRQ=y
+CONFIG_MAGIC_SYSRQ_DEFAULT_ENABLE=0
+CONFIG_LOCKUP_DETECTOR=y
+CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC=y
+CONFIG_BOOTPARAM_HUNG_TASK_PANIC=y
+CONFIG_SCHEDSTATS=y
+CONFIG_TIMER_STATS=y
+CONFIG_DEBUG_SPINLOCK=y
+CONFIG_DEBUG_CREDENTIALS=y
+CONFIG_RCU_CPU_STALL_TIMEOUT=60
+CONFIG_FUNCTION_TRACER=y
+CONFIG_BLK_DEV_IO_TRACE=y
+CONFIG_LKDTM=y
+CONFIG_STRICT_DEVMEM=y
+CONFIG_DEBUG_SET_MODULE_RONX=y
+# CONFIG_CRYPTO_ECHAINIV is not set
+CONFIG_CRYPTO_MD5=y
+CONFIG_CRYPTO_SHA512=y
+CONFIG_CRYPTO_TWOFISH=y
+CONFIG_CRYPTO_ANSI_CPRNG=y
+CONFIG_CRYPTO_USER_API_HASH=y
+CONFIG_CRYPTO_USER_API_SKCIPHER=y
+CONFIG_ASYMMETRIC_KEY_TYPE=y
+CONFIG_ASYMMETRIC_PUBLIC_KEY_SUBTYPE=y
+CONFIG_X509_CERTIFICATE_PARSER=y
+CONFIG_PKCS7_MESSAGE_PARSER=y
+CONFIG_SYSTEM_TRUSTED_KEYRING=y
+CONFIG_ARM64_CRYPTO=y
+CONFIG_CRYPTO_SHA1_ARM64_CE=y
+CONFIG_CRYPTO_SHA2_ARM64_CE=y
+CONFIG_CRYPTO_GHASH_ARM64_CE=y
+CONFIG_CRYPTO_AES_ARM64_CE_CCM=y
+CONFIG_CRYPTO_AES_ARM64_CE_BLK=y
+CONFIG_CRC_T10DIF=y
+CONFIG_CRC7=y
+# CONFIG_XZ_DEC_X86 is not set
+# CONFIG_XZ_DEC_POWERPC is not set
+# CONFIG_XZ_DEC_IA64 is not set
+# CONFIG_XZ_DEC_SPARC is not set
diff --git a/arch/arm64/configs/hm3399_v2r0_linux_defconfig b/arch/arm64/configs/hm3399_v2r0_linux_defconfig
new file mode 100755
index 00000000..5930a599
--- /dev/null
+++ b/arch/arm64/configs/hm3399_v2r0_linux_defconfig
@@ -0,0 +1,561 @@
+CONFIG_DEFAULT_HOSTNAME="localhost"
+CONFIG_SYSVIPC=y
+CONFIG_FHANDLE=y
+CONFIG_NO_HZ=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_LOG_BUF_SHIFT=18
+CONFIG_CGROUPS=y
+CONFIG_CGROUP_FREEZER=y
+CONFIG_CGROUP_DEVICE=y
+CONFIG_CPUSETS=y
+CONFIG_CGROUP_CPUACCT=y
+CONFIG_CGROUP_SCHED=y
+CONFIG_CFS_BANDWIDTH=y
+CONFIG_NAMESPACES=y
+CONFIG_USER_NS=y
+CONFIG_DEFAULT_USE_ENERGY_AWARE=y
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_EMBEDDED=y
+# CONFIG_COMPAT_BRK is not set
+CONFIG_PROFILING=y
+CONFIG_MODULES=y
+CONFIG_MODULE_FORCE_LOAD=y
+CONFIG_MODULE_UNLOAD=y
+CONFIG_MODULE_FORCE_UNLOAD=y
+CONFIG_PARTITION_ADVANCED=y
+CONFIG_ARCH_ROCKCHIP=y
+CONFIG_PCI=y
+CONFIG_PCI_MSI=y
+CONFIG_PCIE_ROCKCHIP=y
+CONFIG_PCIEPORTBUS=y
+CONFIG_PCIEASPM_POWERSAVE=y
+# CONFIG_ARM64_ERRATUM_826319 is not set
+# CONFIG_ARM64_ERRATUM_827319 is not set
+# CONFIG_ARM64_ERRATUM_824069 is not set
+# CONFIG_ARM64_ERRATUM_819472 is not set
+# CONFIG_ARM64_ERRATUM_832075 is not set
+# CONFIG_CAVIUM_ERRATUM_22375 is not set
+# CONFIG_CAVIUM_ERRATUM_23154 is not set
+CONFIG_SCHED_MC=y
+CONFIG_NR_CPUS=8
+CONFIG_PREEMPT_VOLUNTARY=y
+CONFIG_HZ_1000=y
+# CONFIG_COMPACTION is not set
+CONFIG_DEFAULT_MMAP_MIN_ADDR=32768
+CONFIG_ZSMALLOC=y
+CONFIG_SECCOMP=y
+CONFIG_ARMV8_DEPRECATED=y
+CONFIG_SWP_EMULATION=y
+CONFIG_CP15_BARRIER_EMULATION=y
+CONFIG_SETEND_EMULATION=y
+# CONFIG_EFI is not set
+CONFIG_COMPAT=y
+CONFIG_PM_DEBUG=y
+CONFIG_PM_ADVANCED_DEBUG=y
+CONFIG_WQ_POWER_EFFICIENT_DEFAULT=y
+CONFIG_CPU_IDLE=y
+CONFIG_ARM_CPUIDLE=y
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_DEFAULT_GOV_INTERACTIVE=y
+CONFIG_CPU_FREQ_GOV_PERFORMANCE=y
+CONFIG_CPU_FREQ_GOV_POWERSAVE=y
+CONFIG_CPU_FREQ_GOV_USERSPACE=y
+CONFIG_CPU_FREQ_GOV_ONDEMAND=y
+CONFIG_CPU_FREQ_GOV_CONSERVATIVE=y
+CONFIG_CPUFREQ_DT=y
+CONFIG_ARM_ROCKCHIP_CPUFREQ=y
+CONFIG_NET=y
+CONFIG_PACKET=y
+CONFIG_UNIX=y
+CONFIG_XFRM_USER=y
+CONFIG_NET_KEY=y
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+CONFIG_IP_ADVANCED_ROUTER=y
+CONFIG_IP_MROUTE=y
+CONFIG_SYN_COOKIES=y
+# CONFIG_INET_XFRM_MODE_TRANSPORT is not set
+# CONFIG_INET_XFRM_MODE_TUNNEL is not set
+# CONFIG_INET_XFRM_MODE_BEET is not set
+# CONFIG_INET_LRO is not set
+# CONFIG_INET_DIAG is not set
+# CONFIG_INET6_XFRM_MODE_TRANSPORT is not set
+# CONFIG_INET6_XFRM_MODE_TUNNEL is not set
+# CONFIG_INET6_XFRM_MODE_BEET is not set
+# CONFIG_IPV6_SIT is not set
+# CONFIG_ANDROID_PARANOID_NETWORK is not set
+CONFIG_BT=y
+CONFIG_BT_RFCOMM=y
+CONFIG_BT_HIDP=y
+CONFIG_BT_HCIBTUSB=y
+CONFIG_BT_HCIBFUSB=y
+CONFIG_BT_HCIVHCI=y
+CONFIG_BT_MRVL=y
+CONFIG_BT_MRVL_SDIO=y
+CONFIG_NL80211_TESTMODE=y
+CONFIG_CFG80211_DEBUGFS=y
+CONFIG_CFG80211_WEXT=y
+CONFIG_MAC80211_LEDS=y
+CONFIG_MAC80211_DEBUGFS=y
+CONFIG_MAC80211_DEBUG_MENU=y
+CONFIG_MAC80211_VERBOSE_DEBUG=y
+CONFIG_RFKILL=y
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+CONFIG_DEBUG_DEVRES=y
+CONFIG_CONNECTOR=y
+CONFIG_ZRAM=y
+CONFIG_BLK_DEV_LOOP=y
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=1
+CONFIG_BLK_DEV_NVME=y
+CONFIG_ROCKCHIP_SCR=y
+CONFIG_SRAM=y
+CONFIG_SCSI=y
+CONFIG_BLK_DEV_SD=y
+CONFIG_BLK_DEV_SR=y
+CONFIG_SCSI_SCAN_ASYNC=y
+CONFIG_SCSI_SPI_ATTRS=y
+CONFIG_MD=y
+CONFIG_NETDEVICES=y
+# CONFIG_NET_VENDOR_3COM is not set
+# CONFIG_NET_VENDOR_ADAPTEC is not set
+# CONFIG_NET_VENDOR_AGERE is not set
+# CONFIG_NET_VENDOR_ALTEON is not set
+# CONFIG_NET_VENDOR_AMD is not set
+# CONFIG_NET_VENDOR_ARC is not set
+# CONFIG_NET_VENDOR_ATHEROS is not set
+# CONFIG_NET_CADENCE is not set
+# CONFIG_NET_VENDOR_BROADCOM is not set
+# CONFIG_NET_VENDOR_BROCADE is not set
+# CONFIG_NET_VENDOR_CAVIUM is not set
+# CONFIG_NET_VENDOR_CHELSIO is not set
+# CONFIG_NET_VENDOR_CISCO is not set
+# CONFIG_NET_VENDOR_DEC is not set
+# CONFIG_NET_VENDOR_DLINK is not set
+# CONFIG_NET_VENDOR_EMULEX is not set
+# CONFIG_NET_VENDOR_EZCHIP is not set
+# CONFIG_NET_VENDOR_EXAR is not set
+# CONFIG_NET_VENDOR_HISILICON is not set
+# CONFIG_NET_VENDOR_HP is not set
+# CONFIG_NET_VENDOR_INTEL is not set
+# CONFIG_NET_VENDOR_MARVELL is not set
+# CONFIG_NET_VENDOR_MELLANOX is not set
+# CONFIG_NET_VENDOR_MICREL is not set
+# CONFIG_NET_VENDOR_MICROCHIP is not set
+# CONFIG_NET_VENDOR_MYRI is not set
+# CONFIG_NET_VENDOR_NATSEMI is not set
+# CONFIG_NET_VENDOR_NVIDIA is not set
+# CONFIG_NET_VENDOR_OKI is not set
+# CONFIG_NET_PACKET_ENGINE is not set
+# CONFIG_NET_VENDOR_QLOGIC is not set
+# CONFIG_NET_VENDOR_QUALCOMM is not set
+# CONFIG_NET_VENDOR_REALTEK is not set
+# CONFIG_NET_VENDOR_RENESAS is not set
+# CONFIG_NET_VENDOR_RDC is not set
+# CONFIG_NET_VENDOR_ROCKER is not set
+# CONFIG_NET_VENDOR_SAMSUNG is not set
+# CONFIG_NET_VENDOR_SEEQ is not set
+# CONFIG_NET_VENDOR_SILAN is not set
+# CONFIG_NET_VENDOR_SIS is not set
+# CONFIG_NET_VENDOR_SMSC is not set
+CONFIG_STMMAC_ETH=y
+# CONFIG_NET_VENDOR_SUN is not set
+# CONFIG_NET_VENDOR_SYNOPSYS is not set
+# CONFIG_NET_VENDOR_TEHUTI is not set
+# CONFIG_NET_VENDOR_TI is not set
+# CONFIG_NET_VENDOR_VIA is not set
+# CONFIG_NET_VENDOR_WIZNET is not set
+CONFIG_ROCKCHIP_PHY=y
+CONFIG_PPP=y
+CONFIG_PPP_BSDCOMP=y
+CONFIG_PPP_DEFLATE=y
+CONFIG_PPP_FILTER=y
+CONFIG_PPP_MPPE=y
+CONFIG_PPP_MULTILINK=y
+CONFIG_PPPOE=y
+CONFIG_PPPOLAC=y
+CONFIG_PPPOPNS=y
+CONFIG_PPP_ASYNC=y
+CONFIG_PPP_SYNC_TTY=y
+CONFIG_SLIP=y
+CONFIG_SLIP_COMPRESSED=y
+CONFIG_USB_RTL8150=y
+CONFIG_USB_RTL8152=y
+CONFIG_USB_NET_CDC_MBIM=y
+# CONFIG_USB_NET_NET1080 is not set
+# CONFIG_USB_NET_CDC_SUBSET is not set
+# CONFIG_USB_NET_ZAURUS is not set
+CONFIG_LIBERTAS_THINFIRM=y
+CONFIG_USB_NET_RNDIS_WLAN=y
+CONFIG_WL_ROCKCHIP=y
+CONFIG_WIFI_BUILD_MODULE=y
+CONFIG_RTL8723BU=m
+CONFIG_MWIFIEX=m
+CONFIG_MWIFIEX_SDIO=m
+CONFIG_INPUT_FF_MEMLESS=y
+# CONFIG_INPUT_MOUSEDEV is not set
+CONFIG_INPUT_EVDEV=y
+CONFIG_KEYBOARD_ADC=y
+# CONFIG_KEYBOARD_ATKBD is not set
+CONFIG_KEYBOARD_GPIO=y
+CONFIG_KEYBOARD_GPIO_POLLED=y
+CONFIG_KEYBOARD_ROCKCHIP=y
+CONFIG_KEYBOARD_CROS_EC=y
+# CONFIG_MOUSE_PS2 is not set
+CONFIG_MOUSE_CYAPA=y
+CONFIG_MOUSE_ELAN_I2C=y
+CONFIG_INPUT_TOUCHSCREEN=y
+CONFIG_TOUCHSCREEN_ATMEL_MXT=y
+CONFIG_TOUCHSCREEN_GSLX680_VR=y
+CONFIG_TOUCHSCREEN_GSL3673=y
+CONFIG_TOUCHSCREEN_GT9XX=y
+CONFIG_TOUCHSCREEN_ELAN=y
+CONFIG_TOUCHSCREEN_USB_COMPOSITE=y
+CONFIG_TOUCHSCREEN_GT1X=y
+CONFIG_ROCKCHIP_REMOTECTL=y
+CONFIG_ROCKCHIP_REMOTECTL_PWM=y
+CONFIG_INPUT_MISC=y
+CONFIG_INPUT_RK8XX_PWRKEY=y
+CONFIG_INPUT_UINPUT=y
+CONFIG_INPUT_GPIO=y
+# CONFIG_SERIO is not set
+CONFIG_VT_HW_CONSOLE_BINDING=y
+CONFIG_DEVPTS_MULTIPLE_INSTANCES=y
+# CONFIG_LEGACY_PTYS is not set
+# CONFIG_DEVKMEM is not set
+CONFIG_SERIAL_8250=y
+CONFIG_SERIAL_8250_CONSOLE=y
+# CONFIG_SERIAL_8250_PCI is not set
+CONFIG_SERIAL_8250_NR_UARTS=5
+CONFIG_SERIAL_8250_RUNTIME_UARTS=5
+CONFIG_SERIAL_8250_DW=y
+CONFIG_SERIAL_OF_PLATFORM=y
+CONFIG_HW_RANDOM=y
+CONFIG_TCG_TPM=y
+CONFIG_TCG_TIS_I2C_INFINEON=y
+CONFIG_I2C_CHARDEV=y
+CONFIG_I2C_MUX=y
+CONFIG_I2C_RK3X=y
+CONFIG_I2C_CROS_EC_TUNNEL=y
+CONFIG_SPI=y
+CONFIG_SPI_BITBANG=y
+CONFIG_SPI_ROCKCHIP=y
+CONFIG_SPI_SPIDEV=y
+CONFIG_DEBUG_GPIO=y
+CONFIG_GPIO_SYSFS=y
+CONFIG_GPIO_GENERIC_PLATFORM=y
+CONFIG_GPIO_RK8XX=y
+CONFIG_BATTERY_SBS=y
+CONFIG_CHARGER_GPIO=y
+CONFIG_CHARGER_BQ24735=y
+CONFIG_BATTERY_RK817=y
+CONFIG_CHARGER_RK817=y
+CONFIG_POWER_RESET_GPIO=y
+CONFIG_POWER_RESET_GPIO_RESTART=y
+CONFIG_SYSCON_REBOOT_MODE=y
+CONFIG_POWER_AVS=y
+CONFIG_ROCKCHIP_IODOMAIN=y
+CONFIG_THERMAL=y
+CONFIG_THERMAL_WRITABLE_TRIPS=y
+CONFIG_THERMAL_DEFAULT_GOV_POWER_ALLOCATOR=y
+CONFIG_THERMAL_GOV_FAIR_SHARE=y
+CONFIG_THERMAL_GOV_STEP_WISE=y
+CONFIG_CPU_THERMAL=y
+CONFIG_DEVFREQ_THERMAL=y
+CONFIG_ROCKCHIP_THERMAL=y
+CONFIG_WATCHDOG=y
+CONFIG_DW_WATCHDOG=y
+CONFIG_MFD_CROS_EC=y
+CONFIG_MFD_CROS_EC_SPI=y
+CONFIG_MFD_RK808=y
+CONFIG_SEND_POWEROFF_SIGNAL=y
+CONFIG_MFD_TPS6586X=y
+CONFIG_FUSB_30X=y
+CONFIG_REGULATOR=y
+CONFIG_REGULATOR_DEBUG=y
+CONFIG_REGULATOR_FIXED_VOLTAGE=y
+CONFIG_REGULATOR_ACT8865=y
+CONFIG_REGULATOR_FAN53555=y
+CONFIG_REGULATOR_GPIO=y
+CONFIG_REGULATOR_LP8752=y
+CONFIG_REGULATOR_MP8865=y
+CONFIG_REGULATOR_PWM=y
+CONFIG_REGULATOR_RK808=y
+CONFIG_REGULATOR_RK818=y
+CONFIG_REGULATOR_TPS6586X=y
+CONFIG_REGULATOR_XZ3216=y
+CONFIG_MEDIA_SUPPORT=y
+CONFIG_MEDIA_CAMERA_SUPPORT=y
+CONFIG_MEDIA_RC_SUPPORT=y
+CONFIG_MEDIA_CEC_SUPPORT=y
+CONFIG_MEDIA_CONTROLLER=y
+CONFIG_VIDEO_V4L2_SUBDEV_API=y
+# CONFIG_IR_RC5_DECODER is not set
+# CONFIG_IR_RC6_DECODER is not set
+# CONFIG_IR_JVC_DECODER is not set
+# CONFIG_IR_SONY_DECODER is not set
+# CONFIG_IR_SANYO_DECODER is not set
+# CONFIG_IR_SHARP_DECODER is not set
+# CONFIG_IR_MCE_KBD_DECODER is not set
+# CONFIG_IR_XMP_DECODER is not set
+CONFIG_MEDIA_USB_SUPPORT=y
+CONFIG_USB_VIDEO_CLASS=y
+# CONFIG_USB_VIDEO_CLASS_INPUT_EVDEV is not set
+# CONFIG_USB_GSPCA is not set
+CONFIG_V4L_PLATFORM_DRIVERS=y
+CONFIG_SOC_CAMERA=y
+CONFIG_VIDEO_ROCKCHIP_ISP1=y
+CONFIG_V4L_MEM2MEM_DRIVERS=y
+CONFIG_VIDEO_ROCKCHIP_RGA=y
+# CONFIG_MEDIA_SUBDRV_AUTOSELECT is not set
+# CONFIG_VIDEO_IR_I2C is not set
+CONFIG_VIDEO_TC35874X=y
+CONFIG_VIDEO_OV4689=y
+CONFIG_VIDEO_OV13850=y
+CONFIG_VIDEO_VM149C=y
+# CONFIG_DVB_AU8522_V4L is not set
+# CONFIG_DVB_TUNER_DIB0070 is not set
+# CONFIG_DVB_TUNER_DIB0090 is not set
+# CONFIG_VGA_ARB is not set
+CONFIG_DRM=y
+CONFIG_DRM_LOAD_EDID_FIRMWARE=y
+CONFIG_DRM_DMA_SYNC=y
+CONFIG_DRM_ROCKCHIP=y
+CONFIG_ROCKCHIP_DRM_DEBUG=y
+CONFIG_ROCKCHIP_CDN_DP=y
+CONFIG_ROCKCHIP_DW_HDMI=y
+CONFIG_ROCKCHIP_DW_MIPI_DSI=y
+CONFIG_DRM_ROCKCHIP_DSI=y
+CONFIG_ROCKCHIP_ANALOGIX_DP=y
+CONFIG_ROCKCHIP_INNO_HDMI=y
+CONFIG_ROCKCHIP_LVDS=y
+CONFIG_ROCKCHIP_DRM_TVE=y
+CONFIG_ROCKCHIP_RGB=y
+CONFIG_DRM_PANEL_SIMPLE=y
+CONFIG_DRM_DW_HDMI_I2S_AUDIO=y
+CONFIG_DRM_DW_HDMI_CEC=y
+CONFIG_MALI400=y
+CONFIG_MALI450=y
+# CONFIG_MALI400_PROFILING is not set
+CONFIG_MALI_SHARED_INTERRUPTS=y
+CONFIG_MALI_DT=y
+CONFIG_MALI_DEVFREQ=y
+CONFIG_MALI_MIDGARD_FOR_LINUX=y
+CONFIG_MALI_MIDGARD=y
+CONFIG_MALI_EXPERT=y
+CONFIG_MALI_PLATFORM_THIRDPARTY=y
+CONFIG_MALI_PLATFORM_THIRDPARTY_NAME="rk"
+CONFIG_MALI_DEBUG=y
+CONFIG_MALI_PWRSOFT_765=y
+CONFIG_MALI_BIFROST_FOR_LINUX=y
+CONFIG_BACKLIGHT_LCD_SUPPORT=y
+# CONFIG_LCD_CLASS_DEVICE is not set
+CONFIG_BACKLIGHT_CLASS_DEVICE=y
+CONFIG_BACKLIGHT_PWM=y
+CONFIG_ROCKCHIP_RGA2=y
+CONFIG_RK_VCODEC=y
+CONFIG_ROCKCHIP_MPP_SERVICE=y
+CONFIG_ROCKCHIP_MPP_DEVICE=y
+CONFIG_SOUND=y
+CONFIG_SND=y
+CONFIG_SND_SEQUENCER=y
+CONFIG_SND_SEQ_DUMMY=y
+CONFIG_SND_HRTIMER=y
+CONFIG_SND_DYNAMIC_MINORS=y
+# CONFIG_SND_SUPPORT_OLD_API is not set
+# CONFIG_SND_PCI is not set
+# CONFIG_SND_SPI is not set
+CONFIG_SND_USB_AUDIO=y
+CONFIG_SND_SOC=y
+CONFIG_SND_SOC_ROCKCHIP=y
+CONFIG_SND_SOC_ROCKCHIP_SPDIF=y
+CONFIG_SND_SOC_ROCKCHIP_MAX98090=y
+CONFIG_SND_SOC_ROCKCHIP_MULTICODECS=y
+CONFIG_SND_SOC_ROCKCHIP_RT5645=y
+CONFIG_SND_SOC_ES8316=y
+CONFIG_SND_SOC_ES8388=y
+CONFIG_SND_SOC_RK3328=y
+CONFIG_SND_SOC_RK817=y
+CONFIG_SND_SOC_RT5616=y
+CONFIG_SND_SOC_RT5640=y
+CONFIG_SND_SOC_RT5651=y
+CONFIG_SND_SOC_SPDIF=y
+CONFIG_SND_SIMPLE_CARD=y
+CONFIG_HID_BATTERY_STRENGTH=y
+CONFIG_HIDRAW=y
+CONFIG_UHID=y
+CONFIG_HID_KENSINGTON=y
+CONFIG_HID_MULTITOUCH=y
+CONFIG_USB_HIDDEV=y
+CONFIG_I2C_HID=y
+CONFIG_USB_ANNOUNCE_NEW_DEVICES=y
+# CONFIG_USB_DEFAULT_PERSIST is not set
+CONFIG_USB_OTG=y
+CONFIG_USB_MON=y
+CONFIG_USB_XHCI_HCD=y
+CONFIG_USB_EHCI_HCD=y
+CONFIG_USB_EHCI_ROOT_HUB_TT=y
+CONFIG_USB_EHCI_HCD_PLATFORM=y
+CONFIG_USB_OHCI_HCD=y
+# CONFIG_USB_OHCI_HCD_PCI is not set
+CONFIG_USB_OHCI_HCD_PLATFORM=y
+CONFIG_USB_ACM=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_UAS=y
+CONFIG_USB_DWC3=y
+# CONFIG_USB_DWC3_PCI is not set
+CONFIG_USB_DWC2=y
+CONFIG_USB_SERIAL=y
+CONFIG_USB_SERIAL_GENERIC=y
+CONFIG_USB_SERIAL_CP210X=y
+CONFIG_USB_SERIAL_FTDI_SIO=y
+CONFIG_USB_SERIAL_KEYSPAN=y
+CONFIG_USB_SERIAL_PL2303=y
+CONFIG_USB_SERIAL_OTI6858=y
+CONFIG_USB_SERIAL_QUALCOMM=y
+CONFIG_USB_SERIAL_SIERRAWIRELESS=y
+CONFIG_USB_SERIAL_OPTION=y
+CONFIG_USB_GADGET=y
+CONFIG_USB_GADGET_DEBUG_FILES=y
+CONFIG_USB_GADGET_VBUS_DRAW=500
+CONFIG_USB_CONFIGFS=y
+CONFIG_USB_CONFIGFS_ACM=y
+CONFIG_USB_CONFIGFS_MASS_STORAGE=y
+CONFIG_USB_CONFIGFS_F_FS=y
+CONFIG_USB_CONFIGFS_UEVENT=y
+CONFIG_MMC=y
+CONFIG_MMC_BLOCK_MINORS=32
+CONFIG_MMC_TEST=y
+CONFIG_MMC_SDHCI=y
+CONFIG_MMC_SDHCI_PLTFM=y
+CONFIG_MMC_SDHCI_OF_ARASAN=y
+CONFIG_MMC_DW=y
+CONFIG_MMC_DW_ROCKCHIP=y
+CONFIG_NEW_LEDS=y
+CONFIG_LEDS_CLASS=y
+CONFIG_LEDS_GPIO=y
+CONFIG_LEDS_IS31FL32XX=y
+CONFIG_SWITCH=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_DRV_HYM8563=y
+CONFIG_DMADEVICES=y
+CONFIG_PL330_DMA=y
+CONFIG_STAGING=y
+CONFIG_SENSORS_ISL29018=y
+CONFIG_TSL2583=y
+# CONFIG_ANDROID_TIMED_OUTPUT is not set
+CONFIG_FIQ_DEBUGGER=y
+CONFIG_FIQ_DEBUGGER_NO_SLEEP=y
+CONFIG_FIQ_DEBUGGER_CONSOLE=y
+CONFIG_FIQ_DEBUGGER_CONSOLE_DEFAULT_ENABLE=y
+CONFIG_COMMON_CLK_RK808=y
+CONFIG_MAILBOX=y
+CONFIG_ROCKCHIP_IOMMU=y
+CONFIG_ROCKCHIP_PM_DOMAINS=y
+CONFIG_ROCKCHIP_PVTM=y
+CONFIG_ROCKCHIP_SUSPEND_MODE=y
+CONFIG_PM_DEVFREQ=y
+CONFIG_DEVFREQ_GOV_PERFORMANCE=y
+CONFIG_DEVFREQ_GOV_POWERSAVE=y
+CONFIG_DEVFREQ_GOV_USERSPACE=y
+CONFIG_ARM_ROCKCHIP_DMC_DEVFREQ=y
+CONFIG_PM_DEVFREQ_EVENT=y
+CONFIG_MEMORY=y
+CONFIG_IIO=y
+CONFIG_IIO_BUFFER=y
+CONFIG_IIO_KFIFO_BUF=y
+CONFIG_IIO_TRIGGER=y
+CONFIG_ROCKCHIP_SARADC=y
+CONFIG_SENSORS_TSL2563=y
+CONFIG_IIO_SYSFS_TRIGGER=y
+CONFIG_PWM=y
+CONFIG_PWM_ROCKCHIP=y
+CONFIG_PHY_ROCKCHIP_USB=y
+CONFIG_PHY_ROCKCHIP_INNO_USB2=y
+CONFIG_PHY_ROCKCHIP_INNO_USB3=y
+CONFIG_PHY_ROCKCHIP_EMMC=y
+CONFIG_PHY_ROCKCHIP_DP=y
+CONFIG_PHY_ROCKCHIP_INNO_MIPI_DPHY=y
+CONFIG_PHY_ROCKCHIP_INNO_HDMI_PHY=y
+CONFIG_PHY_ROCKCHIP_INNO_VIDEO_COMBO_PHY=y
+CONFIG_PHY_ROCKCHIP_TYPEC=y
+CONFIG_PHY_ROCKCHIP_PCIE=y
+CONFIG_ANDROID=y
+CONFIG_NVMEM=y
+CONFIG_ROCKCHIP_EFUSE=y
+CONFIG_RK_HEADSET=y
+CONFIG_ROCKCHIP_SIP=y
+# CONFIG_ACPI is not set
+CONFIG_EXT4_FS=y
+CONFIG_EXT4_FS_POSIX_ACL=y
+CONFIG_EXT4_FS_SECURITY=y
+CONFIG_XFS_FS=y
+# CONFIG_DNOTIFY is not set
+CONFIG_FUSE_FS=y
+CONFIG_ISO9660_FS=y
+CONFIG_JOLIET=y
+CONFIG_ZISOFS=y
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=936
+CONFIG_FAT_DEFAULT_IOCHARSET="utf8"
+CONFIG_NTFS_FS=y
+CONFIG_TMPFS=y
+CONFIG_TMPFS_POSIX_ACL=y
+CONFIG_SQUASHFS=y
+CONFIG_PSTORE=y
+CONFIG_PSTORE_CONSOLE=y
+CONFIG_PSTORE_RAM=y
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3_ACL=y
+CONFIG_NFS_V4=y
+CONFIG_NFS_SWAP=y
+CONFIG_NLS_DEFAULT="utf8"
+CONFIG_NLS_CODEPAGE_437=y
+CONFIG_NLS_CODEPAGE_936=y
+CONFIG_NLS_ASCII=y
+CONFIG_NLS_ISO8859_1=y
+CONFIG_NLS_UTF8=y
+CONFIG_PRINTK_TIME=y
+CONFIG_DYNAMIC_DEBUG=y
+CONFIG_DEBUG_INFO=y
+CONFIG_MAGIC_SYSRQ=y
+CONFIG_MAGIC_SYSRQ_DEFAULT_ENABLE=0
+CONFIG_LOCKUP_DETECTOR=y
+CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC=y
+CONFIG_BOOTPARAM_HUNG_TASK_PANIC=y
+CONFIG_SCHEDSTATS=y
+CONFIG_TIMER_STATS=y
+CONFIG_DEBUG_SPINLOCK=y
+CONFIG_DEBUG_CREDENTIALS=y
+CONFIG_RCU_CPU_STALL_TIMEOUT=60
+CONFIG_FUNCTION_TRACER=y
+CONFIG_BLK_DEV_IO_TRACE=y
+CONFIG_LKDTM=y
+CONFIG_STRICT_DEVMEM=y
+CONFIG_DEBUG_SET_MODULE_RONX=y
+# CONFIG_CRYPTO_ECHAINIV is not set
+CONFIG_CRYPTO_MD5=y
+CONFIG_CRYPTO_SHA512=y
+CONFIG_CRYPTO_TWOFISH=y
+CONFIG_CRYPTO_ANSI_CPRNG=y
+CONFIG_CRYPTO_USER_API_HASH=y
+CONFIG_CRYPTO_USER_API_SKCIPHER=y
+CONFIG_ASYMMETRIC_KEY_TYPE=y
+CONFIG_ASYMMETRIC_PUBLIC_KEY_SUBTYPE=y
+CONFIG_X509_CERTIFICATE_PARSER=y
+CONFIG_PKCS7_MESSAGE_PARSER=y
+CONFIG_SYSTEM_TRUSTED_KEYRING=y
+CONFIG_ARM64_CRYPTO=y
+CONFIG_CRYPTO_SHA1_ARM64_CE=y
+CONFIG_CRYPTO_SHA2_ARM64_CE=y
+CONFIG_CRYPTO_GHASH_ARM64_CE=y
+CONFIG_CRYPTO_AES_ARM64_CE_CCM=y
+CONFIG_CRYPTO_AES_ARM64_CE_BLK=y
+CONFIG_CRC_T10DIF=y
+CONFIG_CRC7=y
+# CONFIG_XZ_DEC_X86 is not set
+# CONFIG_XZ_DEC_POWERPC is not set
+# CONFIG_XZ_DEC_IA64 is not set
+# CONFIG_XZ_DEC_SPARC is not set
diff --git a/drivers/gpu/drm/rockchip/Kconfig b/drivers/gpu/drm/rockchip/Kconfig
old mode 100644
new mode 100755
index 9fa26977..08bd2989
--- a/drivers/gpu/drm/rockchip/Kconfig
+++ b/drivers/gpu/drm/rockchip/Kconfig
@@ -69,6 +69,14 @@ config ROCKCHIP_MIPI_CSI_TX
 	  for the rocckhip mipi CSI TX driver. If you want to
 	  enable MIPI CSI on RK1808 based SoC, you should select this
 	  option.
+	  
+config DRM_ROCKCHIP_DSI
+	bool "Synopsys DesignWare Cores MIPI-DSI Driver"
+	depends on DRM_ROCKCHIP
+	select DRM_PANEL
+	select DRM_MIPI_DSI
+	help
+	  Choose this option if you want to used Synopsys DWC MIPI-DSI for DRM.
 
 config ROCKCHIP_ANALOGIX_DP
 	tristate "Rockchip specific extensions for Analogix DP driver"
diff --git a/drivers/gpu/drm/rockchip/Makefile b/drivers/gpu/drm/rockchip/Makefile
old mode 100644
new mode 100755
index 658fef2d..dae4eb6d
--- a/drivers/gpu/drm/rockchip/Makefile
+++ b/drivers/gpu/drm/rockchip/Makefile
@@ -11,6 +11,7 @@ obj-$(CONFIG_ROCKCHIP_CDN_DP) += cdn-dp.o
 cdn-dp-objs := cdn-dp-core.o cdn-dp-reg.o cdn-dp-link-training.o
 obj-$(CONFIG_ROCKCHIP_DW_MIPI_DSI) += dw-mipi-dsi.o
 obj-$(CONFIG_ROCKCHIP_MIPI_CSI_TX) += rockchip-mipi-csi-tx.o
+obj-$(CONFIG_DRM_ROCKCHIP_DSI)	+= rockchip_drm_dsi.o
 obj-$(CONFIG_ROCKCHIP_ANALOGIX_DP) += analogix_dp-rockchip.o
 obj-$(CONFIG_ROCKCHIP_INNO_HDMI) += inno_hdmi.o
 obj-$(CONFIG_ROCKCHIP_LVDS) += rockchip_lvds.o
diff --git a/drivers/gpu/drm/rockchip/rockchip_drm_dsi.c b/drivers/gpu/drm/rockchip/rockchip_drm_dsi.c
new file mode 100755
index 00000000..6e2ba2dd
--- /dev/null
+++ b/drivers/gpu/drm/rockchip/rockchip_drm_dsi.c
@@ -0,0 +1,2133 @@
+/*
+ * Copyright (c) 2017 Rockchip Electronics Co. Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#define DEBUG
+
+#include <linux/kernel.h>
+#include <linux/clk.h>
+#include <linux/component.h>
+#include <linux/iopoll.h>
+#include <linux/math64.h>
+#include <linux/module.h>
+#include <linux/of_device.h>
+#include <linux/pm_runtime.h>
+#include <linux/regmap.h>
+#include <linux/reset.h>
+#include <linux/irq.h>
+#include <linux/mfd/syscon.h>
+#include <linux/phy/phy.h>
+#include <linux/gpio/consumer.h>
+#include <asm/unaligned.h>
+
+#include <drm/drm_atomic_helper.h>
+#include <drm/drm_crtc.h>
+#include <drm/drm_crtc_helper.h>
+#include <drm/drm_mipi_dsi.h>
+#include <drm/drm_of.h>
+#include <drm/drm_panel.h>
+#include <drm/drmP.h>
+
+#include <video/mipi_display.h>
+#include <video/videomode.h>
+
+#include "rockchip_drm_drv.h"
+#include "rockchip_drm_vop.h"
+
+#define IS_DSI0(dsi)	((dsi)->id == 0)
+#define IS_DSI1(dsi)	((dsi)->id == 1)
+
+#define UPDATE(v, h, l)		(((v) << (l)) & GENMASK((h), (l)))
+#define HIWORD_UPDATE(v, h, l)	(((v) << (l)) | (GENMASK(h, l) << 16))
+#define GRF_DESC(r, h, l)	((r << 16) | (h << 8) | (l))
+
+/* DWC MIPI DSI Host Controller Register and Field Descriptions */
+#define DSI_VERSION			0x000
+#define DSI_PWR_UP			0x004
+#define RESET				0
+#define POWER_UP			BIT(0)
+#define DSI_CLKMGR_CFG			0x008
+#define TO_CLK_DIVIDSION_MASK		GENMASK(15, 8)
+#define TO_CLK_DIVIDSION(v)		UPDATE(v, 15, 8)
+#define TX_ESC_CLK_DIVIDSION_MASK	GENMASK(7, 0)
+#define TX_ESC_CLK_DIVIDSION(v)		UPDATE(v, 7, 0)
+#define DSI_DPI_VCID			0x00c
+#define DPI_VCID(v)			UPDATE(v, 1, 0)
+#define DSI_DPI_COLOR_CODING		0x010
+#define LOOSELY18_EN(v)			UPDATE(v, 8, 8)
+#define DPI_COLOR_CODING(v)		UPDATE(v, 3, 0)
+#define DSI_DPI_CFG_POL			0x014
+#define COLORM_ACTIVE_LOW		BIT(4)
+#define SHUTD_ACTIVE_LOW		BIT(3)
+#define HSYNC_ACTIVE_LOW		BIT(2)
+#define VSYNC_ACTIVE_LOW		BIT(1)
+#define DATAEN_ACTIVE_LOW		BIT(0)
+#define DSI_DPI_LP_CMD_TIM		0x018
+#define DSI_PCKHDL_CFG			0x02c
+#define CRC_RX_EN			BIT(4)
+#define ECC_RX_EN			BIT(3)
+#define BTA_EN				BIT(2)
+#define EOTP_RX_EN			BIT(1)
+#define EOTP_TX_EN			BIT(0)
+#define DSI_GEN_VCID			0x030
+#define GEN_VCID_RX(v)			UPDATE(v, 1, 0)
+#define DSI_MODE_CFG			0x034
+#define COMMAND_MODE			BIT(0)
+#define VIDEO_MODE			0
+#define DSI_VID_MODE_CFG		0x038
+#define VPG_ORIENTATION(v)		UPDATE(v, 24, 24)
+#define VPG_MODE(v)			UPDATE(v, 20, 20)
+#define VPG_EN				BIT(16)
+#define LP_CMD_EN			BIT(15)
+#define FRAME_BTA_ACK_EN		BIT(14)
+#define LP_HFP_EN			BIT(13)
+#define LP_HBP_EN			BIT(12)
+#define LP_VACT_EN			BIT(11)
+#define LP_VFP_EN			BIT(10)
+#define LP_VBP_EN			BIT(9)
+#define LP_VSA_EN			BIT(8)
+#define VID_MODE_TYPE(v)		UPDATE(v, 1, 0)
+#define DSI_VID_PKT_SIZE		0x03c
+#define VID_PKT_SIZE(v)			UPDATE(v, 13, 0)
+#define DSI_VID_NUM_CHUMKS		0x040
+#define DSI_VID_NULL_PKT_SIZE		0x044
+#define DSI_VID_HSA_TIME		0x048
+#define VID_HSA_TIME(v)			UPDATE(v, 11, 0)
+#define DSI_VID_HBP_TIME		0x04c
+#define VID_HBP_TIME(v)			UPDATE(v, 11, 0)
+#define DSI_VID_HLINE_TIME		0x050
+#define VID_HLINE_TIME(v)		UPDATE(v, 14, 0)
+#define DSI_VID_VSA_LINES		0x054
+#define VSA_LINES(v)			UPDATE(v, 9, 0)
+#define DSI_VID_VBP_LINES		0x058
+#define VBP_LINES(v)			UPDATE(v, 9, 0)
+#define DSI_VID_VFP_LINES		0x05c
+#define VFP_LINES(v)			UPDATE(v, 9, 0)
+#define DSI_VID_VACTIVE_LINES		0x060
+#define V_ACTIVE_LINES(v)		UPDATE(v, 13, 0)
+#define DSI_CMD_MODE_CFG		0x068
+#define CMD_XFER_TYPE_LP		0x010f7f00
+#define CMD_XFER_TYPE_HS		0
+#define ACK_RQST_EN			BIT(1)
+#define TEAR_FX_EN			BIT(0)
+#define DSI_GEN_HDR			0x06c
+#define DSI_GEN_PLD_DATA		0x070
+#define DSI_CMD_PKT_STATUS		0x074
+#define GEN_RD_CMD_BUSY			BIT(6)
+#define GEN_PLD_R_FULL			BIT(5)
+#define GEN_PLD_R_EMPTY			BIT(4)
+#define GEN_PLD_W_FULL			BIT(3)
+#define GEN_PLD_W_EMPTY			BIT(2)
+#define GEN_CMD_FULL			BIT(1)
+#define GEN_CMD_EMPTY			BIT(0)
+#define DSI_TO_CNT_CFG			0x078
+#define HSTX_TO_CNT(v)			UPDATE(v, 31, 16)
+#define LPRX_TO_CNT(v)			UPDATE(v, 15, 0)
+#define DSI_HS_RD_TO_CNT		0x07c
+#define DSI_LP_RD_TO_CNT		0x080
+#define DSI_HS_WR_TO_CNT		0x084
+#define DSI_LP_WR_TO_CNT		0x088
+#define DSI_BTA_TO_CNT			0x08c
+#define DSI_LPCLK_CTRL			0x094
+#define AUTO_CLKLANE_CTRL		BIT(1)
+#define PHY_TXREQUESTCLKHS		BIT(0)
+#define DSI_PHY_TMR_LPCLK_CFG		0x098
+#define PHY_CLKHS2LP_TIME(v)		UPDATE(v, 25, 16)
+#define PHY_CLKLP2HS_TIME(v)		UPDATE(v, 9, 0)
+#define DSI_PHY_TMR_CFG			0x09c
+#define PHY_HS2LP_TIME(v)		UPDATE(v, 31, 24)
+#define PHY_LP2HS_TIME(v)		UPDATE(v, 23, 16)
+#define MAX_RD_TIME(v)			UPDATE(v, 14, 0)
+#define DSI_PHY_RSTZ			0x0a0
+#define PHY_FORCEPLL			BIT(3)
+#define PHY_ENABLECLK			BIT(2)
+#define PHY_RSTZ			BIT(1)
+#define PHY_SHUTDOWNZ			BIT(0)
+#define DSI_PHY_IF_CFG			0x0a4
+#define PHY_STOP_WAIT_TIME(v)		UPDATE(v, 15, 8)
+#define N_LANES(v)			UPDATE(v, 1, 0)
+#define PHY_ULPS_CTRL			0x0a8
+#define PHY_TXEXITULPSLAN		BIT(3)
+#define PHY_TXREQULPSLAN		BIT(2)
+#define PHY_TXEXITULPSCLK		BIT(1)
+#define PHY_TXREQULPSCLK		BIT(0)
+#define PHY_TX_TRIGGERS			0x0ac
+#define DSI_PHY_STATUS			0x0b0
+#define PHY_ULPSACTIVENOT3LANE		BIT(12)
+#define PHY_STOPSTATE3LANE		BIT(11)
+#define PHY_ULPSACTIVENOT2LANE		BIT(10)
+#define PHY_STOPSTATE2LANE		BIT(9)
+#define PHY_ULPSACTIVENOT1LANE		BIT(8)
+#define PHY_STOPSTATE1LANE		BIT(7)
+#define PHY_ULPSACTIVENOT0LANE		BIT(5)
+#define PHY_STOPSTATE0LANE		BIT(4)
+#define PHY_ULPSACTIVENOTCLK		BIT(3)
+#define PHY_STOPSTATECLKLANE		BIT(2)
+#define PHY_DIRECTION			BIT(1)
+#define PHY_LOCK			BIT(0)
+#define PHY_STOPSTATELANE		(PHY_STOPSTATE0LANE | \
+					 PHY_STOPSTATECLKLANE)
+#define DSI_PHY_TST_CTRL0		0x0b4
+#define PHY_TESTCLK			BIT(1)
+#define PHY_TESTCLR			BIT(0)
+#define DSI_PHY_TST_CTRL1		0x0b8
+#define PHY_TESTEN			BIT(16)
+#define PHY_TESTDOUT_SHIFT		8
+#define PHY_TESTDIN_MASK		GENMASK(7, 0)
+#define PHY_TESTDIN(v)			UPDATE(v, 7, 0)
+#define DSI_INT_ST0			0x0bc
+#define DSI_INT_ST1			0x0c0
+#define DSI_INT_MSK0			0x0c4
+#define DSI_INT_MSK1			0x0c8
+#define DSI_MAX_REGISGER		DSI_INT_MSK1
+
+/* PLL Input Divider Ratio */
+#define INPUT_DIV(v)		UPDATE(v, 6, 0)
+/* PLL Loop Divider Ratio */
+#define LOW_PROGRAM_EN		0
+#define HIGH_PROGRAM_EN		BIT(7)
+#define LOOP_DIV_LOW(v)		UPDATE(v, 4, 0)
+#define LOOP_DIV_HIGH(v)	UPDATE(v, 3, 0)
+/* PLL Input and Loop Divider Ratios Control */
+#define LOOP_DIV_PROGRAM_EN	BIT(5)
+#define INPUT_DIV_PROGRAM_EN	BIT(4)
+/* HS operating frequency range selection */
+#define HSFREQRANGE(v)		UPDATE(v, 6, 1)
+
+enum {
+	NON_BURST_MODE_SYNC_PULSE,
+	NON_BURST_MODE_SYNC_EVENT,
+	BURST_MODE,
+};
+
+enum {
+	PIXEL_COLOR_CODING_16BIT_1,
+	PIXEL_COLOR_CODING_16BIT_2,
+	PIXEL_COLOR_CODING_16BIT_3,
+	PIXEL_COLOR_CODING_18BIT_1,
+	PIXEL_COLOR_CODING_18BIT_2,
+	PIXEL_COLOR_CODING_24BIT,
+};
+
+enum grf_index {
+	DPIUPDATECFG,
+	DPISHUTDN,
+	DPICOLORM,
+	VOPSEL,
+	TURNREQUEST,
+	TURNDISABLE,
+	FORCETXSTOPMODE,
+	FORCERXMODE,
+	ENABLE_N,
+	MASTERSLAVEZ,
+	ENABLECLK,
+	BASEDIR,
+	NUM_GRF_DESC,
+};
+
+struct mipi_dphy {
+	/* Non-SNPS PHY */
+	struct phy *phy;
+	struct clk *hs_clk;
+
+	/* SNPS PHY */
+	struct clk *ref_clk;
+	struct clk *cfg_clk;
+	struct regmap *regmap;
+	u8 prediv;
+	u16 fbdiv;
+};
+
+struct rockchip_dsi_soc_data {
+	unsigned int min_bit_rate_per_lane;
+	unsigned int max_bit_rate_per_lane;
+	const u32 *dsi0_grf_desc;
+	const u32 *dsi1_grf_desc;
+};
+
+struct rockchip_dsi {
+	struct drm_encoder encoder;
+	struct drm_connector connector;
+	struct drm_bridge *bridge;
+	struct drm_panel *panel;
+	struct device_node *client;
+
+	/* for dual-channel mode support */
+	struct rockchip_dsi *master;
+	struct rockchip_dsi *slave;
+
+	struct device *dev;
+	void __iomem *regs;
+	struct regmap *regmap;
+	struct regmap *grf;
+	struct clk *pclk;
+	struct reset_control *rst;
+	int id;
+	int irq;
+
+	struct mipi_dsi_host host;
+	struct mipi_dphy dphy;
+	unsigned int lane_mbps;
+	unsigned int channel;
+	unsigned int lanes;
+	enum mipi_dsi_pixel_format format;
+	unsigned long mode_flags;
+	struct videomode vm;
+
+	struct gpio_desc *reset_gpio;
+	struct gpio_desc *enable_gpio;
+
+	const u32 *grf_desc;
+	const struct rockchip_dsi_soc_data *soc_data;
+};
+
+#define HSTT(_max_freq, _c_lp2hs, _c_hs2lp, _d_lp2hs, _d_hs2lp)	\
+{	\
+	.max_freq = _max_freq,	\
+	.clk_lane = {	\
+		.lp2hs = _c_lp2hs,	\
+		.hs2lp = _c_hs2lp,	\
+	},	\
+	.data_lane = {	\
+		.lp2hs = _d_lp2hs,	\
+		.hs2lp = _d_hs2lp,	\
+	},	\
+}
+
+/* Table A-3 High-Speed Transition Times */
+static const struct {
+	unsigned long max_freq;
+	struct {
+		u16 lp2hs;
+		u16 hs2lp;
+	} clk_lane;
+	struct {
+		u8 lp2hs;
+		u8 hs2lp;
+	} data_lane;
+} hstt_table[] = {
+	HSTT(90,    32, 20,  26, 13), HSTT(100,   35, 23,  28, 14),
+	HSTT(110,   32, 22,  26, 13), HSTT(130,   31, 20,  27, 13),
+	HSTT(140,   33, 22,  26, 14), HSTT(150,   33, 21,  26, 14),
+	HSTT(170,   32, 20,  27, 13), HSTT(180,   36, 23,  30, 15),
+	HSTT(200,   40, 22,  33, 15), HSTT(220,   40, 22,  33, 15),
+	HSTT(240,   44, 24,  36, 16), HSTT(250,   48, 24,  38, 17),
+	HSTT(270,   48, 24,  38, 17), HSTT(300,   50, 27,  41, 18),
+	HSTT(330,   56, 28,  45, 18), HSTT(360,   59, 28,  48, 19),
+	HSTT(400,   61, 30,  50, 20), HSTT(450,   67, 31,  55, 21),
+	HSTT(500,   73, 31,  59, 22), HSTT(550,   79, 36,  63, 24),
+	HSTT(600,   83, 37,  68, 25), HSTT(650,   90, 38,  73, 27),
+	HSTT(700,   95, 40,  77, 28), HSTT(750,  102, 40,  84, 28),
+	HSTT(800,  106, 42,  87, 30), HSTT(850,  113, 44,  93, 31),
+	HSTT(900,  118, 47,  98, 32), HSTT(950,  124, 47, 102, 34),
+	HSTT(1000, 130, 49, 107, 35), HSTT(1050, 135, 51, 111, 37),
+	HSTT(1100, 139, 51, 114, 38), HSTT(1150, 146, 54, 120, 40),
+	HSTT(1200, 153, 57, 125, 41), HSTT(1250, 158, 58, 130, 42),
+	HSTT(1300, 163, 58, 135, 44), HSTT(1350, 168, 60, 140, 45),
+	HSTT(1400, 172, 64, 144, 47), HSTT(1450, 176, 65, 148, 48),
+	HSTT(1500, 181, 66, 153, 50)
+};
+
+/* Table 5-1 Frequency Ranges */
+static const struct {
+	unsigned long max_freq;
+	u8 hsfreqrange;
+} hsfreqrange_table[] = {
+	{  90, 0x00}, { 100, 0x10}, { 110, 0x20}, { 130, 0x01},
+	{ 140, 0x11}, { 150, 0x21}, { 170, 0x02}, { 180, 0x12},
+	{ 200, 0x22}, { 220, 0x03}, { 240, 0x13}, { 250, 0x23},
+	{ 270, 0x04}, { 300, 0x14}, { 330, 0x05}, { 360, 0x15},
+	{ 400, 0x25}, { 450, 0x06}, { 500, 0x16}, { 550, 0x07},
+	{ 600, 0x17}, { 650, 0x08}, { 700, 0x18}, { 750, 0x09},
+	{ 800, 0x19}, { 850, 0x29}, { 900, 0x39}, { 950, 0x0a},
+	{1000, 0x1a}, {1050, 0x2a}, {1100, 0x3a}, {1150, 0x0b},
+	{1200, 0x1b}, {1250, 0x2b}, {1300, 0x3b}, {1350, 0x0c},
+	{1400, 0x1c}, {1450, 0x2c}, {1500, 0x3c}
+};
+
+static inline struct rockchip_dsi *host_to_dsi(struct mipi_dsi_host *h)
+{
+	return container_of(h, struct rockchip_dsi, host);
+}
+
+static inline struct rockchip_dsi *connector_to_dsi(struct drm_connector *c)
+{
+	return container_of(c, struct rockchip_dsi, connector);
+}
+
+static inline struct rockchip_dsi *encoder_to_dsi(struct drm_encoder *e)
+{
+	return container_of(e, struct rockchip_dsi, encoder);
+}
+
+static void grf_write(struct rockchip_dsi *dsi, enum grf_index index, u32 val)
+{
+	const u32 desc = dsi->grf_desc[index];
+	u16 reg;
+	u8 h, l;
+
+	if (!desc)
+		return;
+
+	reg = (desc >> 16) & 0xffff;
+	h = (desc >> 8) & 0xff;
+	l = desc & 0xff;
+	regmap_write(dsi->grf, reg, HIWORD_UPDATE(val, h, l));
+}
+
+static inline void ppi_txrequestclkhs_assert(struct rockchip_dsi *dsi)
+{
+	regmap_update_bits(dsi->regmap, DSI_LPCLK_CTRL,
+			   PHY_TXREQUESTCLKHS, PHY_TXREQUESTCLKHS);
+	udelay(1);
+}
+
+static inline void ppi_txrequestclkhs_deassert(struct rockchip_dsi *dsi)
+{
+	regmap_update_bits(dsi->regmap, DSI_LPCLK_CTRL, PHY_TXREQUESTCLKHS, 0);
+	udelay(1);
+}
+
+static int ppi_stopstatelane_asserted(struct rockchip_dsi *dsi)
+{
+	u32 v, m = PHY_STOPSTATELANE;
+
+	return readl_poll_timeout_atomic(dsi->regs + DSI_PHY_STATUS,
+					 v, (v & m) == m, 1, USEC_PER_MSEC);
+}
+
+static inline void ppi_turnrequest_assert(struct rockchip_dsi *dsi)
+{
+	grf_write(dsi, TURNREQUEST, 1);
+}
+
+static inline void ppi_turnrequest_deassert(struct rockchip_dsi *dsi)
+{
+	grf_write(dsi, TURNREQUEST, 0);
+}
+
+static inline void ppi_forcetxstopmode_assert(struct rockchip_dsi *dsi)
+{
+	grf_write(dsi, FORCETXSTOPMODE, 1);
+}
+
+static inline void ppi_forcetxstopmode_deassert(struct rockchip_dsi *dsi)
+{
+	grf_write(dsi, FORCETXSTOPMODE, 0);
+}
+
+static inline void genif_vcid_init(struct rockchip_dsi *dsi, u8 vcid)
+{
+	regmap_write(dsi->regmap, DSI_GEN_VCID, GEN_VCID_RX(vcid));
+}
+
+static int genif_wait_w_pld_fifo_not_full(struct rockchip_dsi *dsi)
+{
+	u32 v, m = GEN_PLD_W_FULL;
+
+	return readl_poll_timeout_atomic(dsi->regs + DSI_CMD_PKT_STATUS,
+					 v, !(v & m), 1, USEC_PER_MSEC);
+}
+
+static int genif_wait_cmd_fifo_not_full(struct rockchip_dsi *dsi)
+{
+	u32 v, m = GEN_CMD_FULL;
+
+	return readl_poll_timeout_atomic(dsi->regs + DSI_CMD_PKT_STATUS,
+					 v, !(v & m), 1, USEC_PER_MSEC);
+}
+
+static int genif_wait_w_fifo_is_empty(struct rockchip_dsi *dsi)
+{
+	u32 v, m = GEN_PLD_W_EMPTY | GEN_CMD_EMPTY;
+
+	return readl_poll_timeout_atomic(dsi->regs + DSI_CMD_PKT_STATUS,
+					 v, (v & m) == m, 1, USEC_PER_MSEC);
+}
+
+static int genif_wait_rd_cmd_not_busy(struct rockchip_dsi *dsi)
+{
+	u32 v, m = GEN_RD_CMD_BUSY;
+
+	return readl_relaxed_poll_timeout(dsi->regs + DSI_CMD_PKT_STATUS,
+					  v, !(v & m), 50, 5000);
+}
+
+static int genif_wait_r_pld_fifo_not_empty(struct rockchip_dsi *dsi)
+{
+	u32 v, m = GEN_PLD_R_EMPTY;
+
+	return readl_poll_timeout_atomic(dsi->regs + DSI_CMD_PKT_STATUS,
+					 v, !(v & m), 1, USEC_PER_MSEC);
+}
+
+static inline void testif_testclk_assert(struct rockchip_dsi *dsi)
+{
+	regmap_update_bits(dsi->regmap, DSI_PHY_TST_CTRL0,
+			   PHY_TESTCLK, PHY_TESTCLK);
+	udelay(1);
+}
+
+static inline void testif_testclk_deassert(struct rockchip_dsi *dsi)
+{
+	regmap_update_bits(dsi->regmap, DSI_PHY_TST_CTRL0, PHY_TESTCLK, 0);
+	udelay(1);
+}
+
+static inline void testif_testclr_assert(struct rockchip_dsi *dsi)
+{
+	regmap_update_bits(dsi->regmap, DSI_PHY_TST_CTRL0,
+			   PHY_TESTCLR, PHY_TESTCLR);
+	udelay(1);
+}
+
+static inline void testif_testclr_deassert(struct rockchip_dsi *dsi)
+{
+	regmap_update_bits(dsi->regmap, DSI_PHY_TST_CTRL0, PHY_TESTCLR, 0);
+	udelay(1);
+}
+
+static inline void testif_testen_assert(struct rockchip_dsi *dsi)
+{
+	regmap_update_bits(dsi->regmap, DSI_PHY_TST_CTRL1,
+			   PHY_TESTEN, PHY_TESTEN);
+	udelay(1);
+}
+
+static inline void testif_testen_deassert(struct rockchip_dsi *dsi)
+{
+	regmap_update_bits(dsi->regmap, DSI_PHY_TST_CTRL1, PHY_TESTEN, 0);
+	udelay(1);
+}
+
+static inline void testif_set_data(struct rockchip_dsi *dsi, u8 data)
+{
+	regmap_update_bits(dsi->regmap, DSI_PHY_TST_CTRL1,
+			   PHY_TESTDIN_MASK, PHY_TESTDIN(data));
+	udelay(1);
+}
+
+static inline u8 testif_get_data(struct rockchip_dsi *dsi)
+{
+	u32 data = 0;
+
+	regmap_read(dsi->regmap, DSI_PHY_TST_CTRL1, &data);
+
+	return data >> PHY_TESTDOUT_SHIFT;
+}
+
+static void testif_test_code_write(struct rockchip_dsi *dsi, u8 test_code)
+{
+	testif_testclk_assert(dsi);
+	testif_set_data(dsi, test_code);
+	testif_testen_assert(dsi);
+	testif_testclk_deassert(dsi);
+	testif_testen_deassert(dsi);
+}
+
+static void testif_test_data_write(struct rockchip_dsi *dsi, u8 test_data)
+{
+	testif_testclk_deassert(dsi);
+	testif_set_data(dsi, test_data);
+	testif_testclk_assert(dsi);
+}
+
+static int testif_write(void *context, unsigned int reg, unsigned int value)
+{
+	struct rockchip_dsi *dsi = context;
+
+	testif_test_code_write(dsi, reg);
+	testif_test_data_write(dsi, value);
+
+	dev_dbg(dsi->dev, "test_code=0x%02x, test_data=0x%02x, monitor_data=0x%02x\n",
+		reg, value, testif_get_data(dsi));
+
+	return 0;
+}
+
+static int testif_read(void *context, unsigned int reg, unsigned int *value)
+{
+	struct rockchip_dsi *dsi = context;
+
+	testif_test_code_write(dsi, reg);
+	*value = testif_get_data(dsi);
+	testif_test_data_write(dsi, *value);
+
+	return 0;
+}
+
+static inline void mipi_dphy_forcepll_assert(struct rockchip_dsi *dsi)
+{
+	regmap_update_bits(dsi->regmap, DSI_PHY_RSTZ,
+			   PHY_FORCEPLL, PHY_FORCEPLL);
+	udelay(1);
+}
+
+static inline void mipi_dphy_enableclk_assert(struct rockchip_dsi *dsi)
+{
+	grf_write(dsi, ENABLECLK, 1);
+	regmap_update_bits(dsi->regmap, DSI_PHY_RSTZ,
+			   PHY_ENABLECLK, PHY_ENABLECLK);
+	udelay(1);
+}
+
+static inline void mipi_dphy_enableclk_deassert(struct rockchip_dsi *dsi)
+{
+	regmap_update_bits(dsi->regmap, DSI_PHY_RSTZ, PHY_ENABLECLK, 0);
+	grf_write(dsi, ENABLECLK, 0);
+	udelay(1);
+}
+
+static inline void mipi_dphy_shutdownz_assert(struct rockchip_dsi *dsi)
+{
+	regmap_update_bits(dsi->regmap, DSI_PHY_RSTZ, PHY_SHUTDOWNZ, 0);
+	udelay(1);
+}
+
+static inline void mipi_dphy_shutdownz_deassert(struct rockchip_dsi *dsi)
+{
+	regmap_update_bits(dsi->regmap, DSI_PHY_RSTZ,
+			   PHY_SHUTDOWNZ, PHY_SHUTDOWNZ);
+	udelay(1);
+}
+
+static inline void mipi_dphy_rstz_assert(struct rockchip_dsi *dsi)
+{
+	regmap_update_bits(dsi->regmap, DSI_PHY_RSTZ, PHY_RSTZ, 0);
+	udelay(1);
+}
+
+static inline void mipi_dphy_rstz_deassert(struct rockchip_dsi *dsi)
+{
+	regmap_update_bits(dsi->regmap, DSI_PHY_RSTZ, PHY_RSTZ, PHY_RSTZ);
+	udelay(1);
+}
+
+static void mipi_dphy_hstt_config(struct rockchip_dsi *dsi)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(hstt_table); i++)
+		if (dsi->lane_mbps < hstt_table[i].max_freq)
+			break;
+
+	if (i == ARRAY_SIZE(hstt_table))
+		--i;
+
+	regmap_write(dsi->regmap, DSI_PHY_TMR_CFG,
+		     PHY_HS2LP_TIME(hstt_table[i].data_lane.hs2lp) |
+		     PHY_LP2HS_TIME(hstt_table[i].data_lane.lp2hs) |
+		     MAX_RD_TIME(0x7fff));
+	regmap_write(dsi->regmap, DSI_PHY_TMR_LPCLK_CFG,
+		     PHY_CLKHS2LP_TIME(hstt_table[i].clk_lane.hs2lp) |
+		     PHY_CLKLP2HS_TIME(hstt_table[i].clk_lane.lp2hs));
+}
+
+static inline void mipi_dphy_if_config(struct rockchip_dsi *dsi)
+{
+	/* XXX: don't hardcode? */
+	regmap_write(dsi->regmap, DSI_PHY_IF_CFG,
+		     N_LANES(dsi->lanes - 1) | PHY_STOP_WAIT_TIME(0x20));
+}
+
+static inline void mipi_dphy_enable_n_assert(struct rockchip_dsi *dsi,
+					     unsigned int lanes)
+{
+	u32 map[] = {0x1, 0x3, 0x7, 0xf};
+
+	grf_write(dsi, ENABLE_N, map[lanes - 1]);
+}
+
+static void mipi_dphy_pll_configure(struct rockchip_dsi *dsi)
+{
+	struct mipi_dphy *dphy = &dsi->dphy;
+	u8 n;
+	u16 m;
+
+	regmap_write(dphy->regmap, 0x19,
+		     LOOP_DIV_PROGRAM_EN | INPUT_DIV_PROGRAM_EN);
+
+	/* PLL Input Divider Ratio */
+	n = dphy->prediv - 1;
+	regmap_write(dphy->regmap, 0x17, INPUT_DIV(n));
+
+	/* PLL Loop Divider Ratio */
+	m = dphy->fbdiv - 1;
+	regmap_write(dphy->regmap, 0x18,
+		     LOW_PROGRAM_EN | LOOP_DIV_LOW(m));
+	regmap_write(dphy->regmap, 0x18,
+		     HIGH_PROGRAM_EN | LOOP_DIV_HIGH(m >> 5));
+}
+
+static void mipi_dphy_configure(struct rockchip_dsi *dsi)
+{
+	struct mipi_dphy *dphy = &dsi->dphy;
+	u8 hsfreqrange;
+	int index;
+
+	for (index = 0; index < ARRAY_SIZE(hsfreqrange_table); index++)
+		if (dsi->lane_mbps < hsfreqrange_table[index].max_freq)
+			break;
+
+	if (index == ARRAY_SIZE(hsfreqrange_table))
+		--index;
+
+	hsfreqrange = hsfreqrange_table[index].hsfreqrange;
+
+	/* HS frequency range selection */
+	regmap_write(dphy->regmap, 0x44, HSFREQRANGE(hsfreqrange));
+
+	/* 1.5 Gbps analog circuitry support */
+	if (dsi->lane_mbps > 1000)
+		regmap_write(dphy->regmap, 0x22, 0x88);
+
+	mipi_dphy_pll_configure(dsi);
+
+	/* Placing the test interface in inactive mode */
+	regmap_write(dphy->regmap, 0x00, 0x00);
+}
+
+static void mipi_dphy_power_off(struct rockchip_dsi *dsi)
+{
+	struct mipi_dphy *dphy = &dsi->dphy;
+
+	phy_power_off(dphy->phy);
+}
+
+static int mipi_dphy_power_on(struct rockchip_dsi *dsi)
+{
+	struct mipi_dphy *dphy = &dsi->dphy;
+	u32 status;
+	int ret;
+
+	mipi_dphy_shutdownz_deassert(dsi);
+	mipi_dphy_rstz_deassert(dsi);
+	mipi_dphy_forcepll_assert(dsi);
+	usleep_range(1500, 2000);
+
+	phy_power_on(dphy->phy);
+
+	/* waits for the PLL to acquire lock */
+	ret = readl_poll_timeout_atomic(dsi->regs + DSI_PHY_STATUS,
+					status, status & PHY_LOCK,
+					10, USEC_PER_MSEC);
+	if (ret < 0) {
+		dev_err(dsi->dev, "PLL is not locked\n");
+		return ret;
+	}
+
+	usleep_range(100, 200);
+
+	/* waits for lane go to the stop state */
+	ret = ppi_stopstatelane_asserted(dsi);
+	if (ret) {
+		dev_err(dsi->dev, "lane module is not in stop state\n");
+		return ret;
+	}
+
+	udelay(10);
+
+	return 0;
+}
+
+static void mipi_dphy_init(struct rockchip_dsi *dsi)
+{
+	struct mipi_dphy *dphy = &dsi->dphy;
+
+	mipi_dphy_shutdownz_assert(dsi);
+	mipi_dphy_rstz_assert(dsi);
+	testif_testclr_assert(dsi);
+
+	/* Configures DPHY to work as a Master */
+	grf_write(dsi, MASTERSLAVEZ, 1);
+
+	/* Configures lane as TX */
+	grf_write(dsi, BASEDIR, 0);
+
+	/* Set all REQUEST inputs to zero */
+	grf_write(dsi, TURNREQUEST, 0);
+	grf_write(dsi, TURNDISABLE, 0);
+	grf_write(dsi, FORCETXSTOPMODE, 0);
+	grf_write(dsi, FORCERXMODE, 0);
+	udelay(1);
+
+	testif_testclr_deassert(dsi);
+
+	if (!dphy->phy)
+		mipi_dphy_configure(dsi);
+
+	/* Enable Data Lane Module */
+	mipi_dphy_enable_n_assert(dsi, dsi->lanes);
+
+	/* Enable Clock Lane Module */
+	mipi_dphy_enableclk_assert(dsi);
+}
+
+static unsigned long mipi_dphy_pll_round_rate(unsigned long fin,
+					      unsigned long fout,
+					      u8 *prediv, u16 *fbdiv)
+{
+	unsigned long best_freq = 0;
+	unsigned long fvco_min, fvco_max;
+	u8 min_prediv, max_prediv;
+	u8 _prediv, uninitialized_var(best_prediv);
+	u16 _fbdiv, uninitialized_var(best_fbdiv);
+	u32 min_delta = UINT_MAX;
+
+	fin /= USEC_PER_SEC;
+	fout /= USEC_PER_SEC;
+
+	/*
+	 * PLL constraint:
+	 * 5Mhz < Fref / N < 40MHz, 80MHz < Fvco < 1500Mhz
+	 */
+	min_prediv = DIV_ROUND_UP(fin, 40);
+	max_prediv = fin / 5;
+	fvco_min = 80;
+	fvco_max = 1500;
+
+	for (_prediv = min_prediv; _prediv <= max_prediv; _prediv++) {
+		u32 delta, _fout;
+
+		/* Fvco = Fref * M / N */
+		_fbdiv = fout * _prediv / fin;
+
+		/*
+		 * Due to the use of a "by 2 pre-scaler," the range of the
+		 * feedback multiplication value M is limited to even division
+		 * numbers, and m must be greater than 12, less than 1000.
+		 */
+		if (_fbdiv <= 12 || _fbdiv >= 1000)
+			continue;
+
+		if (_fbdiv % 2)
+			++_fbdiv;
+
+		_fout = _fbdiv * fin / _prediv;
+		if (_fout < fvco_min || _fout > fvco_max)
+			continue;
+
+		delta = abs(fout - _fout);
+		if (delta < min_delta) {
+			best_prediv = _prediv;
+			best_fbdiv = _fbdiv;
+			min_delta = delta;
+			best_freq = _fout;
+		}
+	}
+
+	if (best_freq) {
+		*prediv = best_prediv;
+		*fbdiv = best_fbdiv;
+	}
+
+	return best_freq * USEC_PER_SEC;
+}
+
+static unsigned long mipi_dphy_set_pll(struct rockchip_dsi *dsi,
+				       unsigned long rate)
+{
+	struct mipi_dphy *dphy = &dsi->dphy;
+	unsigned long fin, fout;
+	u8 prediv;
+	u16 fbdiv;
+
+	fin = clk_get_rate(dphy->ref_clk);
+	fout = mipi_dphy_pll_round_rate(fin, rate, &prediv, &fbdiv);
+
+	dev_dbg(dsi->dev, "fin=%lu, prediv=%u, fbdiv=%u\n", fin, prediv, fbdiv);
+
+	dphy->prediv = prediv;
+	dphy->fbdiv = fbdiv;
+	if (dsi->slave) {
+		dsi->slave->dphy.prediv = dphy->prediv;
+		dsi->slave->dphy.fbdiv = dphy->fbdiv;
+	}
+
+	return fout;
+}
+
+static const struct regmap_config mipi_dphy_regmap_config = {
+	.name = "phy",
+	.reg_bits = 8,
+	.val_bits = 8,
+	.max_register = 0x97,
+	.fast_io = true,
+	.reg_write = testif_write,
+	.reg_read = testif_read,
+};
+
+static int mipi_dphy_attach(struct rockchip_dsi *dsi)
+{
+	struct device *dev = dsi->dev;
+	struct mipi_dphy *dphy = &dsi->dphy;
+	int ret;
+
+	dphy->phy = devm_phy_optional_get(dev, "mipi_dphy");
+	if (IS_ERR(dphy->phy)) {
+		ret = PTR_ERR(dphy->phy);
+		dev_err(dev, "failed to get mipi dphy: %d\n", ret);
+		return ret;
+	}
+
+	if (dphy->phy) {
+		dev_dbg(dev, "Use Non-SNPS PHY\n");
+
+		dphy->hs_clk = devm_clk_get(dev, "hs_clk");
+		if (IS_ERR(dphy->hs_clk)) {
+			dev_err(dev, "failed to get PHY high-speed clock\n");
+			return PTR_ERR(dphy->hs_clk);
+		}
+	} else {
+		dev_dbg(dev, "Use SNPS PHY\n");
+
+		dphy->ref_clk = devm_clk_get(dev, "ref");
+		if (IS_ERR(dphy->ref_clk)) {
+			dev_err(dev, "failed to get PHY reference clock\n");
+			return PTR_ERR(dphy->ref_clk);
+		}
+
+		/* Check if cfg_clk provided */
+		dphy->cfg_clk = devm_clk_get(dev, "phy_cfg");
+		if (IS_ERR(dphy->cfg_clk)) {
+			if (PTR_ERR(dphy->cfg_clk) != -ENOENT) {
+				dev_err(dev, "failed to get phy cfg clock\n");
+				return PTR_ERR(dphy->cfg_clk);
+			}
+
+			/* Otherwise mark the cfg_clk pointer to NULL */
+			dphy->cfg_clk = NULL;
+		}
+
+		dphy->regmap = devm_regmap_init(dev, NULL, dsi,
+						&mipi_dphy_regmap_config);
+		if (IS_ERR(dphy->regmap)) {
+			dev_err(dev, "failed to create mipi dphy regmap\n");
+			return PTR_ERR(dphy->regmap);
+		}
+	}
+
+	return 0;
+}
+
+static inline void dsi_host_power_up(struct rockchip_dsi *dsi)
+{
+	regmap_write(dsi->regmap, DSI_PWR_UP, POWER_UP);
+}
+
+static inline void dsi_host_reset(struct rockchip_dsi *dsi)
+{
+	regmap_write(dsi->regmap, DSI_PWR_UP, RESET);
+}
+
+static inline void dsi_host_set_vid_mode(struct rockchip_dsi *dsi)
+{
+	regmap_write(dsi->regmap, DSI_MODE_CFG, VIDEO_MODE);
+}
+
+static inline void dsi_host_set_cmd_mode(struct rockchip_dsi *dsi)
+{
+	regmap_write(dsi->regmap, DSI_MODE_CFG, COMMAND_MODE);
+}
+
+static inline void dsi_host_err_to_timer_init(struct rockchip_dsi *dsi)
+{
+	/* XXX: don't hardcode? */
+	regmap_update_bits(dsi->regmap, DSI_CLKMGR_CFG,
+			   TO_CLK_DIVIDSION_MASK, TO_CLK_DIVIDSION(10));
+	regmap_write(dsi->regmap, DSI_TO_CNT_CFG, HSTX_TO_CNT(0xffff) |
+		     LPRX_TO_CNT(0xffff));
+}
+
+static inline void dsi_host_escclk_init(struct rockchip_dsi *dsi)
+{
+	u32 lanebyteclk = dsi->lane_mbps >> 3;
+	u32 esc_clk_div;
+
+	esc_clk_div = DIV_ROUND_UP(lanebyteclk, 20);
+
+	regmap_update_bits(dsi->regmap, DSI_CLKMGR_CFG,
+			   TX_ESC_CLK_DIVIDSION_MASK,
+			   TX_ESC_CLK_DIVIDSION(esc_clk_div));
+}
+
+static inline void dsi_host_interrupt_init(struct rockchip_dsi *dsi)
+{
+	regmap_write(dsi->regmap, DSI_INT_MSK0, 0x1fffff);
+	regmap_write(dsi->regmap, DSI_INT_MSK1, 0x1f7f);
+}
+
+static inline void dsi_host_presp_to_counter_init(struct rockchip_dsi *dsi)
+{
+	/*
+	 * The values in these registers are measured in number of cycles of
+	 * the lanebyteclk clock. Setting a given timeout to 0 disables going
+	 * into LP-11 state and timeout for events of that category.
+	 */
+	regmap_write(dsi->regmap, DSI_BTA_TO_CNT, 0);
+	regmap_write(dsi->regmap, DSI_LP_WR_TO_CNT, 0);
+	regmap_write(dsi->regmap, DSI_HS_WR_TO_CNT, 0);
+	regmap_write(dsi->regmap, DSI_LP_RD_TO_CNT, 0);
+	regmap_write(dsi->regmap, DSI_HS_RD_TO_CNT, 0);
+}
+
+static inline void dsi_host_pkthdl_init(struct rockchip_dsi *dsi)
+{
+	/* A peripheral shall implement ECC, and may optionally implement checksum. */
+	regmap_write(dsi->regmap, DSI_PCKHDL_CFG, ECC_RX_EN | BTA_EN);
+}
+
+static int dsi_host_read_from_fifo(struct rockchip_dsi *dsi,
+				   const struct mipi_dsi_msg *msg)
+{
+	u8 *payload = msg->rx_buf;
+	u16 length;
+	u32 val;
+	int ret;
+
+	ret = genif_wait_rd_cmd_not_busy(dsi);
+	if (ret) {
+		dev_err(dsi->dev, "entire response is not stored in the FIFO\n");
+		return ret;
+	}
+
+	/* Receive payload */
+	for (length = msg->rx_len; length; length -= 4) {
+		ret = genif_wait_r_pld_fifo_not_empty(dsi);
+		if (ret) {
+			dev_err(dsi->dev, "Read payload FIFO is empty\n");
+			return ret;
+		}
+
+		regmap_read(dsi->regmap, DSI_GEN_PLD_DATA, &val);
+
+		switch (length) {
+		case 3:
+			payload[2] = (val >> 16) & 0xff;
+			/* Fall through */
+		case 2:
+			payload[1] = (val >> 8) & 0xff;
+			/* Fall through */
+		case 1:
+			payload[0] = val & 0xff;
+			return 0;
+		}
+
+		payload[0] = (val >>  0) & 0xff;
+		payload[1] = (val >>  8) & 0xff;
+		payload[2] = (val >> 16) & 0xff;
+		payload[3] = (val >> 24) & 0xff;
+		payload += 4;
+	}
+
+	return 0;
+}
+
+static void dsi_host_vid_mode_timing_config(struct rockchip_dsi *dsi)
+{
+	struct videomode *vm = &dsi->vm;
+	unsigned int lanebyteclk = dsi->lane_mbps >> 3;
+	unsigned int dpipclk = vm->pixelclock / USEC_PER_SEC;
+	u32 hsa_time, hbp_time, hline_time;
+	u32 hsa, hbp, hact, hfp, hline;
+	u32 vact, vfp, vbp, vsa;
+
+	vsa = vm->vsync_len;
+	vbp = vm->vback_porch;
+	vact = vm->vactive;
+	vfp = vm->vfront_porch;
+
+	regmap_write(dsi->regmap, DSI_VID_VACTIVE_LINES, V_ACTIVE_LINES(vact));
+	regmap_write(dsi->regmap, DSI_VID_VSA_LINES, VSA_LINES(vsa));
+	regmap_write(dsi->regmap, DSI_VID_VFP_LINES, VFP_LINES(vfp));
+	regmap_write(dsi->regmap, DSI_VID_VBP_LINES, VBP_LINES(vbp));
+
+	hsa = vm->hsync_len;
+	hbp = vm->hback_porch;
+	hact = vm->hactive;
+	hfp = vm->hfront_porch;
+	hline = hsa + hbp + hact + hfp;
+
+	hline_time = DIV_ROUND_CLOSEST_ULL(hline * lanebyteclk, dpipclk);
+	regmap_write(dsi->regmap, DSI_VID_HLINE_TIME, VID_HLINE_TIME(hline_time));
+	hsa_time = DIV_ROUND_CLOSEST_ULL(hsa * lanebyteclk, dpipclk);
+	regmap_write(dsi->regmap, DSI_VID_HSA_TIME, VID_HSA_TIME(hsa_time));
+	hbp_time = DIV_ROUND_CLOSEST_ULL(hbp * lanebyteclk, dpipclk);
+	regmap_write(dsi->regmap, DSI_VID_HBP_TIME, VID_HBP_TIME(hbp_time));
+
+	if (dsi->slave || dsi->master)
+		regmap_write(dsi->regmap, DSI_VID_PKT_SIZE,
+			     VID_PKT_SIZE(hact / 2));
+	else
+		regmap_write(dsi->regmap, DSI_VID_PKT_SIZE,
+			     VID_PKT_SIZE(hact));
+}
+
+static void dsi_host_vid_mode_config(struct rockchip_dsi *dsi)
+{
+	struct device *dev = dsi->dev;
+	u32 val, prop;
+
+	dsi_host_vid_mode_timing_config(dsi);
+
+	val = LP_VACT_EN | LP_VFP_EN | LP_VBP_EN | LP_VSA_EN;
+
+	if (!(dsi->mode_flags & MIPI_DSI_MODE_VIDEO_HFP))
+		val |= LP_HFP_EN;
+	if (!(dsi->mode_flags & MIPI_DSI_MODE_VIDEO_HBP))
+		val |= LP_HBP_EN;
+
+	if (dsi->mode_flags & MIPI_DSI_MODE_VIDEO_BURST)
+		val |= VID_MODE_TYPE(BURST_MODE);
+	else if (dsi->mode_flags & MIPI_DSI_MODE_VIDEO_SYNC_PULSE)
+		val |= VID_MODE_TYPE(NON_BURST_MODE_SYNC_PULSE);
+	else
+		val |= VID_MODE_TYPE(NON_BURST_MODE_SYNC_EVENT);
+
+	if (!of_property_read_u32(dev->of_node, "snps,vpg-orientation", &prop))
+		val |= VPG_ORIENTATION(prop) | VPG_EN;
+
+	if (!of_property_read_u32(dev->of_node, "snps,vpg-mode", &prop))
+		val |= VPG_MODE(prop) | VPG_EN;
+
+	regmap_write(dsi->regmap, DSI_VID_MODE_CFG, val);
+
+	if (dsi->mode_flags & MIPI_DSI_CLOCK_NON_CONTINUOUS)
+		regmap_update_bits(dsi->regmap, DSI_LPCLK_CTRL,
+				   AUTO_CLKLANE_CTRL, AUTO_CLKLANE_CTRL);
+
+	if (!(dsi->mode_flags & MIPI_DSI_MODE_EOT_PACKET))
+		regmap_update_bits(dsi->regmap, DSI_PCKHDL_CFG,
+				   EOTP_TX_EN, EOTP_TX_EN);
+}
+
+static void dsi_host_init(struct rockchip_dsi *dsi)
+{
+	dsi_host_presp_to_counter_init(dsi);
+	dsi_host_err_to_timer_init(dsi);
+	dsi_host_escclk_init(dsi);
+	dsi_host_set_cmd_mode(dsi);
+	dsi_host_pkthdl_init(dsi);
+	genif_vcid_init(dsi, dsi->channel);
+	dsi_host_interrupt_init(dsi);
+}
+
+static void dpi_color_coding_config(struct rockchip_dsi *dsi,
+				    enum mipi_dsi_pixel_format format)
+{
+	u8 color_coding;
+	bool loosely18_en = false;
+
+	switch (format) {
+	case MIPI_DSI_FMT_RGB666:
+		color_coding = PIXEL_COLOR_CODING_18BIT_2;
+		break;
+	case MIPI_DSI_FMT_RGB666_PACKED:
+		color_coding = PIXEL_COLOR_CODING_18BIT_1;
+		loosely18_en = true;
+		break;
+	case MIPI_DSI_FMT_RGB565:
+		color_coding = PIXEL_COLOR_CODING_16BIT_1;
+		break;
+	case MIPI_DSI_FMT_RGB888:
+	default:
+		color_coding = PIXEL_COLOR_CODING_24BIT;
+		break;
+	}
+
+	regmap_write(dsi->regmap, DSI_DPI_COLOR_CODING,
+		     LOOSELY18_EN(loosely18_en) |
+		     DPI_COLOR_CODING(color_coding));
+}
+
+static inline void dpi_vcid_config(struct rockchip_dsi *dsi, u8 vcid)
+{
+	regmap_write(dsi->regmap, DSI_DPI_VCID, DPI_VCID(vcid));
+}
+
+static void dpi_pol_config(struct rockchip_dsi *dsi)
+{
+	u32 val = 0;
+
+	if (dsi->vm.flags & DISPLAY_FLAGS_VSYNC_LOW)
+		val |= VSYNC_ACTIVE_LOW;
+	if (dsi->vm.flags & DISPLAY_FLAGS_HSYNC_LOW)
+		val |= HSYNC_ACTIVE_LOW;
+	if (dsi->vm.flags & DISPLAY_FLAGS_DE_LOW)
+		val |= DATAEN_ACTIVE_LOW;
+
+	regmap_write(dsi->regmap, DSI_DPI_CFG_POL, val);
+}
+
+static void dpi_config(struct rockchip_dsi *dsi)
+{
+	dpi_color_coding_config(dsi, dsi->format);
+	dpi_pol_config(dsi);
+	dpi_vcid_config(dsi, dsi->channel);
+}
+
+static unsigned long rockchip_dsi_calc_link_bandwidth(struct rockchip_dsi *dsi)
+{
+	unsigned long min_freq = dsi->soc_data->min_bit_rate_per_lane;
+	unsigned long max_freq = dsi->soc_data->max_bit_rate_per_lane;
+	unsigned long fpclk, req_freq, tmp;
+	unsigned int lanes;
+	int bpp;
+
+	bpp = mipi_dsi_pixel_format_to_bpp(dsi->format);
+	if (bpp < 0)
+		bpp = 24;
+	lanes = dsi->slave ? dsi->lanes * 2 : dsi->lanes;
+	fpclk = dsi->vm.pixelclock / USEC_PER_SEC;
+
+	/*
+	 * For video Burst mode, The DSI output bandwidth should be higher than
+	 * the DPI system interface input bandwidth in a relation that enables
+	 * the link to go to low-power once per line.
+	 */
+	tmp = fpclk * bpp * 12 / 10 / lanes;
+	if (tmp < min_freq || tmp > max_freq)
+		req_freq = max_freq;
+	else
+		req_freq = tmp;
+
+	return req_freq * USEC_PER_SEC;
+}
+
+static int rockchip_dsi_compute_transmission_timing(struct rockchip_dsi *dsi)
+{
+	struct device *dev = dsi->dev;
+	struct mipi_dphy *dphy = &dsi->dphy;
+	unsigned long rate;
+	u32 bw;
+
+	/* XXX: optional override of the desired bandwidth */
+	if (of_property_read_u32(dev->of_node, "snps,bit-rate-per-lane", &bw))
+		bw = rockchip_dsi_calc_link_bandwidth(dsi);
+
+	if (dphy->phy) {
+		rate = clk_round_rate(dphy->hs_clk, bw);
+		clk_set_rate(dphy->hs_clk, rate);
+	} else {
+		rate = mipi_dphy_set_pll(dsi, bw);
+	}
+
+	dsi->lane_mbps = rate / USEC_PER_SEC;
+	if (dsi->slave)
+		dsi->slave->lane_mbps = dsi->lane_mbps;
+
+	dev_info(dsi->dev, "final DSI-Link bandwidth: %u x %d Mbps\n",
+		 dsi->lane_mbps, dsi->slave ? dsi->lanes * 2 : dsi->lanes);
+
+	return 0;
+}
+
+static void rockchip_dsi_external_bridge_power_on(struct rockchip_dsi *dsi)
+{
+	if (dsi->enable_gpio) {
+		gpiod_direction_output(dsi->enable_gpio, 1);
+		usleep_range(1000, 2000);
+	}
+
+	if (dsi->reset_gpio) {
+		gpiod_direction_output(dsi->reset_gpio, 0);
+		usleep_range(1000, 2000);
+		gpiod_direction_output(dsi->reset_gpio, 1);
+		usleep_range(1000, 2000);
+		gpiod_direction_output(dsi->reset_gpio, 0);
+		usleep_range(1000, 2000);
+	}
+}
+
+static void rockchip_dsi_external_bridge_power_off(struct rockchip_dsi *dsi)
+{
+	if (dsi->reset_gpio)
+		gpiod_direction_output(dsi->reset_gpio, 1);
+
+	if (dsi->enable_gpio)
+		gpiod_direction_output(dsi->enable_gpio, 0);
+}
+
+static void rockchip_dsi_pre_enable(struct rockchip_dsi *dsi)
+{
+	rockchip_dsi_external_bridge_power_on(dsi);
+	pm_runtime_get_sync(dsi->dev);
+	dsi_host_reset(dsi);
+	dsi_host_init(dsi);
+	mipi_dphy_init(dsi);
+	mipi_dphy_hstt_config(dsi);
+	mipi_dphy_if_config(dsi);
+	ppi_txrequestclkhs_assert(dsi);
+	mipi_dphy_power_on(dsi);
+	dsi_host_power_up(dsi);
+
+	if (dsi->slave)
+		rockchip_dsi_pre_enable(dsi->slave);
+}
+
+static ssize_t rockchip_dsi_host_transfer(struct mipi_dsi_host *host,
+					  const struct mipi_dsi_msg *msg)
+{
+	struct rockchip_dsi *dsi = host_to_dsi(host);
+	struct mipi_dsi_packet packet;
+	u32 val;
+	int ret;
+
+	if (msg->flags & MIPI_DSI_MSG_USE_LPM) {
+		val = CMD_XFER_TYPE_LP;
+	} else {
+		val = CMD_XFER_TYPE_HS;
+		ppi_txrequestclkhs_assert(dsi);
+	}
+
+	/* enables the acknowledge request after each packet transmission */
+	if (msg->flags & MIPI_DSI_MSG_REQ_ACK ||
+	    of_property_read_bool(dsi->dev->of_node, "snps,ack-request"))
+		val |= ACK_RQST_EN;
+
+	regmap_write(dsi->regmap, DSI_CMD_MODE_CFG, val);
+
+	/* create a packet to the DSI protocol */
+	ret = mipi_dsi_create_packet(&packet, msg);
+	if (ret) {
+		dev_err(dsi->dev, "failed to create packet: %d\n", ret);
+		return ret;
+	}
+
+	/* Send payload */
+	while (packet.payload_length >= 4) {
+		/*
+		 * Alternatively, you can always keep the FIFO nearly full by
+		 * monitoring the FIFO state until it is not full, and then
+		 * write a single word of data. This solution is more resource
+		 * consuming but it simultaneously avoids FIFO starvation,
+		 * making it possible to use FIFO sizes smaller than the amount
+		 * of data of the longest packet to be written.
+		 */
+		ret = genif_wait_w_pld_fifo_not_full(dsi);
+		if (ret) {
+			dev_err(dsi->dev, "Write payload FIFO is full\n");
+			return ret;
+		}
+
+		val = get_unaligned_le32(packet.payload);
+		regmap_write(dsi->regmap, DSI_GEN_PLD_DATA, val);
+		packet.payload += 4;
+		packet.payload_length -= 4;
+	}
+
+	val = 0;
+	switch (packet.payload_length) {
+	case 3:
+		val |= packet.payload[2] << 16;
+		/* Fall through */
+	case 2:
+		val |= packet.payload[1] << 8;
+		/* Fall through */
+	case 1:
+		val |= packet.payload[0];
+		regmap_write(dsi->regmap, DSI_GEN_PLD_DATA, val);
+		break;
+	}
+
+	ret = genif_wait_cmd_fifo_not_full(dsi);
+	if (ret) {
+		dev_err(dsi->dev, "Command FIFO is full\n");
+		return ret;
+	}
+
+	/* Send packet header */
+	val = get_unaligned_le32(packet.header);
+	regmap_write(dsi->regmap, DSI_GEN_HDR, val);
+
+	ret = genif_wait_w_fifo_is_empty(dsi);
+	if (ret) {
+		dev_err(dsi->dev, "Write payload FIFO is not empty\n");
+		return ret;
+	}
+
+	if (msg->rx_len) {
+		/*
+		 * Since this is a read command, BTA shall be asserted by the
+		 * host processor following completion of the transmission
+		 */
+		ppi_turnrequest_assert(dsi);
+		ret = dsi_host_read_from_fifo(dsi, msg);
+		if (ret)
+			return ret;
+		ppi_turnrequest_deassert(dsi);
+	}
+
+	return 0;
+}
+
+static int rockchip_dsi_host_attach(struct mipi_dsi_host *host,
+				    struct mipi_dsi_device *device)
+{
+	struct rockchip_dsi *dsi = host_to_dsi(host);
+
+	if (device->lanes < 1 || device->lanes > 8)
+		return -EINVAL;
+
+	dsi->client = device->dev.of_node;
+	dsi->lanes = device->lanes;
+	dsi->channel = device->channel;
+	dsi->format = device->format;
+	dsi->mode_flags = device->mode_flags;
+
+	if (dsi->connector.dev)
+		drm_helper_hpd_irq_event(dsi->connector.dev);
+
+	return 0;
+}
+
+static int rockchip_dsi_host_detach(struct mipi_dsi_host *host,
+				    struct mipi_dsi_device *device)
+{
+	struct rockchip_dsi *dsi = host_to_dsi(host);
+
+	dsi->panel = NULL;
+
+	if (dsi->connector.dev)
+		drm_helper_hpd_irq_event(dsi->connector.dev);
+
+	return 0;
+}
+
+static const struct mipi_dsi_host_ops rockchip_dsi_host_ops = {
+	.attach	  = rockchip_dsi_host_attach,
+	.detach	  = rockchip_dsi_host_detach,
+	.transfer = rockchip_dsi_host_transfer,
+};
+
+static void rockchip_dsi_encoder_mode_set(struct drm_encoder *encoder,
+					  struct drm_display_mode *mode,
+					  struct drm_display_mode *adj)
+{
+	struct rockchip_dsi *dsi = encoder_to_dsi(encoder);
+
+	drm_display_mode_to_videomode(adj, &dsi->vm);
+	if (dsi->slave)
+		drm_display_mode_to_videomode(adj, &dsi->slave->vm);
+}
+
+static void rockchip_dsi_vop_routing(struct rockchip_dsi *dsi)
+{
+	struct device_node *np = dsi->dev->of_node;
+	int pipe;
+
+	pipe = drm_of_encoder_active_endpoint_id(np, &dsi->encoder);
+	grf_write(dsi, VOPSEL, pipe);
+
+	if (dsi->slave)
+		grf_write(dsi->slave, VOPSEL, pipe);
+}
+
+static void rockchip_dsi_enable(struct rockchip_dsi *dsi)
+{
+	dsi_host_reset(dsi);
+	dpi_config(dsi);
+	dsi_host_vid_mode_config(dsi);
+	ppi_txrequestclkhs_assert(dsi);
+	dsi_host_set_vid_mode(dsi);
+	dsi_host_power_up(dsi);
+
+	if (dsi->slave)
+		rockchip_dsi_enable(dsi->slave);
+}
+
+static void rockchip_dsi_encoder_enable(struct drm_encoder *encoder)
+{
+	struct rockchip_dsi *dsi = encoder_to_dsi(encoder);
+
+	rockchip_dsi_compute_transmission_timing(dsi);
+	rockchip_dsi_vop_routing(dsi);
+
+	rockchip_dsi_pre_enable(dsi);
+
+	if (dsi->panel)
+		drm_panel_prepare(dsi->panel);
+
+	rockchip_dsi_enable(dsi);
+
+	if (dsi->panel)
+		drm_panel_enable(dsi->panel);
+}
+
+static void rockchip_dsi_disable(struct rockchip_dsi *dsi)
+{
+	dsi_host_set_cmd_mode(dsi);
+	ppi_txrequestclkhs_deassert(dsi);
+	ppi_forcetxstopmode_assert(dsi);
+
+	if (dsi->slave)
+		rockchip_dsi_disable(dsi->slave);
+}
+
+static void rockchip_dsi_post_disable(struct rockchip_dsi *dsi)
+{
+	rockchip_dsi_external_bridge_power_off(dsi);
+	dsi_host_reset(dsi);
+	mipi_dphy_power_off(dsi);
+	pm_runtime_put(dsi->dev);
+
+	if (dsi->slave)
+		rockchip_dsi_post_disable(dsi->slave);
+}
+
+static void rockchip_dsi_encoder_disable(struct drm_encoder *encoder)
+{
+	struct rockchip_dsi *dsi = encoder_to_dsi(encoder);
+
+	if (dsi->panel)
+		drm_panel_disable(dsi->panel);
+
+	rockchip_dsi_disable(dsi);
+
+	if (dsi->panel)
+		drm_panel_unprepare(dsi->panel);
+
+	rockchip_dsi_post_disable(dsi);
+}
+
+static int
+rockchip_dsi_encoder_atomic_check(struct drm_encoder *encoder,
+				  struct drm_crtc_state *crtc_state,
+				  struct drm_connector_state *conn_state)
+{
+	struct rockchip_crtc_state *s = to_rockchip_crtc_state(crtc_state);
+	struct rockchip_dsi *dsi = encoder_to_dsi(encoder);
+	struct drm_connector *connector = conn_state->connector;
+	struct drm_display_info *info = &connector->display_info;
+
+	switch (dsi->format) {
+	case MIPI_DSI_FMT_RGB888:
+		s->output_mode = ROCKCHIP_OUT_MODE_P888;
+		break;
+	case MIPI_DSI_FMT_RGB666:
+		s->output_mode = ROCKCHIP_OUT_MODE_P666;
+		break;
+	case MIPI_DSI_FMT_RGB565:
+		s->output_mode = ROCKCHIP_OUT_MODE_P565;
+		break;
+	default:
+		WARN_ON(1);
+		return -EINVAL;
+	}
+
+	s->output_type = DRM_MODE_CONNECTOR_DSI;
+
+	if (dsi->slave)
+		s->output_flags |= ROCKCHIP_OUTPUT_DSI_DUAL_CHANNEL;
+
+	if (IS_DSI1(dsi))
+		s->output_flags |= ROCKCHIP_OUTPUT_DSI_DUAL_LINK;
+
+	if (info->num_bus_formats)
+		s->bus_format = info->bus_formats[0];
+
+	return 0;
+}
+
+static const struct drm_encoder_helper_funcs
+rockchip_dsi_encoder_helper_funcs = {
+	.mode_set = rockchip_dsi_encoder_mode_set,
+	.atomic_check = rockchip_dsi_encoder_atomic_check,
+	.enable = rockchip_dsi_encoder_enable,
+	.disable = rockchip_dsi_encoder_disable,
+};
+
+static const struct drm_encoder_funcs rockchip_dsi_encoder_funcs = {
+	.destroy = drm_encoder_cleanup,
+};
+
+static int rockchip_dsi_connector_get_modes(struct drm_connector *connector)
+{
+	struct rockchip_dsi *dsi = connector_to_dsi(connector);
+
+	return drm_panel_get_modes(dsi->panel);
+}
+
+static struct drm_encoder *
+rockchip_dsi_connector_best_encoder(struct drm_connector *connector)
+{
+	struct rockchip_dsi *dsi = connector_to_dsi(connector);
+
+	return &dsi->encoder;
+}
+
+static int
+rockchip_dsi_connector_loader_protect(struct drm_connector *connector, bool on)
+{
+	struct rockchip_dsi *dsi = connector_to_dsi(connector);
+
+	if (dsi->panel)
+		drm_panel_loader_protect(dsi->panel, on);
+
+	if (on)
+		pm_runtime_get_sync(dsi->dev);
+	else
+		pm_runtime_put(dsi->dev);
+
+	return 0;
+}
+
+static const struct drm_connector_helper_funcs
+rockchip_dsi_connector_helper_funcs = {
+	.get_modes = rockchip_dsi_connector_get_modes,
+	.best_encoder = rockchip_dsi_connector_best_encoder,
+	.loader_protect = rockchip_dsi_connector_loader_protect,
+};
+
+static void rockchip_dsi_connector_destroy(struct drm_connector *connector)
+{
+	struct rockchip_dsi *dsi = connector_to_dsi(connector);
+
+	if (dsi->panel)
+		drm_panel_detach(dsi->panel);
+
+	drm_connector_unregister(connector);
+	drm_connector_cleanup(connector);
+}
+
+static enum drm_connector_status
+rockchip_dsi_connector_detect(struct drm_connector *connector, bool force)
+{
+	struct rockchip_dsi *dsi = connector_to_dsi(connector);
+
+	if (dsi->panel)
+		return connector_status_connected;
+
+	return connector_status_disconnected;
+}
+
+static const struct drm_connector_funcs rockchip_dsi_connector_funcs = {
+	.dpms = drm_atomic_helper_connector_dpms,
+	.fill_modes = drm_helper_probe_single_connector_modes,
+	.detect = rockchip_dsi_connector_detect,
+	.destroy = rockchip_dsi_connector_destroy,
+	.reset = drm_atomic_helper_connector_reset,
+	.atomic_duplicate_state = drm_atomic_helper_connector_duplicate_state,
+	.atomic_destroy_state = drm_atomic_helper_connector_destroy_state,
+};
+
+static int rockchip_dsi_connector_init(struct drm_device *drm,
+				       struct rockchip_dsi *dsi)
+{
+	struct drm_encoder *encoder = &dsi->encoder;
+	struct drm_connector *connector = &dsi->connector;
+	int ret;
+
+	ret = drm_connector_init(drm, connector, &rockchip_dsi_connector_funcs,
+				 DRM_MODE_CONNECTOR_DSI);
+	if (ret) {
+		DRM_ERROR("Failed to initialize connector with drm\n");
+		return ret;
+	}
+
+	drm_connector_helper_add(connector,
+				 &rockchip_dsi_connector_helper_funcs);
+	connector->port = dsi->dev->of_node;
+	drm_mode_connector_attach_encoder(connector, encoder);
+
+	ret = drm_panel_attach(dsi->panel, connector);
+	if (ret) {
+		DRM_ERROR("Failed to attach panel to drm\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+static int rockchip_dsi_dual_channel_probe(struct rockchip_dsi *dsi)
+{
+	struct device_node *np;
+
+	np = of_parse_phandle(dsi->dev->of_node, "rockchip,dual-channel", 0);
+	if (np) {
+		struct platform_device *secondary = of_find_device_by_node(np);
+
+		dsi->slave = platform_get_drvdata(secondary);
+		of_node_put(np);
+
+		if (!dsi->slave)
+			return -EPROBE_DEFER;
+
+		dsi->slave->master = dsi;
+
+		dsi->lanes /= 2;
+		dsi->slave->lanes = dsi->lanes;
+		dsi->slave->channel = dsi->channel;
+		dsi->slave->format = dsi->format;
+		dsi->slave->mode_flags = dsi->mode_flags;
+	}
+
+	return 0;
+}
+
+static int rockchip_dsi_bind(struct device *dev, struct device *master,
+			     void *data)
+{
+	struct device_node *np = dev->of_node;
+	struct drm_device *drm = data;
+	struct rockchip_dsi *dsi = dev_get_drvdata(dev);
+	struct drm_encoder *encoder = &dsi->encoder;
+	int ret;
+
+	ret = rockchip_dsi_dual_channel_probe(dsi);
+	if (ret)
+		return ret;
+
+	if (dsi->master)
+		return 0;
+
+	dsi->panel = of_drm_find_panel(dsi->client);
+	if (!dsi->panel)
+		dsi->bridge = of_drm_find_bridge(dsi->client);
+
+	if (!dsi->panel && !dsi->bridge) {
+		DRM_INFO("Waiting for panel/bridge driver\n");
+		return -EPROBE_DEFER;
+	}
+
+	encoder->possible_crtcs = drm_of_find_possible_crtcs(drm, np);
+
+	drm_encoder_init(drm, encoder, &rockchip_dsi_encoder_funcs,
+			 DRM_MODE_ENCODER_DSI, NULL);
+	drm_encoder_helper_add(encoder, &rockchip_dsi_encoder_helper_funcs);
+
+	if (dsi->bridge) {
+		/*
+		 * If there's a bridge, attach to it and
+		 * let it create the connector
+		 */
+		dsi->bridge->driver_private = &dsi->host;
+		dsi->bridge->encoder = encoder;
+		ret = drm_bridge_attach(drm, dsi->bridge);
+		if (ret) {
+			DRM_ERROR("Failed to attach bridge to drm\n");
+			return ret;
+		}
+		encoder->bridge = dsi->bridge;
+	} else {
+		/* Otherwise create our own connector and attach to a panel */
+		ret = rockchip_dsi_connector_init(drm, dsi);
+		if (ret)
+			return ret;
+	}
+
+	pm_runtime_enable(dev);
+	if (dsi->slave)
+		pm_runtime_enable(dsi->slave->dev);
+
+	enable_irq(dsi->irq);
+
+	return 0;
+}
+
+static void rockchip_dsi_unbind(struct device *dev, struct device *master,
+				void *data)
+{
+	struct rockchip_dsi *dsi = dev_get_drvdata(dev);
+
+	pm_runtime_disable(dev);
+	if (dsi->slave)
+		pm_runtime_disable(dsi->slave->dev);
+
+	drm_encoder_cleanup(&dsi->encoder);
+
+	/* Skip connector cleanup if creation was delegated to the bridge */
+	if (dsi->connector.dev)
+		drm_connector_cleanup(&dsi->connector);
+}
+
+static const struct component_ops rockchip_dsi_component_ops = {
+	.bind	= rockchip_dsi_bind,
+	.unbind	= rockchip_dsi_unbind,
+};
+
+static const char * const dphy_error[] = {
+	"ErrEsc escape entry error from Lane 0",
+	"ErrSyncEsc low-power data transmission synchronization error from Lane 0",
+	"the ErrControl error from Lane 0",
+	"LP0 contention error ErrContentionLP0 from Lane 0",
+	"LP1 contention error ErrContentionLP1 from Lane 0",
+};
+
+static const char * const ack_with_err[] = {
+	"the SoT error from the Acknowledge error report",
+	"the SoT Sync error from the Acknowledge error report",
+	"the EoT Sync error from the Acknowledge error report",
+	"the Escape Mode Entry Command error from the Acknowledge error report",
+	"the LP Transmit Sync error from the Acknowledge error report",
+	"the Peripheral Timeout error from the Acknowledge Error report",
+	"the False Control error from the Acknowledge error report",
+	"the reserved (specific to device) from the Acknowledge error report",
+	"the ECC error, single-bit (detected and corrected) from the Acknowledge error report",
+	"the ECC error, multi-bit (detected, not corrected) from the Acknowledge error report",
+	"the checksum error (long packet only) from the Acknowledge error report",
+	"the not recognized DSI data type from the Acknowledge error report",
+	"the DSI VC ID Invalid from the Acknowledge error report",
+	"the invalid transmission length from the Acknowledge error report",
+	"the reserved (specific to device) from the Acknowledge error report"
+	"the DSI protocol violation from the Acknowledge error report",
+};
+
+static const char * const error_report[] = {
+	"Host reports that the configured timeout counter for the high-speed transmission has expired",
+	"Host reports that the configured timeout counter for the low-power reception has expired",
+	"Host reports that a received packet contains a single bit error",
+	"Host reports that a received packet contains multiple ECC errors",
+	"Host reports that a received long packet has a CRC error in its payload",
+	"Host receives a transmission that does not end in the expected by boundaries",
+	"Host receives a transmission that does not end with an End of Transmission packet",
+	"An overflow occurs in the DPI pixel payload FIFO",
+	"An overflow occurs in the Generic command FIFO",
+	"An overflow occurs in the Generic write payload FIFO",
+	"An underflow occurs in the Generic write payload FIFO",
+	"An underflow occurs in the Generic read FIFO",
+	"An overflow occurs in the Generic read FIFO",
+};
+
+static irqreturn_t rockchip_dsi_irq_thread(int irq, void *dev_id)
+{
+	struct rockchip_dsi *dsi = dev_id;
+	u32 int_st0, int_st1;
+	int i;
+
+	regmap_read(dsi->regmap, DSI_INT_ST0, &int_st0);
+	regmap_read(dsi->regmap, DSI_INT_ST1, &int_st1);
+
+	for (i = 0; i < ARRAY_SIZE(ack_with_err); i++)
+		if (int_st0 & BIT(i))
+			dev_dbg(dsi->dev, "%s\n", ack_with_err[i]);
+
+	for (i = 0; i < ARRAY_SIZE(dphy_error); i++)
+		if (int_st0 & BIT(16 + i))
+			dev_dbg(dsi->dev, "%s\n", dphy_error[i]);
+
+	for (i = 0; i < ARRAY_SIZE(error_report); i++)
+		if (int_st1 & BIT(i))
+			dev_dbg(dsi->dev, "%s\n", error_report[i]);
+
+	return IRQ_HANDLED;
+}
+
+static int rockchip_dsi_parse_dt(struct rockchip_dsi *dsi)
+{
+	struct device *dev = dsi->dev;
+	struct device_node *np = dev->of_node;
+	struct device_node *endpoint, *remote = NULL;
+
+	endpoint = of_graph_get_endpoint_by_regs(np, 1, -1);
+	if (endpoint) {
+		remote = of_graph_get_remote_port_parent(endpoint);
+		of_node_put(endpoint);
+		if (!remote) {
+			dev_err(dev, "no panel/bridge connected\n");
+			return -ENODEV;
+		}
+		of_node_put(remote);
+	}
+
+	dsi->client = remote;
+
+	return 0;
+}
+
+static const struct regmap_config rockchip_dsi_regmap_config = {
+	.name = "host",
+	.reg_bits = 32,
+	.val_bits = 32,
+	.reg_stride = 4,
+	.max_register = DSI_MAX_REGISGER,
+};
+
+static int rockchip_dsi_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct device_node *np = dev->of_node;
+	struct rockchip_dsi *dsi;
+	struct resource *res;
+	int of_id;
+	int ret;
+
+	printk(KERN_INFO "%s -- %d\n",__func__,__LINE__);
+
+	dsi = devm_kzalloc(dev, sizeof(*dsi), GFP_KERNEL);
+	if (!dsi)
+		return -ENOMEM;
+
+	of_id = of_alias_get_id(np, "dsi");
+	if (of_id < 0)
+		of_id = 0;
+
+	dsi->dev = dev;
+	dsi->soc_data = of_device_get_match_data(dev);
+	dsi->id = of_id;
+	dsi->grf_desc = of_id ? dsi->soc_data->dsi1_grf_desc :
+				dsi->soc_data->dsi0_grf_desc;
+	platform_set_drvdata(pdev, dsi);
+
+	ret = rockchip_dsi_parse_dt(dsi);
+	if (ret) {
+		dev_err(dev, "failed to parse DT\n");
+		return ret;
+	}
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	dsi->regs = devm_ioremap_resource(dev, res);
+	if (IS_ERR(dsi->regs))
+		return PTR_ERR(dsi->regs);
+
+	dsi->regmap = devm_regmap_init_mmio_clk(dev, "pclk", dsi->regs,
+						&rockchip_dsi_regmap_config);
+	if (IS_ERR(dsi->regmap)) {
+		dev_err(dev, "failed to init register map\n");
+		return PTR_ERR(dsi->regmap);
+	}
+
+	dsi->grf = syscon_regmap_lookup_by_phandle(np, "rockchip,grf");
+	if (IS_ERR(dsi->grf)) {
+		dev_err(dev, "failed to get grf regmap\n");
+		return PTR_ERR(dsi->grf);
+	}
+
+	dsi->pclk = devm_clk_get(dev, "pclk");
+	if (IS_ERR(dsi->pclk)) {
+		dev_err(dev, "failed to get apb clock\n");
+		return PTR_ERR(dsi->pclk);
+	}
+
+	dsi->rst = devm_reset_control_get(dev, "apb");
+	if (IS_ERR(dsi->rst)) {
+		dev_err(dev, "failed to get apb reset\n");
+		return PTR_ERR(dsi->rst);
+	}
+
+	ret = mipi_dphy_attach(dsi);
+	if (ret)
+		return ret;
+
+	dsi->irq = platform_get_irq(pdev, 0);
+	if (dsi->irq < 0) {
+		dev_err(dev, "failed to get IRQ resource\n");
+		return dsi->irq;
+	}
+
+	irq_set_status_flags(dsi->irq, IRQ_NOAUTOEN);
+	ret = devm_request_threaded_irq(dev, dsi->irq, NULL,
+					rockchip_dsi_irq_thread,
+					IRQF_ONESHOT, dev_name(dev), dsi);
+	if (ret) {
+		dev_err(dev, "failed to request IRQ: %d\n", ret);
+		return ret;
+	}
+
+	dsi->enable_gpio = devm_gpiod_get_optional(dev, "enable", 0);
+	if (IS_ERR(dsi->enable_gpio)) {
+		ret = PTR_ERR(dsi->enable_gpio);
+		dev_err(dev, "failed to request enable GPIO: %d\n", ret);
+		return ret;
+	}
+
+	dsi->reset_gpio = devm_gpiod_get_optional(dev, "reset", 0);
+	if (IS_ERR(dsi->reset_gpio)) {
+		ret = PTR_ERR(dsi->reset_gpio);
+		dev_err(dev, "failed to request reset GPIO: %d\n", ret);
+		return ret;
+	}
+
+	dsi->host.ops = &rockchip_dsi_host_ops;
+	dsi->host.dev = dev;
+	ret = mipi_dsi_host_register(&dsi->host);
+	if (ret) {
+		dev_err(dev, "failed to register DSI host: %d\n", ret);
+		return ret;
+	}
+
+	return component_add(dev, &rockchip_dsi_component_ops);
+}
+
+static int rockchip_dsi_remove(struct platform_device *pdev)
+{
+	struct rockchip_dsi *dsi = platform_get_drvdata(pdev);
+
+	component_del(&pdev->dev, &rockchip_dsi_component_ops);
+	mipi_dsi_host_unregister(&dsi->host);
+
+	return 0;
+}
+
+static int rockchip_dsi_suspend(struct device *dev)
+{
+	struct rockchip_dsi *dsi = dev_get_drvdata(dev);
+	struct mipi_dphy *dphy = &dsi->dphy;
+
+	if (dphy->phy) {
+		clk_disable_unprepare(dphy->hs_clk);
+	} else {
+		clk_disable_unprepare(dphy->ref_clk);
+		clk_disable_unprepare(dphy->cfg_clk);
+	}
+
+	reset_control_assert(dsi->rst);
+	usleep_range(1000, 2000);
+	clk_disable_unprepare(dsi->pclk);
+
+	return 0;
+}
+
+static int rockchip_dsi_resume(struct device *dev)
+{
+	struct rockchip_dsi *dsi = dev_get_drvdata(dev);
+	struct mipi_dphy *dphy = &dsi->dphy;
+
+	clk_prepare_enable(dsi->pclk);
+	usleep_range(1000, 2000);
+	reset_control_deassert(dsi->rst);
+
+	if (dphy->phy) {
+		clk_prepare_enable(dphy->hs_clk);
+	} else {
+		clk_prepare_enable(dphy->ref_clk);
+		clk_prepare_enable(dphy->cfg_clk);
+	}
+
+	return 0;
+}
+
+static const u32 rk3288_dsi0_grf_desc[NUM_GRF_DESC] = {
+	[DPICOLORM]	  = GRF_DESC(0x025c,  8, 8),
+	[DPISHUTDN]	  = GRF_DESC(0x025c,  7, 7),
+	[VOPSEL]	  = GRF_DESC(0x025c,  6, 6),
+	[FORCETXSTOPMODE] = GRF_DESC(0x0264, 11, 8),
+	[FORCERXMODE]	  = GRF_DESC(0x0264,  7, 4),
+	[TURNDISABLE]	  = GRF_DESC(0x0264,  3, 0),
+	[TURNREQUEST]	  = GRF_DESC(0x03a4, 10, 8),
+	[DPIUPDATECFG]	  = GRF_DESC(0x03a8,  0, 0),
+};
+
+static const u32 rk3288_dsi1_grf_desc[NUM_GRF_DESC] = {
+	[DPICOLORM]	  = GRF_DESC(0x025c, 11, 11),
+	[DPISHUTDN]	  = GRF_DESC(0x025c, 10, 10),
+	[VOPSEL]	  = GRF_DESC(0x025c,  9,  9),
+	[ENABLE_N]	  = GRF_DESC(0x0268, 15, 12),
+	[FORCETXSTOPMODE] = GRF_DESC(0x0268, 11,  8),
+	[FORCERXMODE]	  = GRF_DESC(0x0268,  7,  4),
+	[TURNDISABLE]	  = GRF_DESC(0x0268,  3,  0),
+	[BASEDIR]	  = GRF_DESC(0x027c, 15, 15),
+	[MASTERSLAVEZ]	  = GRF_DESC(0x027c, 14, 14),
+	[ENABLECLK]	  = GRF_DESC(0x027c, 12, 12),
+	[TURNREQUEST]	  = GRF_DESC(0x03a4,  7,  4),
+	[DPIUPDATECFG]	  = GRF_DESC(0x03a8,  1,  1),
+};
+
+static const struct rockchip_dsi_soc_data rk3288_dsi_soc_data = {
+	.min_bit_rate_per_lane = 80,
+	.max_bit_rate_per_lane = 1500,
+	.dsi0_grf_desc = rk3288_dsi0_grf_desc,
+	.dsi1_grf_desc = rk3288_dsi1_grf_desc,
+};
+
+static const u32 rk3366_dsi_grf_desc[NUM_GRF_DESC] = {
+	[VOPSEL]	  = GRF_DESC(0x0400,  2, 2),
+	[DPIUPDATECFG]	  = GRF_DESC(0x0410,  9, 9),
+	[DPICOLORM]	  = GRF_DESC(0x0410,  3, 3),
+	[DPISHUTDN]	  = GRF_DESC(0x0410,  2, 2),
+	[FORCETXSTOPMODE] = GRF_DESC(0x0414, 10, 7),
+	[FORCERXMODE]	  = GRF_DESC(0x0414,  6, 6),
+	[TURNDISABLE]	  = GRF_DESC(0x0414,  5, 5),
+};
+
+static const struct rockchip_dsi_soc_data rk3366_dsi_soc_data = {
+	.min_bit_rate_per_lane = 80,
+	.max_bit_rate_per_lane = 1000,
+	.dsi0_grf_desc = rk3366_dsi_grf_desc,
+};
+
+static const u32 rk3368_dsi_grf_desc[NUM_GRF_DESC] = {
+	[DPIUPDATECFG]	  = GRF_DESC(0x0418,  7, 7),
+	[DPICOLORM]	  = GRF_DESC(0x0418,  3, 3),
+	[DPISHUTDN]	  = GRF_DESC(0x0418,  2, 2),
+	[FORCETXSTOPMODE] = GRF_DESC(0x041c, 10, 7),
+	[FORCERXMODE]	  = GRF_DESC(0x041c,  6, 6),
+	[TURNDISABLE]	  = GRF_DESC(0x041c,  5, 5),
+};
+
+static const struct rockchip_dsi_soc_data rk3368_dsi_soc_data = {
+	.min_bit_rate_per_lane = 80,
+	.max_bit_rate_per_lane = 1000,
+	.dsi0_grf_desc = rk3368_dsi_grf_desc,
+};
+
+static const u32 rk3399_dsi0_grf_desc[NUM_GRF_DESC] = {
+	[DPIUPDATECFG]	  = GRF_DESC(0x6224, 15, 15),
+	[DPISHUTDN]	  = GRF_DESC(0x6224, 14, 14),
+	[DPICOLORM]	  = GRF_DESC(0x6224, 13, 13),
+	[VOPSEL]	  = GRF_DESC(0x6250,  0,  0),
+	[TURNREQUEST]	  = GRF_DESC(0x6258, 15, 12),
+	[TURNDISABLE]	  = GRF_DESC(0x6258, 11,  8),
+	[FORCETXSTOPMODE] = GRF_DESC(0x6258,  7,  4),
+	[FORCERXMODE]	  = GRF_DESC(0x6258,  3,  0),
+};
+
+static const u32 rk3399_dsi1_grf_desc[NUM_GRF_DESC] = {
+	[VOPSEL]	  = GRF_DESC(0x6250,  4,  4),
+	[DPIUPDATECFG]	  = GRF_DESC(0x6250,  3,  3),
+	[DPISHUTDN]	  = GRF_DESC(0x6250,  2,  2),
+	[DPICOLORM]	  = GRF_DESC(0x6250,  1,  1),
+	[TURNDISABLE]	  = GRF_DESC(0x625c, 15, 12),
+	[FORCETXSTOPMODE] = GRF_DESC(0x625c, 11,  8),
+	[FORCERXMODE]	  = GRF_DESC(0x625c,  7,  4),
+	[ENABLE_N]	  = GRF_DESC(0x625c,  3,  0),
+	[MASTERSLAVEZ]	  = GRF_DESC(0x6260,  7,  7),
+	[ENABLECLK]	  = GRF_DESC(0x6260,  6,  6),
+	[BASEDIR]	  = GRF_DESC(0x6260,  5,  5),
+	[TURNREQUEST]	  = GRF_DESC(0x6260,  3,  0),
+};
+
+static const struct rockchip_dsi_soc_data rk3399_dsi_soc_data = {
+	.min_bit_rate_per_lane = 80,
+	.max_bit_rate_per_lane = 1500,
+	.dsi0_grf_desc = rk3399_dsi0_grf_desc,
+	.dsi1_grf_desc = rk3399_dsi1_grf_desc,
+};
+
+static const struct of_device_id rockchip_dsi_of_match[] = {
+	{ .compatible = "rockchip,rk3288-dsi", .data = &rk3288_dsi_soc_data },
+	{ .compatible = "rockchip,rk3366-dsi", .data = &rk3366_dsi_soc_data },
+	{ .compatible = "rockchip,rk3368-dsi", .data = &rk3368_dsi_soc_data },
+	{ .compatible = "rockchip,rk3399-dsi", .data = &rk3399_dsi_soc_data },
+	{},
+};
+MODULE_DEVICE_TABLE(of, rockchip_dsi_of_match);
+
+static const struct dev_pm_ops rockchip_dsi_pm_ops = {
+	SET_RUNTIME_PM_OPS(rockchip_dsi_suspend, rockchip_dsi_resume, NULL)
+};
+
+static struct platform_driver rockchip_dsi_driver = {
+	.driver = {
+		.name = "rockchip-dsi",
+		.pm = &rockchip_dsi_pm_ops,
+		.of_match_table = of_match_ptr(rockchip_dsi_of_match),
+	},
+	.probe	= rockchip_dsi_probe,
+	.remove	= rockchip_dsi_remove,
+};
+module_platform_driver(rockchip_dsi_driver);
+
+MODULE_AUTHOR("Wyon Bi <bivvy.bi@rock-chips.com>");
+MODULE_DESCRIPTION("Synopsys DesignWare Cores MIPI-DSI driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/mfd/Kconfig b/drivers/mfd/Kconfig
old mode 100644
new mode 100755
index 8851f64d..98d05bfd
--- a/drivers/mfd/Kconfig
+++ b/drivers/mfd/Kconfig
@@ -801,6 +801,12 @@ config MFD_RK808
 	  through I2C interface. The device supports multiple sub-devices
 	  including interrupts, RTC, LDO & DCDC regulators, and onkey.
 
+config SEND_POWEROFF_SIGNAL
+	bool "send power signal when poweroff"
+	help
+	  If you say yes here you get support for the function
+	  
+
 config MFD_RN5T618
 	tristate "Ricoh RN5T5618 PMIC"
 	depends on I2C
diff --git a/drivers/mfd/rk808.c b/drivers/mfd/rk808.c
old mode 100644
new mode 100755
index 2380b5e2..4f833938
--- a/drivers/mfd/rk808.c
+++ b/drivers/mfd/rk808.c
@@ -27,6 +27,9 @@
 #include <linux/reboot.h>
 #include <linux/regmap.h>
 #include <linux/syscore_ops.h>
+#include <linux/of_gpio.h>
+#include <linux/wakelock.h>
+#include <linux/of_platform.h>
 
 struct rk808_reg_data {
 	int addr;
@@ -860,6 +863,14 @@ static void rk808_syscore_shutdown(void)
 		/* power off supplies ! */
 		if (pm_shutdown) {
 			dev_info(&rk808_i2c_client->dev, "System power off\n");
+#ifdef CONFIG_SEND_POWEROFF_SIGNAL //add by zfanji
+			dev_info(&rk808_i2c_client->dev, "send poweroff_signal~~~ %d    \n",rk808->active_low ? 0 : 1);
+			gpio_set_value(rk808->poweroff_signal, rk808->active_low ? 0 : 1);
+			mdelay(1000);
+			gpio_set_value(rk808->poweroff_signal, rk808->active_low ? 1 : 0);
+
+			dev_info(&rk808_i2c_client->dev, "send poweroff_signal~~~ %d    \n",rk808->active_low ? 1 : 0);
+#endif		
 			ret = pm_shutdown(rk808->regmap);
 			if (ret)
 				dev_err(&rk808_i2c_client->dev,
@@ -1368,6 +1379,21 @@ static int rk808_probe(struct i2c_client *client,
 			dev_err(&client->dev, "create rk8xx sysfs error\n");
 	}
 
+#ifdef CONFIG_SEND_POWEROFF_SIGNAL //add by zfanji
+	rk808->poweroff_signal = of_get_named_gpio_flags(np, "poweroff_signal-gpios", 0, NULL);
+
+	rk808->active_low = of_property_read_bool(np,
+							  "poweroff,signal-active-low");
+	
+	ret = gpio_request(rk808->poweroff_signal, "poweroff signal");
+	if (ret) {
+		dev_info(&client->dev, "poweroff signal gpio request failed.\n");
+	}else{
+		dev_info(&client->dev, "poweroff signal gpio request ok... \n");
+		gpio_direction_output(rk808->poweroff_signal, rk808->active_low ? 1 : 0);
+	}
+#endif
+
 	return 0;
 
 err_irq:
diff --git a/drivers/misc/5v_en.c b/drivers/misc/5v_en.c
new file mode 100755
index 00000000..53bb0b39
--- /dev/null
+++ b/drivers/misc/5v_en.c
@@ -0,0 +1,156 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#include <dt-bindings/gpio/gpio.h>
+#include <linux/gpio.h>
+#include <linux/of_gpio.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/fb.h>
+#include <linux/backlight.h>
+#include <linux/err.h>
+#include <linux/pwm.h>
+#include <linux/pwm_backlight.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+
+
+static struct of_device_id five_v_en_of_match[] = {
+	{ .compatible = "5v_en" },
+	{ }
+};
+
+MODULE_DEVICE_TABLE(of, five_v_en_of_match);
+
+
+static int five_v_en_probe(struct platform_device *pdev)
+{
+        struct device_node *node = pdev->dev.of_node;
+        enum of_gpio_flags flags;
+        int gpio;
+        int ret;
+        int en_value;
+
+        printk("start: %s\n", __func__); 
+        if (!node){
+			return -ENODEV;
+		}
+
+
+		//hub_rst	
+		gpio = of_get_named_gpio_flags(node,"hub_rst",0,&flags);
+		en_value = (flags == GPIO_ACTIVE_LOW)?1:0;
+		if(!gpio_is_valid(gpio)){
+			dev_err(&pdev->dev, "%s---%d,invalid hub_rst gpio%d\n",__func__,__LINE__,gpio);
+		}else{
+			ret = devm_gpio_request(&pdev->dev, gpio, "hub_rst_pin");
+			if(ret){
+				dev_err(&pdev->dev, "%s,%d,failed to request GPIO%d for hub_rst\n",__func__,__LINE__,gpio);
+				return -ENODEV;
+			}
+			gpio_direction_output(gpio, en_value);
+			msleep(50);
+			gpio_direction_output(gpio, !en_value); 
+		}
+		
+		
+		//power led enable
+		gpio = of_get_named_gpio_flags(node,"pwr_led_en",0,&flags);
+		en_value = (flags == GPIO_ACTIVE_LOW)?1:0;
+		if(!gpio_is_valid(gpio)){
+			dev_err(&pdev->dev, "%s---%d,invalid pwr_led_en gpio%d\n",__func__,__LINE__,gpio);
+		}else{
+			ret = devm_gpio_request(&pdev->dev, gpio, "pwr_led_en_gpio");
+			if(ret){
+				dev_err(&pdev->dev, "%s,%d,failed to request GPIO%d for hub_rst\n",__func__,__LINE__,gpio);
+				return -ENODEV;
+			}
+			gpio_direction_output(gpio, en_value);
+		}
+		
+
+		 //4G power 
+		 gpio = of_get_named_gpio_flags(node,"pwr_en_4g",0,&flags);
+		 en_value = (flags == GPIO_ACTIVE_HIGH)?1:0;
+		 if(!gpio_is_valid(gpio)){
+			 dev_err(&pdev->dev, "%s---%d,invalid pwr_en_4g gpio%d\n",__func__,__LINE__,gpio);
+		 }else{
+			 ret = devm_gpio_request(&pdev->dev, gpio, "pwr_en_4g_gpio");
+			 if(ret){
+				 dev_err(&pdev->dev, "%s,%d,failed to request GPIO%d for pwr_en_4g\n",__func__,__LINE__,gpio);
+				 return -ENODEV;
+			 }
+			 gpio_direction_output(gpio, !en_value);
+			 msleep(200);
+			 gpio_direction_output(gpio, en_value);
+			 msleep(100);
+		 }
+		 
+	 
+		 //4G  reset
+		 gpio = of_get_named_gpio_flags(node,"rst_4g",0,&flags);
+		 en_value = (flags == GPIO_ACTIVE_HIGH)?1:0;
+		 if(!gpio_is_valid(gpio)){
+			 dev_err(&pdev->dev, "%s---%d,invalid rst_4g gpio%d\n",__func__,__LINE__,gpio);
+		 }else{
+			 ret = devm_gpio_request(&pdev->dev, gpio, "rst_4g_gpio");
+			 if(ret){
+				 dev_err(&pdev->dev, "%s,%d,failed to request GPIO%d for rst_4g\n",__func__,__LINE__,gpio);
+				 return -ENODEV;
+			 }
+			 
+			 gpio_direction_output(gpio, en_value);
+			 msleep(200);
+			 gpio_direction_output(gpio, !en_value);
+		 }
+
+
+        printk("end: %s\n", __func__); 
+        return 0;
+}
+
+static int five_v_en_remove(struct platform_device *pdev)
+{
+        //printk("func: %s\n", __func__); 
+	return 0;
+}
+
+#ifdef CONFIG_PM_SLEEP
+static int five_v_en_suspend(struct device *dev)
+{
+        //printk("func: %s\n", __func__); 
+	return 0;
+}
+
+static int five_v_en_resume(struct device *dev)
+{
+        //printk("func: %s\n", __func__); 
+	return 0;
+}
+#endif
+
+static const struct dev_pm_ops five_v_en_pm_ops = {
+#ifdef CONFIG_PM_SLEEP
+	.suspend = five_v_en_suspend,
+	.resume = five_v_en_resume,
+	.poweroff = five_v_en_suspend,
+	.restore = five_v_en_resume,
+#endif
+};
+
+static struct platform_driver five_v_en_driver = {
+	.driver		= {
+		.name		= "five_v_en",
+		.owner		= THIS_MODULE,
+		.pm		= &five_v_en_pm_ops,
+		.of_match_table	= of_match_ptr(five_v_en_of_match),
+	},
+	.probe		= five_v_en_probe,
+	.remove		= five_v_en_remove,
+};
+
+module_platform_driver(five_v_en_driver);
+
+MODULE_DESCRIPTION("5v power for otg and hdmi Driver");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:five_v_en");
diff --git a/drivers/misc/Kconfig b/drivers/misc/Kconfig
old mode 100644
new mode 100755
index 77fa126e..f9acde9d
--- a/drivers/misc/Kconfig
+++ b/drivers/misc/Kconfig
@@ -564,6 +564,14 @@ config GPIO_DET
 	help
 	  Enable this driver will support gpio detection.
 
+config 5V_EN
+	bool "5v en power control for otg and hdmi"
+	default y
+	help
+	  This driver is control enable 5v power when startup and disable it
+	  when suspend and no insert otg. if your board is control this power
+	  by a gpio please select it. 
+	  
 source "drivers/misc/c2port/Kconfig"
 source "drivers/misc/eeprom/Kconfig"
 source "drivers/misc/cb710/Kconfig"
diff --git a/drivers/misc/Makefile b/drivers/misc/Makefile
old mode 100644
new mode 100755
index b58f922d..bf5ef6a8
--- a/drivers/misc/Makefile
+++ b/drivers/misc/Makefile
@@ -61,3 +61,4 @@ obj-$(CONFIG_CXL_BASE)		+= cxl/
 obj-$(CONFIG_UID_SYS_STATS) += uid_sys_stats.o
 obj-$(CONFIG_MEMORY_STATE_TIME) += memory_state_time.o
 obj-$(CONFIG_USB_CAM_GPIO)	+= usb_cam_gpio.o
+obj-$(CONFIG_5V_EN)	+= 5v_en.o
diff --git a/drivers/net/ethernet/stmicro/stmmac/dwmac-rk.c b/drivers/net/ethernet/stmicro/stmmac/dwmac-rk.c
old mode 100644
new mode 100755
index 541bf10a..375a3fee
--- a/drivers/net/ethernet/stmicro/stmmac/dwmac-rk.c
+++ b/drivers/net/ethernet/stmicro/stmmac/dwmac-rk.c
@@ -1688,6 +1688,15 @@ static int rk_gmac_remove(struct platform_device *pdev)
 	return ret;
 }
 
+
+static void rk_gmac_shutdown(struct platform_device *pdev)
+{
+
+	stmmac_shutdown(&pdev->dev);
+
+}
+
+
 #ifdef CONFIG_PM_SLEEP
 static int rk_gmac_suspend(struct device *dev)
 {
@@ -1738,6 +1747,7 @@ MODULE_DEVICE_TABLE(of, rk_gmac_dwmac_match);
 static struct platform_driver rk_gmac_dwmac_driver = {
 	.probe  = rk_gmac_probe,
 	.remove = rk_gmac_remove,
+	.shutdown = rk_gmac_shutdown,
 	.driver = {
 		.name           = "rk_gmac-dwmac",
 		.pm		= &rk_gmac_pm_ops,
diff --git a/drivers/net/ethernet/stmicro/stmmac/stmmac.h b/drivers/net/ethernet/stmicro/stmmac/stmmac.h
old mode 100644
new mode 100755
index 02f7b2c5..60093f4a
--- a/drivers/net/ethernet/stmicro/stmmac/stmmac.h
+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac.h
@@ -142,6 +142,8 @@ int stmmac_ptp_register(struct stmmac_priv *priv);
 void stmmac_ptp_unregister(struct stmmac_priv *priv);
 int stmmac_resume(struct device *dev);
 int stmmac_suspend(struct device *dev);
+int stmmac_shutdown(struct device *dev);
+
 int stmmac_dvr_remove(struct device *dev);
 int stmmac_dvr_probe(struct device *device,
 		     struct plat_stmmacenet_data *plat_dat,
diff --git a/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c b/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
old mode 100644
new mode 100755
index 5113e61b..69fcfcd3
--- a/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
@@ -3048,6 +3048,49 @@ int stmmac_dvr_remove(struct device *dev)
 }
 EXPORT_SYMBOL_GPL(stmmac_dvr_remove);
 
+int stmmac_shutdown(struct device *dev)
+{
+#if 1
+	struct net_device *ndev = dev_get_drvdata(dev);
+	struct stmmac_priv *priv = netdev_priv(ndev);
+	printk("stmmac_shutdown\n");
+	
+	if (!netif_running(ndev))
+		return 0;
+
+	/**/
+	if (priv->dev->dev_addr) {
+		printk("stmmac_shutdown set MAC: %x:%x:%x:%x:%x:%x\n",
+			priv->dev->dev_addr[0],
+			priv->dev->dev_addr[1],
+			priv->dev->dev_addr[2],
+			priv->dev->dev_addr[3],
+			priv->dev->dev_addr[4],
+			priv->dev->dev_addr[5]);
+		//set MAC address
+		phy_write(priv->dev->phydev, 0x1f, 0x7);
+		phy_write(priv->dev->phydev, 0x1e, 0x6e);
+		phy_write(priv->dev->phydev, 0x15, ((u16)priv->dev->dev_addr[1] << 8) + priv->dev->dev_addr[0]); //0x0000);
+		phy_write(priv->dev->phydev, 0x16, ((u16)priv->dev->dev_addr[3] << 8) + priv->dev->dev_addr[2]); //0x0000);
+		phy_write(priv->dev->phydev, 0x17, ((u16)priv->dev->dev_addr[5] << 8) + priv->dev->dev_addr[4]); //0x0300);
+		//set max packet length
+		phy_write(priv->dev->phydev, 0x1f, 0x7);
+		phy_write(priv->dev->phydev, 0x1e, 0x6d);
+		phy_write(priv->dev->phydev, 0x16, 0x1fff);
+		//enable wol event
+		phy_write(priv->dev->phydev, 0x1f, 0x7);
+		phy_write(priv->dev->phydev, 0x1e, 0x6d);
+		phy_write(priv->dev->phydev, 0x15, 0x1000);
+		//disable rgmii pad
+		phy_write(priv->dev->phydev, 0x1f, 0x7);
+		phy_write(priv->dev->phydev, 0x1e, 0x6d);
+		phy_write(priv->dev->phydev, 0x19, 0x0001);
+		return 0;
+		}
+#endif
+	return 0;
+}
+
 /**
  * stmmac_suspend - suspend callback
  * @dev: device pointer
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8723bu/Makefile b/drivers/net/wireless/rockchip_wlan/rtl8723bu/Makefile
old mode 100644
new mode 100755
index 541757cd..087762ce
--- a/drivers/net/wireless/rockchip_wlan/rtl8723bu/Makefile
+++ b/drivers/net/wireless/rockchip_wlan/rtl8723bu/Makefile
@@ -76,7 +76,7 @@ CONFIG_RTW_SDIO_PM_KEEP_POWER = y
 ###################### MP HW TX MODE FOR VHT #######################
 CONFIG_MP_VHT_HW_TX_MODE = n
 ###################### Platform Related #######################
-CONFIG_PLATFORM_I386_PC = y
+CONFIG_PLATFORM_I386_PC = n
 CONFIG_PLATFORM_ANDROID_X86 = n
 CONFIG_PLATFORM_ANDROID_INTEL_X86 = n
 CONFIG_PLATFORM_JB_X86 = n
@@ -101,7 +101,7 @@ CONFIG_PLATFORM_ARM_TCC8920_JB42 = n
 CONFIG_PLATFORM_ARM_TCC8930_JB42 = n
 CONFIG_PLATFORM_ARM_RK2818 = n
 CONFIG_PLATFORM_ARM_RK3066 = n
-CONFIG_PLATFORM_ARM_RK3188 = n
+CONFIG_PLATFORM_ARM_RK3188 = y
 CONFIG_PLATFORM_ARM_URBETTER = n
 CONFIG_PLATFORM_ARM_TI_PANDA = n
 CONFIG_PLATFORM_MIPS_JZ4760 = n
@@ -1252,7 +1252,7 @@ EXTRA_CFLAGS += -DRTW_SUPPORT_PLATFORM_SHUTDOWN
 ARCH := arm
 CROSS_COMPILE := /home/android_sdk/Rockchip/Rk3188/prebuilts/gcc/linux-x86/arm/arm-eabi-4.6/bin/arm-eabi-
 KSRC := /home/android_sdk/Rockchip/Rk3188/kernel
-MODULE_NAME := wlan
+MODULE_NAME := 8723bu
 endif
 
 ifeq ($(CONFIG_PLATFORM_ARM_RK3066), y)
diff --git a/drivers/net/wireless/rockchip_wlan/rtl8723bu/os_dep/linux/rtw_android.c b/drivers/net/wireless/rockchip_wlan/rtl8723bu/os_dep/linux/rtw_android.c
index 8de7ff72..e9bf6c45 100755
--- a/drivers/net/wireless/rockchip_wlan/rtl8723bu/os_dep/linux/rtw_android.c
+++ b/drivers/net/wireless/rockchip_wlan/rtl8723bu/os_dep/linux/rtw_android.c
@@ -1040,9 +1040,9 @@ void *wifi_get_country_code(char *ccode)
 	DBG_871X("%s\n", __FUNCTION__);
 	if (!ccode)
 		return NULL;
-	if (wifi_control_data && wifi_control_data->get_country_code) {
-		return wifi_control_data->get_country_code(ccode);
-	}
+	//if (wifi_control_data && wifi_control_data->get_country_code) {
+	//	return wifi_control_data->get_country_code(ccode);
+	//}
 	return NULL;
 }
 #endif /* (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 39)) */
@@ -1101,7 +1101,7 @@ static int wifi_probe(struct platform_device *pdev)
 }
 
 #ifdef RTW_SUPPORT_PLATFORM_SHUTDOWN
-extern PADAPTER g_test_adapter;
+PADAPTER g_test_adapter;
 
 static void shutdown_card(void)
 {
diff --git a/drivers/rtc/rtc-hym8563.c b/drivers/rtc/rtc-hym8563.c
old mode 100644
new mode 100755
index 864f645e..dffba9f3
--- a/drivers/rtc/rtc-hym8563.c
+++ b/drivers/rtc/rtc-hym8563.c
@@ -16,12 +16,14 @@
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  */
+//#define DEBUG
 
 #include <linux/module.h>
 #include <linux/clk-provider.h>
 #include <linux/i2c.h>
 #include <linux/bcd.h>
 #include <linux/rtc.h>
+#include <linux/of_gpio.h>
 
 #define HYM8563_CTL1		0x00
 #define HYM8563_CTL1_TEST	BIT(7)
@@ -102,9 +104,10 @@ static int hym8563_rtc_read_time(struct device *dev, struct rtc_time *tm)
 	struct hym8563 *hym8563 = i2c_get_clientdata(client);
 	u8 buf[7];
 	int ret;
+	dev_dbg(&client->dev, "%s    \n",__func__);
 
 	if (!hym8563->valid) {
-		dev_warn(&client->dev, "no valid clock/calendar values available\n");
+		dev_warn(&client->dev, "xxxx no valid clock/calendar values available\n");
 		return -EPERM;
 	}
 
@@ -127,7 +130,7 @@ static int hym8563_rtc_set_time(struct device *dev, struct rtc_time *tm)
 	struct hym8563 *hym8563 = i2c_get_clientdata(client);
 	u8 buf[7];
 	int ret;
-
+	dev_dbg(&client->dev,"%s    \n",__func__);
 	/* Years >= 2100 are to far in the future, 19XX is to early */
 	if (tm->tm_year < 100 || tm->tm_year >= 200)
 		return -EINVAL;
@@ -175,6 +178,8 @@ static int hym8563_rtc_alarm_irq_enable(struct device *dev,
 	int data;
 
 	data = i2c_smbus_read_byte_data(client, HYM8563_CTL2);
+	
+	printk("%s %d 0x%.4x   \n",__func__,enabled,data);
 	if (data < 0)
 		return data;
 
@@ -182,6 +187,9 @@ static int hym8563_rtc_alarm_irq_enable(struct device *dev,
 		data |= HYM8563_CTL2_AIE;
 	else
 		data &= ~HYM8563_CTL2_AIE;
+	
+	data &= ~HYM8563_CTL2_TIE;
+	data &= ~HYM8563_CTL2_AF;
 
 	return i2c_smbus_write_byte_data(client, HYM8563_CTL2, data);
 };
@@ -192,6 +200,7 @@ static int hym8563_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *alm)
 	struct rtc_time *alm_tm = &alm->time;
 	u8 buf[4];
 	int ret;
+	dev_dbg(&client->dev,"%s    \n",__func__);
 
 	ret = i2c_smbus_read_i2c_block_data(client, HYM8563_ALM_MIN, 4, buf);
 	if (ret < 0)
@@ -232,6 +241,7 @@ static int hym8563_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alm)
 	struct rtc_time *alm_tm = &alm->time;
 	u8 buf[4];
 	int ret;
+	printk("%s    \n",__func__);
 
 	/*
 	 * The alarm has no seconds so deal with it
@@ -443,6 +453,7 @@ static irqreturn_t hym8563_irq(int irq, void *dev_id)
 	struct i2c_client *client = hym8563->client;
 	struct mutex *lock = &hym8563->rtc->ops_lock;
 	int data, ret;
+	printk("%s    \n",__func__);
 
 	mutex_lock(lock);
 
@@ -532,23 +543,21 @@ static int hym8563_probe(struct i2c_client *client,
 {
 	struct hym8563 *hym8563;
 	int ret;
-	/* hym8563 initial time,avoid hym8563 read time error */
-	struct rtc_time tm_read, tm = {
-		.tm_wday = 0,
+	struct rtc_time tm = {
+		.tm_wday = 6,
 		.tm_year = 117,
 		.tm_mon = 0,
 		.tm_mday = 1,
 		.tm_hour = 12,
 		.tm_min = 0,
 		.tm_sec = 0,
-	};
+	};	
 
 	hym8563 = devm_kzalloc(&client->dev, sizeof(*hym8563), GFP_KERNEL);
 	if (!hym8563)
 		return -ENOMEM;
 
 	hym8563->client = client;
-	hym8563->valid = true;
 	i2c_set_clientdata(client, hym8563);
 
 	device_set_wakeup_capable(&client->dev, true);
@@ -575,18 +584,22 @@ static int hym8563_probe(struct i2c_client *client,
 	ret = i2c_smbus_read_byte_data(client, HYM8563_SEC);
 	if (ret < 0)
 		return ret;
-	if (ret & HYM8563_SEC_VL)
-		hym8563_rtc_set_time(&client->dev, &tm);
 
-	hym8563_rtc_read_time(&client->dev, &tm_read);
-	if (((tm_read.tm_year < 70) | (tm_read.tm_year > 137)) | (tm_read.tm_mon == -1) | (rtc_valid_tm(&tm_read) != 0)) //if the hym8563 haven't initialized
-		hym8563_rtc_set_time(&client->dev, &tm);	//initialize the hym8563
+	//dev_info(&client->dev, "HYM8563_SEC=0x%.2x \n");
+	
+	if (ret & HYM8563_SEC_VL){
+		dev_info(&client->dev,"reset time ~~~ \n");
+		hym8563_rtc_set_time(&client->dev, &tm);//initialize the hym8563
+	}
+
 
 	if (ret & HYM8563_SEC_VL)
 		ret = i2c_smbus_read_byte_data(client, HYM8563_SEC);
 
 	hym8563->valid = !(ret & HYM8563_SEC_VL);
-	dev_dbg(&client->dev, "rtc information is %s\n",
+
+	
+	dev_info(&client->dev, "ret=0x%.2x rtc information is %s\n",ret,
 		hym8563->valid ? "valid" : "invalid");
 
 	hym8563->rtc = devm_rtc_device_register(&client->dev, client->name,
diff --git a/drivers/spi/Kconfig b/drivers/spi/Kconfig
old mode 100644
new mode 100755
index 8b9c2a38..d32b005d
--- a/drivers/spi/Kconfig
+++ b/drivers/spi/Kconfig
@@ -654,6 +654,15 @@ config SPI_NUC900
 	help
 	  SPI driver for Nuvoton NUC900 series ARM SoCs
 
+
+config SPI_WK2XXX
+        tristate "wk2xxx support "
+        default y
+        help
+          This supports user mode SPI protocol drivers.
+
+          Note that this application programming interface is EXPERIMENTAL
+          and hence SUBJECT TO CHANGE WITHOUT NOTICE while it stabilizes.
 #
 # Add new SPI master controllers in alphabetical order above this line
 #
diff --git a/drivers/spi/Makefile b/drivers/spi/Makefile
old mode 100644
new mode 100755
index 31fb7fb2..d511044e
--- a/drivers/spi/Makefile
+++ b/drivers/spi/Makefile
@@ -93,3 +93,6 @@ obj-$(CONFIG_SPI_XILINX)		+= spi-xilinx.o
 obj-$(CONFIG_SPI_XLP)			+= spi-xlp.o
 obj-$(CONFIG_SPI_XTENSA_XTFPGA)		+= spi-xtensa-xtfpga.o
 obj-$(CONFIG_SPI_ZYNQMP_GQSPI)		+= spi-zynqmp-gqspi.o
+obj-$(CONFIG_SPI_WK2XXX)            += wk2xxx_spi.o
+obj-$(CONFIG_SPI_WK2XXX)            += spi-rockchip-test.o
+
diff --git a/drivers/spi/wk2xxx.h b/drivers/spi/wk2xxx.h
new file mode 100755
index 00000000..e2e469c3
--- /dev/null
+++ b/drivers/spi/wk2xxx.h
@@ -0,0 +1,176 @@
+
+/*
+*	WKIC Ltd.
+*	WK2xxx.c
+*	wk2xxx_GPIO_I2C DEMO Ver
+
+ion :1.0 Data:2018-08-08
+*	By  xuxunwei Tech 
+*
+*/
+#ifndef	_SERIAL_WK2XXX_H       //_SERIAL_WK2XXX_H
+#define  _SERIAL_WK2XXX_H
+	
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/console.h>
+#include <asm/irq.h>
+
+
+
+/*****************************
+***wkxxxx  Global register address defines
+******************************/
+#define 	WK2XXX_GENA     0X00
+#define 	WK2XXX_GRST     0X01
+#define		WK2XXX_GMUT     0X02
+#define 	WK2XXX_GIER     0X10
+#define 	WK2XXX_GIFR     0X11
+#define 	WK2XXX_GPDIR    0X21
+#define 	WK2XXX_GPDAT    0X31
+
+
+/*****************************
+*wkxxxx  slave uarts  register address defines
+******************************/
+#define 	WK2XXX_SPAGE    0X03
+#define 	WK2XXX_PAGE1    1
+#define 	WK2XXX_PAGE0    0
+
+/*PAGE0*/
+#define 	WK2XXX_SCR      0X04
+#define 	WK2XXX_LCR      0X05
+#define 	WK2XXX_FCR      0X06
+#define 	WK2XXX_SIER     0X07
+#define 	WK2XXX_SIFR     0X08
+#define 	WK2XXX_TFCNT    0X09
+#define 	WK2XXX_RFCNT    0X0A
+#define 	WK2XXX_FSR      0X0B
+#define 	WK2XXX_LSR      0X0C
+#define 	WK2XXX_FDAT     0X0D
+#define 	WK2XXX_FWCR     0X0E
+#define 	WK2XXX_RS485    0X0F
+/*PAGE1*/
+#define 	WK2XXX_BAUD1    0X04
+#define 	WK2XXX_BAUD0    0X05
+#define 	WK2XXX_PRES     0X06
+#define 	WK2XXX_RFTL     0X07
+#define 	WK2XXX_TFTL     0X08
+#define 	WK2XXX_FWTH     0X09
+#define 	WK2XXX_FWTL     0X0A
+#define 	WK2XXX_XON1     0X0B
+#define 	WK2XXX_XOFF1    0X0C
+#define 	WK2XXX_SADR     0X0D
+#define 	WK2XXX_SAEN     0X0E
+#define 	WK2XXX_RRSDLY   0X0F
+
+
+//wkxxx register bit defines
+/*GENA register*/
+#define 	WK2XXX_UT4EN	  0x08
+#define 	WK2XXX_UT3EN	  0x04
+#define 	WK2XXX_UT2EN	  0x02
+#define 	WK2XXX_UT1EN	  0x01
+/*GRST register*/
+#define 	WK2XXX_UT4SLEEP	0x80
+#define 	WK2XXX_UT3SLEEP	0x40
+#define 	WK2XXX_UT2SLEEP	0x20
+#define 	WK2XXX_UT1SLEEP	0x10
+#define 	WK2XXX_UT4RST	    0x08
+#define 	WK2XXX_UT3RST		0x04
+#define 	WK2XXX_UT2RST		0x02
+#define 	WK2XXX_UT1RST		0x01
+/*GIER register*/
+#define 	WK2XXX_UT4IE		0x08
+#define 	WK2XXX_UT3IE		0x04
+#define 	WK2XXX_UT2IE		0x02
+#define 	WK2XXX_UT1IE		0x01
+/*GIFR register*/
+#define 	WK2XXX_UT4INT		0x08
+#define 	WK2XXX_UT3INT		0x04
+#define 	WK2XXX_UT2INT		0x02
+#define 	WK2XXX_UT1INT		0x01
+/*SPAGE register*/
+#define 	WK2XXX_SPAGE0	    0x00
+#define 	WK2XXX_SPAGE1     0x01
+/*SCR register*/
+#define 	WK2XXX_SLEEPEN    0x04
+#define 	WK2XXX_TXEN       0x02
+#define 	WK2XXX_RXEN       0x01
+/*LCR register*/
+#define 	WK2XXX_BREAK	  0x20
+#define 	WK2XXX_IREN     0x10
+#define 	WK2XXX_PAEN     0x08
+#define 	WK2XXX_PAM1     0x04
+#define 	WK2XXX_PAM0     0x02
+#define 	WK2XXX_STPL     0x01
+/*FCR register*/
+#define 	WK2XXX_TFEN     0x08
+#define 	WK2XXX_RFEN     0x04
+#define 	WK2XXX_TFRST    0x02
+#define 	WK2XXX_RFRST    0x01
+/*SIER register*/
+#define 	WK2XXX_FERR_IEN      0x80
+#define 	WK2XXX_CTS_IEN       0x40
+#define 	WK2XXX_RTS_IEN       0x20
+#define 	WK2XXX_XOFF_IEN      0x10
+#define 	WK2XXX_TFEMPTY_IEN   0x08
+#define 	WK2XXX_TFTRIG_IEN    0x04
+#define 	WK2XXX_RXOUT_IEN     0x02
+#define 	WK2XXX_RFTRIG_IEN    0x01
+/*SIFR register*/
+#define 	WK2XXX_FERR_INT      0x80
+#define 	WK2XXX_CTS_INT       0x40
+#define 	WK2XXX_RTS_INT       0x20
+#define 	WK2XXX_XOFF_INT      0x10
+#define 	WK2XXX_TFEMPTY_INT   0x08
+#define 	WK2XXX_TFTRIG_INT    0x04
+#define 	WK2XXX_RXOVT_INT     0x02
+#define 	WK2XXX_RFTRIG_INT    0x01
+
+/*TFCNT register*/
+/*RFCNT register*/
+/*FSR register*/
+#define 	WK2XXX_RFOE      0x80
+#define 	WK2XXX_RFBI      0x40
+#define 	WK2XXX_RFFE      0x20
+#define 	WK2XXX_RFPE      0x10
+#define 	WK2XXX_RDAT      0x08
+#define 	WK2XXX_TDAT      0x04
+#define 	WK2XXX_TFULL     0x02
+#define 	WK2XXX_TBUSY     0x01
+/*LSR register*/
+#define 	WK2XXX_OE        0x08
+#define 	WK2XXX_BI        0x04
+#define 	WK2XXX_FE        0x02
+#define 	WK2XXX_PE        0x01
+/*FWCR register*/
+#define 	WK2XXX_RTS       0x02
+#define 	WK2XXX_CTS       0x01
+/*RS485 register*/
+#define 	WK2XXX_RSRS485   0x40
+#define 	WK2XXX_ATADD     0x20
+#define 	WK2XXX_DATEN     0x10
+#define 	WK2XXX_RTSEN     0x02
+#define 	WK2XXX_RTSINV    0x01
+
+
+
+//
+#define 	NR_PORTS 	4
+
+//
+#define 	SERIAL_WK2XXX_MAJOR	    	207
+#define 	CALLOUT_WK2XXX_MAJOR		  208	
+#define 	MINOR_START		            5
+//wk2xxx hardware configuration
+#define		wk2xxx_spi_speed	10000000
+#define 	IRQ_WK2XXX		GPIO7_A2
+#define 	WK_CRASTAL_CLK		(3686400*2)
+#define     MAX_WK2XXX           	4
+#define 	WK2XXX_ISR_PASS_LIMIT	50
+#define		PORT_WK2XXX            1
+#endif
+
diff --git a/drivers/spi/wk2xxx_spi.c b/drivers/spi/wk2xxx_spi.c
new file mode 100755
index 00000000..3c6d402f
--- /dev/null
+++ b/drivers/spi/wk2xxx_spi.c
@@ -0,0 +1,1784 @@
+/*
+*   FILE NAME  : wk2xxx_spi.c   
+*
+*   WKIC Ltd.
+*   By  Xu XunWei Tech  
+*   DEMO Version :2.0 Data:2018-8-08
+*
+*   DESCRIPTION: Implements an interface for the wk2xxx of spi interface
+*
+*   1. compiler warnings all changes
+*/
+
+
+
+
+#include <linux/init.h>                        
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/console.h>
+#include <linux/tty.h>
+#include <linux/tty_flip.h>
+#include <linux/serial_core.h>
+#include <linux/delay.h>
+#include <linux/err.h>
+#include <linux/freezer.h>
+#include <linux/spi/spi.h>
+#include <linux/timer.h>
+#include <linux/of_gpio.h>
+#include <linux/gpio.h>
+
+
+#include <linux/workqueue.h>
+#include <linux/platform_device.h>
+//#include <asm/mach/map.h>
+#include <asm/irq.h>
+#include <asm/io.h>
+#include <linux/platform_data/spi-rockchip.h>
+#include "wk2xxx.h"
+
+
+
+MODULE_LICENSE("Dual BSD/GPL");
+
+//#define _DEBUG_WK2XXX
+//#define _DEBUG_WK2XXX1
+//#define _DEBUG_WK2XXX2
+//#define _DEBUG_WK2XXX4
+//#define _DEBUG_WK2XXX5
+
+#define WK2XXX_STATUS_PE    1
+#define WK2XXX_STATUS_FE    2
+#define WK2XXX_STATUS_BRK   4
+#define WK2XXX_STATUS_OE    8
+
+
+static DEFINE_MUTEX(wk2xxxs_lock);                /* race on probe */
+static DEFINE_MUTEX(wk2xxxs_reg_lock);
+static DEFINE_MUTEX(wk2xxs_work_lock);                /* work on probe */
+
+struct wk2xxx_port 
+{
+    //struct timer_list mytimer;    
+    
+    struct uart_port port;//[NR_PORTS];
+    struct spi_device *spi_wk;
+    spinlock_t conf_lock;   /* shared data */
+    struct workqueue_struct *workqueue;
+    struct work_struct work;
+    int suspending;
+    void (*wk2xxx_hw_suspend) (int suspend);
+    int tx_done;
+
+    int force_end_work;
+    int irq;
+    int minor;      /* minor number */
+    int tx_empty; 
+    int tx_empty_flag;
+
+
+    int start_tx_flag;
+    int stop_tx_flag;
+    int stop_rx_flag; 
+    int irq_flag;
+    int conf_flag;
+
+    int tx_empty_fail;
+    int start_tx_fail;
+    int stop_tx_fail;
+    int stop_rx_fail;
+    int irq_fail;
+    int conf_fail;
+
+
+    uint8_t new_lcr;
+	uint8_t new_fwcr;
+    uint8_t new_scr; 
+    /*set baud 0f register*/
+    uint8_t new_baud1;
+    uint8_t new_baud0;
+    uint8_t new_pres;
+
+};
+
+static struct wk2xxx_port wk2xxxs[NR_PORTS]; /* the chips */
+/*
+* This function read wk2xxx of Global register:
+*/
+static int wk2xxx_read_global_reg(struct spi_device *spi,uint8_t reg,uint8_t *dat)
+{
+        struct spi_message msg;
+        uint8_t buf_wdat[2];
+        uint8_t buf_rdat[2];
+        int status;
+        struct spi_transfer index_xfer = {
+                .len            = 2,
+                //.cs_change      = 1,
+                .speed_hz	= wk2xxx_spi_speed,
+        };
+        mutex_lock(&wk2xxxs_reg_lock);
+        status =0;
+        spi_message_init(&msg);
+        buf_wdat[0] = 0x40|reg;
+        buf_wdat[1] = 0x00;
+        buf_rdat[0] = 0x00;
+        buf_rdat[1] = 0x00;
+        index_xfer.tx_buf = buf_wdat;
+        index_xfer.rx_buf =(void *) buf_rdat;
+        spi_message_add_tail(&index_xfer, &msg);
+        status = spi_sync(spi, &msg);
+        mutex_unlock(&wk2xxxs_reg_lock);
+        if(status)
+        {
+         return status;
+         }
+        *dat = buf_rdat[1];
+         return 0;
+
+}
+/*
+* This function write wk2xxx of Global register:
+*/
+static int wk2xxx_write_global_reg(struct spi_device *spi,uint8_t reg,uint8_t dat)
+{
+        struct spi_message msg;
+        uint8_t buf_reg[2];
+        int status;
+        struct spi_transfer index_xfer = {
+                .len            = 2,
+                //.cs_change      = 1,
+                .speed_hz	= wk2xxx_spi_speed,
+        };
+        mutex_lock(&wk2xxxs_reg_lock);
+        spi_message_init(&msg);
+        /* register index */
+        buf_reg[0] = 0x00|reg;
+        buf_reg[1] = dat;
+        index_xfer.tx_buf = buf_reg;
+        spi_message_add_tail(&index_xfer, &msg);
+        status = spi_sync(spi, &msg);
+        mutex_unlock(&wk2xxxs_reg_lock);
+        return status;
+}
+/*
+* This function read wk2xxx of slave register:
+*/
+static int wk2xxx_read_slave_reg(struct spi_device *spi,uint8_t port,uint8_t reg,uint8_t *dat)
+{
+        struct spi_message msg;
+        uint8_t buf_wdat[2];
+        uint8_t buf_rdat[2];
+        int status;
+        struct spi_transfer index_xfer = {
+                .len            = 2,
+                //.cs_change      = 1,
+                .speed_hz	= wk2xxx_spi_speed,
+        };
+        mutex_lock(&wk2xxxs_reg_lock);
+        status =0;
+        spi_message_init(&msg);
+        buf_wdat[0] = 0x40|(((port-1)<<4)|reg);
+        buf_wdat[1] = 0x00;
+        buf_rdat[0] = 0x00;
+        buf_rdat[1] = 0x00;
+        index_xfer.tx_buf = buf_wdat;
+        index_xfer.rx_buf =(void *) buf_rdat;
+        spi_message_add_tail(&index_xfer, &msg);
+        status = spi_sync(spi, &msg);
+        mutex_unlock(&wk2xxxs_reg_lock);
+        if(status)
+        {
+           return status;
+         }
+        *dat = buf_rdat[1];
+         return 0;
+
+}
+/*
+* This function write wk2xxx of Slave register:
+*/
+static int wk2xxx_write_slave_reg(struct spi_device *spi,uint8_t port,uint8_t reg,uint8_t dat)
+{
+        struct spi_message msg;
+        uint8_t buf_reg[2];
+        int status;
+        struct spi_transfer index_xfer = {
+                .len            = 2,
+                //.cs_change      = 1,
+				.speed_hz	= wk2xxx_spi_speed,
+        };
+        mutex_lock(&wk2xxxs_reg_lock);
+        spi_message_init(&msg);
+        /* register index */
+        buf_reg[0] = ((port-1)<<4)|reg;
+        buf_reg[1] = dat;
+        index_xfer.tx_buf = buf_reg;
+        spi_message_add_tail(&index_xfer, &msg);
+        status = spi_sync(spi, &msg);
+        mutex_unlock(&wk2xxxs_reg_lock);
+        return status;
+}
+
+#define MAX_RFCOUNT_SIZE 256
+
+/*
+* This function read wk2xxx of fifo:
+*/
+static int wk2xxx_read_fifo(struct spi_device *spi,uint8_t port,uint8_t fifolen,uint8_t *dat)
+{
+        struct spi_message msg;
+        int status,i;
+        uint8_t recive_fifo_data[MAX_RFCOUNT_SIZE+1]={0};
+        uint8_t transmit_fifo_data[MAX_RFCOUNT_SIZE+1]={0};
+        struct spi_transfer index_xfer = {
+                .len            = fifolen+1,
+                //.cs_change      = 1,
+                .speed_hz	= wk2xxx_spi_speed,
+        }; 
+	    if(!(fifolen>0))
+	      {
+			printk(KERN_ERR "%s,fifolen error!!\n", __func__);
+			return 1;
+		  }
+        mutex_lock(&wk2xxxs_reg_lock);
+        spi_message_init(&msg);
+        /* register index */
+        transmit_fifo_data[0] = ((port-1)<<4)|0xc0;
+        index_xfer.tx_buf = transmit_fifo_data;
+        index_xfer.rx_buf =(void *) recive_fifo_data;
+        spi_message_add_tail(&index_xfer, &msg);
+        
+        status = spi_sync(spi, &msg);
+        udelay(1);
+        for(i=0;i<fifolen;i++)
+            *(dat+i)=recive_fifo_data[i+1];
+        mutex_unlock(&wk2xxxs_reg_lock);
+        return status;
+        
+}
+/*
+* This function write wk2xxx of fifo:
+*/
+static int wk2xxx_write_fifo(struct spi_device *spi,uint8_t port,uint8_t fifolen,uint8_t *dat)
+{
+        struct spi_message msg;
+        int status,i;
+        uint8_t recive_fifo_data[MAX_RFCOUNT_SIZE+1]={0};
+        uint8_t transmit_fifo_data[MAX_RFCOUNT_SIZE+1]={0};
+        struct spi_transfer index_xfer = {
+                .len            = fifolen+1,
+                //.cs_change      = 1,
+                .speed_hz	= wk2xxx_spi_speed,
+        }; 
+	    if(!(fifolen>0))
+	      {
+			printk(KERN_ERR "%s,fifolen error!!\n", __func__);
+			return 1;
+		  }
+
+        mutex_lock(&wk2xxxs_reg_lock);
+        spi_message_init(&msg);
+        /* register index */
+        transmit_fifo_data[0] = ((port-1)<<4)|0x80;
+         for(i=0;i<fifolen;i++)
+            {
+            transmit_fifo_data[i+1]=*(dat+i);
+            }
+        index_xfer.tx_buf = transmit_fifo_data;
+        index_xfer.rx_buf =(void *) recive_fifo_data;
+        spi_message_add_tail(&index_xfer, &msg);
+        status = spi_sync(spi, &msg);
+        mutex_unlock(&wk2xxxs_reg_lock);
+        return status;
+        
+}
+
+static void wk2xxxirq_app(struct uart_port *port);
+static void conf_wk2xxx_subport(struct uart_port *port);
+static void wk2xxx_work(struct work_struct *w);
+static void wk2xxx_stop_tx(struct uart_port *port);
+static u_int wk2xxx_tx_empty(struct uart_port *port);// or query the tx fifo is not empty?
+
+static int wk2xxx_dowork(struct wk2xxx_port *s)
+{    
+#ifdef _DEBUG_WK2XXX
+    printk( "--wk2xxx_dowork()---\n");
+#endif
+
+    if (!s->force_end_work && !work_pending(&s->work) && !freezing(current) && !s->suspending)
+    {
+        queue_work(s->workqueue, &s->work);//
+        #ifdef _DEBUG_WK2XXX
+         printk( "--queue_work---ok---\n");;
+// printk("work_pending =: %d s->force_end_work  = : %d freezing(current) = :%d s->suspending= :%d\n" ,work_pending(&s->work),s->force_end_work ,freezing(current),s->suspending);
+      #endif
+        return 1;   
+    }
+    else
+    {
+      #ifdef _DEBUG_WK2XXX
+        printk( "--queue_work---error---\n");
+      #endif
+
+//printk("work_pending =: %d s->force_end_work  = : %d freezing(current) = :%d s->suspending= :%d\n" ,work_pending(&s->work),s->force_end_work ,freezing(current),s->suspending);
+    //  return 0;
+//  printk("work_pending() =: %d tx_empty_flag = : %d start_tx_flag = :%d stop_tx_flag = :%d conf_flag =: %d irq_flag =: %d tx_empty=:%d\n",work_pending(&s->work),s->tx_empty_flag,s->start_tx_flag,s->stop_tx_flag,s->stop_rx_flag,s->conf_flag,s->irq_flag,s->tx_empty);
+        return 0;
+    }
+
+}
+
+static void wk2xxx_work(struct work_struct *w)
+{  
+
+
+    struct wk2xxx_port *s = container_of(w, struct wk2xxx_port, work);
+    uint8_t rx;
+
+        
+
+    int work_start_tx_flag; 
+    int work_stop_rx_flag;
+    int work_irq_flag;
+    int work_conf_flag;
+#ifdef _DEBUG_WK2XXX
+printk( "--wk2xxx_work---in---\n");
+#endif
+    do {
+
+             mutex_lock(&wk2xxs_work_lock);
+     
+             work_start_tx_flag = s->start_tx_flag;
+             if(work_start_tx_flag)
+             s->start_tx_flag = 0;
+     
+             work_stop_rx_flag = s->stop_rx_flag;
+             if(work_stop_rx_flag)
+             s->stop_rx_flag = 0;
+             work_conf_flag = s->conf_flag;
+             if( work_conf_flag)
+                s->conf_flag = 0;
+
+             work_irq_flag = s->irq_flag;
+             if(work_irq_flag)
+             s->irq_flag = 0;
+             mutex_unlock(&wk2xxs_work_lock);
+         
+             if(work_start_tx_flag)
+             {
+              wk2xxx_read_slave_reg(s->spi_wk,s->port.iobase,WK2XXX_SIER,&rx);
+              rx |= WK2XXX_TFTRIG_IEN|WK2XXX_RFTRIG_IEN|WK2XXX_RXOUT_IEN; 
+              wk2xxx_write_slave_reg(s->spi_wk,s->port.iobase,WK2XXX_SIER,rx);
+             }
+     
+             if(work_stop_rx_flag)
+             {
+              wk2xxx_read_slave_reg(s->spi_wk,s->port.iobase,WK2XXX_SIER,&rx);
+              rx &=~WK2XXX_RFTRIG_IEN;
+              rx &=~WK2XXX_RXOUT_IEN;
+              wk2xxx_write_slave_reg(s->spi_wk,s->port.iobase,WK2XXX_SIER,rx);
+             }
+     
+             if(work_irq_flag)
+             {
+                 wk2xxxirq_app(&s->port);
+                 s->irq_fail = 1;
+             }
+
+
+
+        }while (!s->force_end_work && !freezing(current) && \
+        (work_irq_flag || work_stop_rx_flag ));
+
+
+        if(s->start_tx_fail)
+        {
+            wk2xxx_read_slave_reg(s->spi_wk,s->port.iobase,WK2XXX_SIER,&rx);
+            rx |= WK2XXX_TFTRIG_IEN|WK2XXX_RFTRIG_IEN|WK2XXX_RXOUT_IEN;
+            wk2xxx_write_slave_reg(s->spi_wk,s->port.iobase,WK2XXX_SIER,rx);
+        	s->start_tx_fail =0;
+
+        }
+        
+        
+       if(s->stop_rx_fail)
+        {
+            wk2xxx_read_slave_reg(s->spi_wk,s->port.iobase,WK2XXX_SIER,&rx);
+            rx &=~WK2XXX_RFTRIG_IEN;
+            rx &=~WK2XXX_RXOUT_IEN;
+            wk2xxx_write_slave_reg(s->spi_wk,s->port.iobase,WK2XXX_SIER,rx);
+            s->stop_rx_fail =0;
+        }
+        if(s->irq_fail)
+        {
+            s->irq_fail = 0;
+            enable_irq(s->port.irq);
+        }
+
+#ifdef _DEBUG_WK2XXX
+    printk( "--wk2xxx_work---exit---\n");
+#endif
+
+}
+
+
+static void wk2xxx_rx_chars(struct uart_port *port)
+{
+
+
+    struct wk2xxx_port *s = container_of(port,struct wk2xxx_port,port);
+    uint8_t fsr,lsr,dat[1],rx_dat[256]={0};
+    unsigned int ch,flg,sifr, ignored=0,status = 0,rx_count=0;
+    int rfcnt=0,rx_num=0;
+#ifdef _DEBUG_WK2XXX5
+    printk(KERN_ALERT "wk2xxx_rx_chars()---------in---\n");
+#endif
+    wk2xxx_write_slave_reg(s->spi_wk,s->port.iobase,WK2XXX_SPAGE,WK2XXX_PAGE0);//set register in page0
+    wk2xxx_read_slave_reg(s->spi_wk,s->port.iobase,WK2XXX_FSR,dat);
+    fsr = dat[0];
+    wk2xxx_read_slave_reg(s->spi_wk,s->port.iobase,WK2XXX_LSR,dat);
+    lsr = dat[0];
+    wk2xxx_read_slave_reg(s->spi_wk,s->port.iobase,WK2XXX_SIFR,dat);
+    sifr=dat[0];
+#ifdef _DEBUG_WK2XXX
+     printk(KERN_ALERT "rx_chars()-port:%lx--fsr:0x%x--lsr:0x%x--\n",s->port.iobase,fsr,lsr);
+#endif
+if(!(sifr&0x80))//no error
+{  
+
+
+  flg = TTY_NORMAL;
+  if (fsr& WK2XXX_RDAT)
+  {
+    wk2xxx_read_slave_reg(s->spi_wk,s->port.iobase,WK2XXX_RFCNT,dat);
+    rfcnt=dat[0];
+    if(rfcnt==0)
+    {
+     rfcnt=255; 
+    }
+#if 0
+      printk(KERN_ALERT "rx_chars()--port:%ld--RFCNT:0x%x-\n",s->port.iobase,rfcnt);
+#endif
+
+#if 1  
+    wk2xxx_read_fifo(s->spi_wk,s->port.iobase, rfcnt,rx_dat);
+#else
+	  for(rx_num=0;rx_num<rfcnt;rx_num++)
+		 {
+		   wk2xxx_read_slave_reg(s->spi_wk,s->port.iobase,WK2XXX_FDAT,dat);
+		   rx_dat[rx_num]=dat[0];
+		 }
+#endif
+
+    s->port.icount.rx+=rfcnt;
+        for(rx_num=0;rx_num<rfcnt;rx_num++)
+    {
+        if (uart_handle_sysrq_char(&s->port,rx_dat[rx_num]))//.state, ch))
+               break;//
+               
+ #ifdef _DEBUG_WK2XXX5
+
+        printk(KERN_ALERT "rx_chars:0x%x----\n",rx_dat[rx_num]);
+#endif
+                  uart_insert_char(&s->port, status, WK2XXX_STATUS_OE, rx_dat[rx_num], flg);
+                  rx_count++;
+ 
+                  if ((rx_count >= 64 ) && (s->port.state->port.tty->port != NULL))
+                  {
+                   tty_flip_buffer_push(s->port.state->port.tty->port);
+                   rx_count = 0;
+                 }
+
+    }//for
+       if((rx_count > 0)&&(s->port.state->port.tty->port!= NULL))
+  {
+  #ifdef _DEBUG_WK2XXX
+          printk(KERN_ALERT  "push buffer tty flip port = :%lx count =:%d\n",s->port.iobase,rx_count);
+  #endif
+         tty_flip_buffer_push(s->port.state->port.tty->port);
+         rx_count = 0;
+  }
+
+  }
+}//ifm
+else//error
+{
+    while (fsr& WK2XXX_RDAT)/**/
+        {
+            wk2xxx_read_slave_reg(s->spi_wk,s->port.iobase,WK2XXX_FDAT,dat);
+        ch = (int)dat[0];
+
+#ifdef _DEBUG_WK2XXX
+
+        printk(KERN_ALERT "wk2xxx_rx_chars()----port:%lx--RXDAT:0x%x----\n",s->port.iobase,ch);
+#endif
+
+        s->port.icount.rx++;
+        //rx_count++;
+#ifdef _DEBUG_WK2XXX1
+            printk(KERN_ALERT "wk2xxx_rx_chars()----port:%lx error\n",s->port.iobase);
+#endif
+            flg = TTY_NORMAL;
+        if (lsr&(WK2XXX_OE |WK2XXX_FE|WK2XXX_PE|WK2XXX_BI))
+                {
+               printk(KERN_ALERT "wk2xxx_rx_chars()----port:%lx error,lsr:%x!!!!!!!!!!!!!!!!!\n",s->port.iobase,lsr);
+                        //goto handle_error;
+            if (lsr & WK2XXX_PE)
+                {
+                        s->port.icount.parity++;
+                        status |= WK2XXX_STATUS_PE;
+                        flg = TTY_PARITY;
+                }
+                if (lsr & WK2XXX_FE)
+                {
+                        s->port.icount.frame++;
+                        status |= WK2XXX_STATUS_FE;
+                        flg = TTY_FRAME;
+                }
+                if (lsr & WK2XXX_OE)
+                {
+                        s->port.icount.overrun++;
+                        status |= WK2XXX_STATUS_OE;
+                        flg = TTY_OVERRUN;
+                }
+                if(lsr&fsr & WK2XXX_BI)
+                {
+                        s->port.icount.brk++;
+                        status |= WK2XXX_STATUS_BRK;
+                        flg = TTY_BREAK;
+                }
+                
+                if (++ignored > 100) 
+                       goto out;
+                
+                 goto ignore_char;       
+    }
+
+error_return:
+    if (uart_handle_sysrq_char(&s->port,ch))//.state, ch))
+    {
+        goto ignore_char;
+
+	}
+        
+        uart_insert_char(&s->port, status, WK2XXX_STATUS_OE, ch, flg);
+        rx_count++;
+        
+        if ((rx_count >= 64 ) && (s->port.state->port.tty->port != NULL)) 
+        {
+         tty_flip_buffer_push(s->port.state->port.tty->port);
+         rx_count = 0;
+        } 
+#ifdef _DEBUG_WK2XXX1
+                printk(KERN_ALERT  " s->port.icount.rx = 0x%x char = 0x%x flg = 0x%X port = %lx rx_count = %d\n",s->port.icount.rx,ch,flg,s->port.iobase,rx_count);
+#endif
+        ignore_char:
+
+            wk2xxx_read_slave_reg(s->spi_wk,s->port.iobase,WK2XXX_FSR,dat);
+            fsr = dat[0];
+            wk2xxx_read_slave_reg(s->spi_wk,s->port.iobase,WK2XXX_LSR,dat);
+            lsr = dat[0];
+        }
+out:
+	if((rx_count > 0)&&(s->port.state->port.tty->port != NULL))
+{
+#ifdef _DEBUG_WK2XXX1
+        printk(KERN_ALERT  "push buffer tty flip port = :%lx count = :%d\n",s->port.iobase,rx_count);
+#endif
+        tty_flip_buffer_push(s->port.state->port.tty->port);
+        rx_count = 0;
+}
+
+}//if()else
+
+ #if 0
+   printk(KERN_ALERT  " rx_num = :%d\n",s->port.icount.rx);
+ #endif
+
+#ifdef _DEBUG_WK2XXX
+                 printk(KERN_ALERT "wk2xxx_rx_chars()---------out---\n");
+#endif
+
+      	return;
+#ifdef SUPPORT_SYSRQ
+        s->port.state->sysrq = 0;
+#endif
+        goto error_return;
+
+#ifdef _DEBUG_WK2XXX
+    	printk( "--wk2xxx_rx_chars---exit---\n");
+#endif
+
+}
+
+static void wk2xxx_tx_chars(struct uart_port *port)
+{
+
+
+    	struct wk2xxx_port *s = container_of(port,struct wk2xxx_port,port);
+    	uint8_t fsr,tfcnt,dat[1],txbuf[255]={0};
+    	int count,tx_count,i;
+#ifdef _DEBUG_WK2XXX5
+printk( "--wk2xxx_tx_chars---in---\n");
+#endif
+        if (s->port.x_char) 
+        {   
+        #ifdef _DEBUG_WK2XXX
+        printk(KERN_ALERT "wk2xxx_tx_chars   s->port.x_char:%x,port = %lx\n",s->port.x_char,s->port.iobase);
+       #endif
+            wk2xxx_write_slave_reg(s->spi_wk,s->port.iobase,WK2XXX_FDAT,s->port.x_char);
+            s->port.icount.tx++;
+            s->port.x_char = 0;
+            goto out;
+        }
+
+        if(uart_circ_empty(&s->port.state->xmit) || uart_tx_stopped(&s->port))
+        {
+            goto out;
+
+        }
+
+    /*
+     * Tried using FIFO (not checking TNF) for fifo fill:
+     * still had the '1 bytes repeated' problem.
+    */
+    	wk2xxx_read_slave_reg(s->spi_wk,s->port.iobase,WK2XXX_FSR,dat);
+    	fsr = dat[0];
+
+    	wk2xxx_read_slave_reg(s->spi_wk,s->port.iobase,WK2XXX_TFCNT,dat); 
+    	tfcnt= dat[0];
+#ifdef _DEBUG_WK2XXX
+printk(KERN_ALERT "wk2xxx_tx_chars   fsr:0x%x,rfcnt:0x%x,port = %lx\n",fsr,tfcnt,s->port.iobase);
+#endif
+    	if(tfcnt==0)
+    	{
+	     tx_count=(fsr & WK2XXX_TFULL)?0:255;
+		#ifdef _DEBUG_WK2XXX
+        printk(KERN_ALERT "wk2xxx_tx_chars2   tx_count:%x,port = %lx\n",tx_count,s->port.iobase);
+		#endif 
+    	}
+    	else
+    	{
+		tx_count=255-tfcnt;
+		#ifdef _DEBUG_WK2XXX
+        printk(KERN_ALERT "wk2xxx_tx_chars2   tx_count:%x,port = %lx\n",tx_count,s->port.iobase);
+		#endif 
+    	}
+
+#ifdef _DEBUG_WK2XXX
+    printk(KERN_ALERT "fsr:%x\n",fsr);
+#endif
+   
+
+	count = tx_count;
+	i=0;
+	do
+	{
+  		if(uart_circ_empty(&s->port.state->xmit))
+     			break;
+	   	txbuf[i]=s->port.state->xmit.buf[s->port.state->xmit.tail];
+	   	s->port.state->xmit.tail = (s->port.state->xmit.tail + 1) & (UART_XMIT_SIZE - 1);
+	   	s->port.icount.tx++;
+	   	i++;
+#ifdef _DEBUG_WK2XXX
+        printk(KERN_ALERT "tx_chars:0x%x--\n",txbuf[i-1]);
+#endif
+   
+}while(--count>0);
+
+#if 1
+	wk2xxx_write_fifo(s->spi_wk,s->port.iobase,i,txbuf);
+#else
+	for(count=0;count<i;count++)
+	{
+   		wk2xxx_write_slave_reg(s->spi_wk,s->port.iobase,WK2XXX_FDAT,txbuf[count]);	
+	}
+#endif
+
+
+#ifdef _DEBUG_WK2XXX
+printk(KERN_ALERT "icount.tx:%d,xmit.head1:%d,xmit.tail:%d,UART_XMIT_SIZE::%lx,char:%x,fsr:0x%x,port = %lx\n",s->port.icount.tx,s->port.state->xmit.head,s->port.state->xmit.tail,UART_XMIT_SIZE,s->port.state->xmit.buf[s->port.state->xmit.tail],fsr,s->port.iobase);
+#endif
+    	out:wk2xxx_read_slave_reg(s->spi_wk,s->port.iobase,WK2XXX_FSR,dat);
+          fsr = dat[0];
+        if(((fsr&WK2XXX_TDAT)==0)&&((fsr&WK2XXX_TBUSY)==0))
+        {
+           if (uart_circ_chars_pending(&s->port.state->xmit) < WAKEUP_CHARS)
+               uart_write_wakeup(&s->port); 
+
+           if (uart_circ_empty(&s->port.state->xmit))
+            {
+               wk2xxx_stop_tx(&s->port);
+            }
+        }
+#ifdef _DEBUG_WK2XXX
+    	printk( "--wk2xxx_tx_chars---exit---\n");
+#endif
+
+
+}
+
+static irqreturn_t wk2xxx_irq(int irq, void *dev_id)//
+{
+        struct wk2xxx_port *s = dev_id;
+    	disable_irq_nosync(s->port.irq);
+#if 0
+        printk( "--wk2xxx_irq---in---\n");
+#endif       
+        s->irq_flag = 1;
+    	if(wk2xxx_dowork(s))
+    	{
+    	    ;
+    	}
+    	else
+    	{
+        	s->irq_flag = 0;
+        	s->irq_fail = 1;    
+    	}
+    
+#ifdef _DEBUG_WK2XXX
+        printk( "--wk2xxx_irq---exit---\n");
+#endif
+
+    	return IRQ_HANDLED;
+}
+
+static void wk2xxxirq_app(struct uart_port *port)//
+{
+    struct wk2xxx_port *s = container_of(port,struct wk2xxx_port,port);
+    unsigned int  pass_counter = 0;
+    uint8_t sifr,gifr,sier,dat[1];
+#ifdef _DEBUG_WK2XXX
+    printk(KERN_ALERT "wk2xxxirq_app()------port:%lx--------------\n",s->port.iobase);
+#endif		
+#if 0
+    uint8_t gier,sifr0,sifr1,sifr2,sifr3,sier1,sier0,sier2,sier3;
+ #endif                
+    wk2xxx_read_global_reg(s->spi_wk,WK2XXX_GIFR ,dat);
+    gifr = dat[0];
+#if 0
+    wk2xxx_read_global_reg(s->spi_wk,WK2XXX_GIER ,dat);
+    gier = dat[0];
+    wk2xxx_read_slave_reg(s->spi_wk,1,WK2XXX_SIFR,&sifr0);
+    wk2xxx_read_slave_reg(s->spi_wk,2,WK2XXX_SIFR,&sifr1);
+    wk2xxx_read_slave_reg(s->spi_wk,3,WK2XXX_SIFR,&sifr2);
+    wk2xxx_read_slave_reg(s->spi_wk,4,WK2XXX_SIFR,&sifr3);
+    wk2xxx_read_slave_reg(s->spi_wk,1,WK2XXX_SIER,&sier0);
+    wk2xxx_read_slave_reg(s->spi_wk,2,WK2XXX_SIER,&sier1);
+    wk2xxx_read_slave_reg(s->spi_wk,3,WK2XXX_SIER,&sier2);
+    wk2xxx_read_slave_reg(s->spi_wk,4,WK2XXX_SIER,&sier3);
+    printk(KERN_ALERT "irq_app....gifr:%x  gier:%x  sier1:%x  sier2:%x sier3:%x sier4:%x   sifr1:%x sifr2:%x sifr3:%x sifr4:%x \n",gifr,gier,sier0,sier1,sier2,sier3,sifr0,sifr1,sifr2,sifr3);
+#endif      
+        
+                
+
+        switch(s->port.iobase)
+        {
+                case 1 :
+                    if(!(gifr & WK2XXX_UT1INT))
+                    {
+                        return;
+                    }
+                    break;
+                case 2 :
+                    if(!(gifr & WK2XXX_UT2INT))
+                    {            
+                        return;
+                    }                                     
+                    break;
+                case 3 :
+                    if(!(gifr & WK2XXX_UT3INT))
+                    {            
+                        return;
+                    }
+                    break;
+                case 4 :
+                    if(!(gifr & WK2XXX_UT4INT))
+                    {               
+                        return;
+                    }
+                    break;
+                    default:
+                    break;
+                                
+        }
+        
+        wk2xxx_read_slave_reg(s->spi_wk,s->port.iobase,WK2XXX_SIFR,dat);
+        sifr = dat[0];
+        wk2xxx_read_slave_reg(s->spi_wk,s->port.iobase,WK2XXX_SIER,dat);
+        sier = dat[0];
+#ifdef _DEBUG_WK2XXX1
+        printk(KERN_ALERT "irq_app..........sifr:%x sier:%x \n",sifr,sier);
+#endif
+        do {
+                if ((sifr&WK2XXX_RFTRIG_INT)||(sifr&WK2XXX_RXOVT_INT))
+                {
+                    wk2xxx_rx_chars(&s->port);
+                }
+        
+                if ((sifr & WK2XXX_TFTRIG_INT)&&(sier & WK2XXX_TFTRIG_IEN ))
+                {
+                    wk2xxx_tx_chars(&s->port);
+                    return;
+                }
+                if (pass_counter++ > WK2XXX_ISR_PASS_LIMIT)
+                    break;
+                wk2xxx_read_slave_reg(s->spi_wk,s->port.iobase,WK2XXX_SIFR,dat);
+                sifr = dat[0];
+                wk2xxx_read_slave_reg(s->spi_wk,s->port.iobase,WK2XXX_SIER,dat);
+                sier = dat[0];
+#ifdef _DEBUG_WK2XXX1
+    printk(KERN_ALERT "irq_app...........rx............tx  sifr:%x sier:%x port:%lx\n",sifr,sier,s->port.iobase);
+#endif
+	} while ((sifr&WK2XXX_RXOVT_INT)||(sifr & WK2XXX_RFTRIG_INT)||((sifr & WK2XXX_TFTRIG_INT)&&(sier & WK2XXX_TFTRIG_IEN)));
+#ifdef _DEBUG_WK2XXX
+    printk(KERN_ALERT "wk2xxxirq_app()---------exit---\n");
+#endif
+        
+}
+
+
+/*
+ *   Return TIOCSER_TEMT when transmitter is not busy.
+ */
+
+static u_int wk2xxx_tx_empty(struct uart_port *port)// or query the tx fifo is not empty?
+{
+    uint8_t tx;
+    struct wk2xxx_port *s = container_of(port,struct wk2xxx_port,port);
+#ifdef _DEBUG_WK2XXX
+    printk(KERN_ALERT "wk2xxx_tx_empty()---------in---\n");
+#endif
+	mutex_lock(&wk2xxxs_lock);
+	if(!(s->tx_empty_flag || s->tx_empty_fail))
+	{
+	    wk2xxx_read_slave_reg(s->spi_wk,s->port.iobase,WK2XXX_FSR,&tx);
+	    while((tx & WK2XXX_TDAT)|(tx&WK2XXX_TBUSY))
+	   	{
+	   		wk2xxx_read_slave_reg(s->spi_wk,s->port.iobase,WK2XXX_FSR,&tx);
+	   	}
+    	s->tx_empty = ((tx & WK2XXX_TDAT)|(tx&WK2XXX_TBUSY))<=0;
+		if(s->tx_empty)
+		{
+		    s->tx_empty_flag =0;
+		    s->tx_empty_fail=0;
+		}
+		else
+		{
+		    s->tx_empty_fail=0;
+		    s->tx_empty_flag =0;
+		}
+	}
+	mutex_unlock(&wk2xxxs_lock);
+
+#ifdef _DEBUG_WK2XXX5
+       printk(KERN_ALERT "s->tx_empty_fail----FSR:%d--s->tx_empty:%d--\n",rx,s->tx_empty);
+#endif
+      
+#ifdef _DEBUG_WK2XXX
+        printk(KERN_ALERT "wk2xxx_tx_empty----------exit---\n");
+#endif
+    	return s->tx_empty;
+
+
+}
+
+static void wk2xxx_set_mctrl(struct uart_port *port, u_int mctrl)//nothing
+{
+#ifdef _DEBUG_WK2XXX
+    printk(KERN_ALERT "%s!!\n", __func__);
+#endif
+}
+static u_int wk2xxx_get_mctrl(struct uart_port *port)// since no modem control line
+{       
+#ifdef _DEBUG_WK2XXX
+	printk(KERN_ALERT "%s!!\n", __func__);
+#endif
+        return TIOCM_CTS | TIOCM_DSR | TIOCM_CAR;
+}
+
+
+/*
+ *  interrupts disabled on entry
+ */
+
+static void wk2xxx_stop_tx(struct uart_port *port)//
+{
+
+    uint8_t dat[1],sier,sifr;
+	struct wk2xxx_port *s = container_of(port,struct wk2xxx_port,port);
+#ifdef _DEBUG_WK2XXX
+printk(KERN_ALERT "-wk2xxx_stop_tx------in---\n");
+#endif 
+    mutex_lock(&wk2xxxs_lock);
+	if(!(s->stop_tx_flag||s->stop_tx_fail))
+    {
+	    wk2xxx_read_slave_reg(s->spi_wk,s->port.iobase,WK2XXX_SIER,dat);
+		sier=dat[0];
+		s->stop_tx_fail=(sier&WK2XXX_TFTRIG_IEN)>0;
+		if(s->stop_tx_fail)
+        {
+            wk2xxx_read_slave_reg(s->spi_wk,s->port.iobase,WK2XXX_SIER,dat);
+            sier=dat[0];
+            sier&=~WK2XXX_TFTRIG_IEN;
+            wk2xxx_write_slave_reg(s->spi_wk,s->port.iobase,WK2XXX_SIER,sier);
+
+			
+            wk2xxx_read_slave_reg(s->spi_wk,s->port.iobase,WK2XXX_SIFR,dat);
+            sifr=dat[0];
+            sifr&= ~WK2XXX_TFTRIG_INT;
+            wk2xxx_write_slave_reg(s->spi_wk,s->port.iobase,WK2XXX_SIFR,sifr);
+            s->stop_tx_fail =0;
+            s->stop_tx_flag=0;
+         }
+    	else
+    	{
+            s->stop_tx_fail =0;
+            s->stop_tx_flag=0;
+		}
+        }
+	mutex_unlock(&wk2xxxs_lock); 
+#ifdef _DEBUG_WK2XXX4
+    printk(KERN_ALERT "-wk2xxx_stop_tx------exit---\n");
+#endif
+        
+}
+
+/*
+ *  * interrupts may not be disabled on entry
+*/
+static void wk2xxx_start_tx(struct uart_port *port)
+{
+    
+		struct wk2xxx_port *s = container_of(port,struct wk2xxx_port,port);
+#ifdef _DEBUG_WK2XXX
+printk(KERN_ALERT "-wk2xxx_start_tx------in---\n");
+#endif
+        if(!(s->start_tx_flag||s->start_tx_fail))
+        {    
+				s->start_tx_flag = 1;
+            	if(wk2xxx_dowork(s))
+            	{
+                    ;
+            	}
+            	else
+            	{
+                    s->start_tx_fail = 1;
+					s->start_tx_flag = 0;
+            	}
+         }
+
+#ifdef _DEBUG_WK2XXX
+printk(KERN_ALERT "-wk2xxx_start_tx------exit---\n");
+#endif
+
+
+
+}
+
+/*
+ *  * Interrupts enabled
+*/
+
+static void wk2xxx_stop_rx(struct uart_port *port)
+{
+        struct wk2xxx_port *s = container_of(port,struct wk2xxx_port,port);
+#ifdef _DEBUG_WK2XXX
+printk(KERN_ALERT "-wk2xxx_stop_rx------in---\n");
+#endif
+       	if(!(s->stop_rx_flag ||s->stop_rx_fail ))
+        {
+				s->stop_rx_flag = 1;
+            	if(wk2xxx_dowork(s))
+            	{
+                	;
+            	}
+            	else
+            	{
+                	s->stop_rx_flag = 0;
+                	s->stop_rx_fail = 1;
+            	}
+         }
+
+
+#ifdef _DEBUG_WK2XXX
+    printk(KERN_ALERT "-wk2xxx_stop_rx------exit---\n");
+#endif
+
+
+}
+
+
+/*
+ *  * No modem control lines
+ *   */
+static void wk2xxx_enable_ms(struct uart_port *port)    //nothing
+{
+#ifdef _DEBUG_WK2XXX
+			printk(KERN_ALERT "%s!!\n", __func__);
+#endif
+
+
+}
+/*
+ *  * Interrupts always disabled.
+*/   
+static void wk2xxx_break_ctl(struct uart_port *port, int break_state)
+{
+#ifdef _DEBUG_WK2XXX
+	printk(KERN_ALERT "%s!!\n", __func__);
+#endif
+}
+
+
+static int wk2xxx_startup(struct uart_port *port)//i
+{
+
+        uint8_t gena,grst,gier,sier,scr,dat[1];
+        struct wk2xxx_port *s = container_of(port,struct wk2xxx_port,port);
+        char b[12];
+#ifdef _DEBUG_WK2XXX5
+		printk(KERN_ALERT "-wk2xxx_startup------in---\n");
+#endif
+        if (s->suspending)
+            return 0;
+        
+        s->force_end_work = 0;
+        sprintf(b, "wk2xxx-%d", (uint8_t)s->port.iobase);
+		s->workqueue = create_workqueue(b);
+	    
+        if (!s->workqueue) 
+        {
+            dev_warn(&s->spi_wk->dev, "cannot create workqueue\n");
+            return -EBUSY;
+        }
+        
+        INIT_WORK(&s->work, wk2xxx_work);
+        
+        if (s->wk2xxx_hw_suspend)
+        	s->wk2xxx_hw_suspend(0);
+          
+        wk2xxx_read_global_reg(s->spi_wk,WK2XXX_GENA,dat);
+        gena=dat[0];
+        switch (s->port.iobase)
+        {
+          case 1:
+                  gena|=WK2XXX_UT1EN;
+                  wk2xxx_write_global_reg(s->spi_wk,WK2XXX_GENA,gena);
+                  break;
+          case 2:
+                  gena|=WK2XXX_UT2EN;
+                  wk2xxx_write_global_reg(s->spi_wk,WK2XXX_GENA,gena);
+                  break;
+          case 3:
+                 gena|=WK2XXX_UT3EN;
+                 wk2xxx_write_global_reg(s->spi_wk,WK2XXX_GENA,gena);
+                  break;
+          case 4:
+                  gena|=WK2XXX_UT4EN;
+                  wk2xxx_write_global_reg(s->spi_wk,WK2XXX_GENA,gena);
+                  break;
+          default:
+		          printk(KERN_ALERT ":con_wk2xxx_subport bad iobase %d\n", (uint8_t)s->port.iobase);
+                  break;
+        }
+ 
+        wk2xxx_read_global_reg(s->spi_wk,WK2XXX_GRST,dat);
+        grst=dat[0];
+        switch (s->port.iobase)
+        {
+             case 1:
+                    grst|=WK2XXX_UT1RST;
+                    wk2xxx_write_global_reg(s->spi_wk,WK2XXX_GRST,grst);
+                    break;
+             case 2:
+                    grst|=WK2XXX_UT2RST;
+                    wk2xxx_write_global_reg(s->spi_wk,WK2XXX_GRST,grst);
+                    break;
+             case 3:
+                   grst|=WK2XXX_UT3RST;
+                   wk2xxx_write_global_reg(s->spi_wk,WK2XXX_GRST,grst);
+                    break;
+             case 4:
+                    grst|=WK2XXX_UT4RST;
+                    wk2xxx_write_global_reg(s->spi_wk,WK2XXX_GRST,grst);
+                    break;
+            default:
+     printk(KERN_ALERT ":con_wk2xxx_subport bad iobase %d\n", (uint8_t)s->port.iobase);
+                    break;
+        }
+        
+        wk2xxx_read_slave_reg(s->spi_wk,s->port.iobase,WK2XXX_SIER,dat);
+        sier = dat[0];
+        sier &= ~WK2XXX_TFTRIG_IEN;
+        sier |= WK2XXX_RFTRIG_IEN;
+        sier |= WK2XXX_RXOUT_IEN;
+        wk2xxx_write_slave_reg(s->spi_wk,s->port.iobase,WK2XXX_SIER,sier);
+
+        wk2xxx_read_slave_reg(s->spi_wk,s->port.iobase,WK2XXX_SCR,dat);
+        scr = dat[0] | WK2XXX_TXEN|WK2XXX_RXEN;
+        wk2xxx_write_slave_reg(s->spi_wk,s->port.iobase,WK2XXX_SCR,scr);
+
+    //initiate the fifos
+        wk2xxx_write_slave_reg(s->spi_wk,s->port.iobase,WK2XXX_FCR,0xff);//initiate the fifos
+        wk2xxx_write_slave_reg(s->spi_wk,s->port.iobase,WK2XXX_FCR,0xfc);
+    //set rx/tx interrupt 
+        wk2xxx_write_slave_reg(s->spi_wk,s->port.iobase,WK2XXX_SPAGE,1);  
+        wk2xxx_write_slave_reg(s->spi_wk,s->port.iobase,WK2XXX_RFTL,0x40);
+        wk2xxx_write_slave_reg(s->spi_wk,s->port.iobase,WK2XXX_TFTL,0X20);
+        wk2xxx_write_slave_reg(s->spi_wk,s->port.iobase,WK2XXX_SPAGE,0);  
+    //enable the sub port interrupt
+        wk2xxx_read_global_reg(s->spi_wk,WK2XXX_GIER,dat);
+        gier = dat[0];
+        
+        switch (s->port.iobase)
+	{
+          case 1:
+                gier|=WK2XXX_UT1IE;
+                wk2xxx_write_global_reg(s->spi_wk,WK2XXX_GIER,gier);
+                break;
+          case 2:
+                gier|=WK2XXX_UT2IE;
+                wk2xxx_write_global_reg(s->spi_wk,WK2XXX_GIER,gier);
+                break;
+          case 3:
+                gier|=WK2XXX_UT3IE;
+                wk2xxx_write_global_reg(s->spi_wk,WK2XXX_GIER,gier);
+                break;
+          case 4:
+                gier|=WK2XXX_UT4IE;
+                wk2xxx_write_global_reg(s->spi_wk,WK2XXX_GIER,gier);
+                break;
+        default:
+                printk(KERN_ALERT ": bad iobase %d\n", (uint8_t)s->port.iobase);
+                break;
+        }
+
+        if (s->wk2xxx_hw_suspend)
+            s->wk2xxx_hw_suspend(0);
+        msleep(50);
+
+
+        uart_circ_clear(&s->port.state->xmit);
+        wk2xxx_enable_ms(&s->port);
+
+      // request irq
+        if(request_irq(s->port.irq, wk2xxx_irq,IRQF_SHARED|IRQF_TRIGGER_LOW, "wk2xxx_irq_gpio", s) < 0)
+        {
+                dev_warn(&s->spi_wk->dev, "cannot allocate irq %d\n", s->irq);
+                s->port.irq = 0;
+                destroy_workqueue(s->workqueue);
+                s->workqueue = NULL;
+                return -EBUSY;
+        }       udelay(100);
+        udelay(100);
+#ifdef _DEBUG_WK2XXX5
+        printk(KERN_ALERT "-wk2xxx_startup------exit---\n");
+#endif
+
+       return 0;
+}
+//* Power down all displays on reboot, poweroff or halt *
+
+static void wk2xxx_shutdown(struct uart_port *port)
+{
+
+    uint8_t gena,dat[1];
+    struct wk2xxx_port *s = container_of(port,struct wk2xxx_port,port);
+#ifdef _DEBUG_WK2XXX
+    printk(KERN_ALERT "-wk2xxx_shutdown------in---\n");
+#endif
+    	if (s->suspending)
+       		return;
+       	s->force_end_work = 1;
+    	if (s->workqueue) 
+    	{
+    	    flush_workqueue(s->workqueue);
+			destroy_workqueue(s->workqueue);
+			s->workqueue = NULL;
+    	}
+    
+    	if (s->port.irq)
+    	{    
+          free_irq(s->port.irq, s);//释放中断
+    	}
+     
+     	wk2xxx_read_global_reg(s->spi_wk,WK2XXX_GENA,dat);
+        gena=dat[0];
+        switch (s->port.iobase)
+    	{
+        	case 1:
+                gena&=~WK2XXX_UT1EN;
+                wk2xxx_write_global_reg(s->spi_wk,WK2XXX_GENA,gena);
+                break;
+          case 2:
+                 gena&=~WK2XXX_UT2EN;
+                 wk2xxx_write_global_reg(s->spi_wk,WK2XXX_GENA,gena);
+                 break;
+          case 3:
+                 gena&=~WK2XXX_UT3EN;
+                 wk2xxx_write_global_reg(s->spi_wk,WK2XXX_GENA,gena);
+                 break;
+          case 4:
+                 gena&=~WK2XXX_UT4EN;
+                  wk2xxx_write_global_reg(s->spi_wk,WK2XXX_GENA,gena);
+                  break;
+          default:
+                  printk(KERN_ALERT ":con_wk2xxx_subport bad iobase %d\n", (uint8_t)s->port.iobase);
+                  break;
+          } 
+
+#ifdef _DEBUG_WK2XXX
+        printk(KERN_ALERT "-wk2xxx_shutdown-----exit---\n");
+#endif
+
+        return ;
+}
+
+static void conf_wk2xxx_subport(struct uart_port *port)//i
+{   
+
+
+	struct wk2xxx_port *s = container_of(port,struct wk2xxx_port,port);
+	uint8_t old_sier,fwcr,lcr,scr,scr_ss,dat[1],baud0_ss,baud1_ss,pres_ss;
+#ifdef _DEBUG_WK2XXX
+    printk(KERN_ALERT "-conf_wk2xxx_subport------in---\n");
+#endif
+	lcr = s->new_lcr;
+	scr_ss = s->new_scr;
+	baud0_ss=s->new_baud0;
+	baud1_ss=s->new_baud1;
+	pres_ss=s->new_pres;
+	fwcr=s->new_fwcr;
+	wk2xxx_read_slave_reg(s->spi_wk,s->port.iobase,WK2XXX_SIER ,dat);
+	old_sier = dat[0];
+	wk2xxx_write_slave_reg(s->spi_wk,s->port.iobase,WK2XXX_SIER ,old_sier&(~(WK2XXX_TFTRIG_IEN | WK2XXX_RFTRIG_IEN | WK2XXX_RXOUT_IEN)));
+    //local_irq_restore(flags);
+	do{
+       	wk2xxx_read_slave_reg(s->spi_wk,s->port.iobase,WK2XXX_FSR,dat);
+	  } while (dat[0] & WK2XXX_TBUSY);
+        // then, disable tx and rx
+        wk2xxx_read_slave_reg(s->spi_wk,s->port.iobase,WK2XXX_SCR,dat);
+        scr = dat[0];
+        wk2xxx_write_slave_reg(s->spi_wk,s->port.iobase,WK2XXX_SCR ,scr&(~(WK2XXX_RXEN|WK2XXX_TXEN)));
+        // set the parity, stop bits and data size //
+        wk2xxx_write_slave_reg(s->spi_wk,s->port.iobase,WK2XXX_LCR ,lcr);
+		/*set cts  and rst*/
+		if(fwcr>0){  
+#ifdef _DEBUG_WK2XXX
+        printk(KERN_ALERT "-conf_wk2xxx_subport-set ctsrts--fwcr=0x%X\n",fwcr);
+#endif
+				wk2xxx_write_slave_reg(s->spi_wk,s->port.iobase,WK2XXX_FWCR,fwcr);
+				wk2xxx_write_slave_reg(s->spi_wk,s->port.iobase,WK2XXX_SPAGE ,1);
+				wk2xxx_write_slave_reg(s->spi_wk,s->port.iobase,WK2XXX_FWTH,0XF0);
+				wk2xxx_write_slave_reg(s->spi_wk,s->port.iobase,WK2XXX_FWTL,0X80);
+				wk2xxx_write_slave_reg(s->spi_wk,s->port.iobase,WK2XXX_SPAGE ,0);
+		}
+    
+        wk2xxx_write_slave_reg(s->spi_wk,s->port.iobase,WK2XXX_SIER ,old_sier);
+        // set the baud rate //
+        wk2xxx_write_slave_reg(s->spi_wk,s->port.iobase,WK2XXX_SPAGE ,1);
+        wk2xxx_write_slave_reg(s->spi_wk,s->port.iobase,WK2XXX_BAUD0 ,baud0_ss);
+        wk2xxx_write_slave_reg(s->spi_wk,s->port.iobase,WK2XXX_BAUD1 ,baud1_ss);
+        wk2xxx_write_slave_reg(s->spi_wk,s->port.iobase,WK2XXX_PRES ,pres_ss);
+#ifdef _DEBUG_WK2XXX2
+         wk2xxx_read_slave_reg(s->spi_wk,s->port.iobase,WK2XXX_BAUD0,dat);
+         printk(KERN_ALERT ":WK2XXX_BAUD0=0x%X\n", dat[0]);
+         wk2xxx_read_slave_reg(s->spi_wk,s->port.iobase,WK2XXX_BAUD1,dat);
+         printk(KERN_ALERT ":WK2XXX_BAUD1=0x%X\n", dat[0]);
+         wk2xxx_read_slave_reg(s->spi_wk,s->port.iobase,WK2XXX_PRES,dat);
+         printk(KERN_ALERT ":WK2XXX_PRES=0x%X\n", dat[0]);
+#endif
+         wk2xxx_write_slave_reg(s->spi_wk,s->port.iobase,WK2XXX_SPAGE ,0);
+         wk2xxx_write_slave_reg(s->spi_wk,s->port.iobase,WK2XXX_SCR ,scr|(WK2XXX_RXEN|WK2XXX_TXEN));
+
+
+#ifdef _DEBUG_WK2XXX
+        printk(KERN_ALERT "-conf_wk2xxx_subport------exit---\n");
+#endif
+
+}
+
+
+// change speed
+static void wk2xxx_termios( struct uart_port *port, struct ktermios *termios,
+            struct ktermios *old)
+{
+
+	struct wk2xxx_port *s = container_of(port,struct wk2xxx_port,port);
+	int baud = 0;
+	uint8_t lcr=0,fwcr,baud1,baud0,pres;
+	unsigned short cflag;
+	unsigned short lflag;
+#ifdef _DEBUG_WK2XXX
+printk(KERN_ALERT "-wk32xx_termios------in---\n");
+#endif
+	
+	cflag = termios->c_cflag;
+	lflag = termios->c_lflag;
+#ifdef _DEBUG_WK2XXX1
+    printk(KERN_ALERT "cflag := 0x%X  lflag : = 0x%X\n",cflag,lflag);
+#endif
+	baud1=0;
+	baud0=0;
+	pres=0;
+	baud = tty_termios_baud_rate(termios);
+
+	switch (baud) {
+		case 600:
+			baud1=0x4;
+			baud0=0x7f;
+			pres=0;
+			break;
+		case 1200:
+			baud1=0x2;
+			baud0=0x3F;
+			pres=0;
+			break;
+		case 2400:
+			baud1=0x1;
+			baud0=0x1f;
+			pres=0;
+			break;
+		case 4800:
+			baud1=0x00;
+			baud0=0x8f;
+			pres=0;
+			break;
+		case 9600:
+			baud1=0x00;
+			baud0=0x47;
+			pres=0;
+			break;
+		case 19200:
+			baud1=0x00;
+			baud0=0x23;
+			pres=0;
+			break;
+		case 38400:
+			baud1=0x00;
+			baud0=0x11;
+			pres=0;
+			break;
+		case 76800:
+			baud1=0x00;
+			baud0=0x08;
+			pres=0;
+			break;  
+		case 1800:
+			baud1=0x01;
+			baud0=0x7f;
+			pres=0;
+			break;
+		case 3600:
+			baud1=0x00;
+			baud0=0xbf;
+			pres=0;
+			break;
+		case 7200:
+			baud1=0x00;
+			baud0=0x5f;
+			pres=0;
+			break;
+		case 14400:
+			baud1=0x00;
+			baud0=0x2f;
+			pres=0;
+			break;
+		case 28800:
+			baud1=0x00;
+			baud0=0x17;
+			pres=0;
+			break;
+		case 57600:
+			baud1=0x00;
+			baud0=0x0b;
+			pres=0;
+			break;
+		case 115200:
+			baud1=0x00;
+			baud0=0x05;
+			pres=0;
+			break;
+		case 230400:
+			baud1=0x00;
+			baud0=0x02;
+			pres=0;
+			break;
+		default:  
+			baud1=0x00;
+			baud0=0x00;
+			pres=0;
+			break;
+	}
+	tty_termios_encode_baud_rate(termios, baud, baud);
+
+	/* we are sending char from a workqueue so enable */
+
+
+#ifdef _DEBUG_WK2XXX
+            printk(KERN_ALERT "wk2xxx_termios()----port:%lx--lcr:0x%x- cflag:0x%x-CSTOPB:0x%x,PARENB:0x%x,PARODD:0x%x--\n",s->port.iobase,lcr,cflag,CSTOPB,PARENB,PARODD);
+#endif
+
+        lcr =0;
+        if (cflag & CSTOPB)
+                lcr|=WK2XXX_STPL;//two  stop_bits
+        else
+                lcr&=~WK2XXX_STPL;//one  stop_bits
+
+        if (cflag & PARENB) {
+                lcr|=WK2XXX_PAEN;//enbale spa
+                if (!(cflag & PARODD)){
+                        lcr |= WK2XXX_PAM1;
+                        lcr &= ~WK2XXX_PAM0;
+                }
+                else{
+                        lcr |= WK2XXX_PAM0;//PAM0=1
+                        lcr &= ~WK2XXX_PAM1;//PAM1=0
+                }
+        }
+        else{
+                lcr&=~WK2XXX_PAEN;
+        }
+
+		/*set rts and cts*/
+		fwcr=(termios->c_cflag&CRTSCTS)?0X30:0;
+		
+
+#ifdef _DEBUG_WK2XXX
+       printk(KERN_ALERT "wk2xxx_termios()----port:%lx--lcr:0x%x- cflag:0x%x-CSTOPB:0x%x,PARENB:0x%x,PARODD:0x%x--\n",s->port.iobase,lcr,cflag,CSTOPB,PARENB,PARODD);
+#endif
+
+	s->new_baud1=baud1;
+	s->new_baud0=baud0;	
+	s->new_pres=pres;
+	s->new_lcr = lcr;
+	s->new_fwcr = fwcr;
+
+#ifdef _DEBUG_WK2XXX
+       printk(KERN_ALERT "wk2xxx_termios()----port:%lx--NEW_FWCR-\n",s->port.iobase,s->new_fwcr);
+#endif
+
+
+	conf_wk2xxx_subport(&s->port);  
+
+#ifdef _DEBUG_WK2XXX
+      printk(KERN_ALERT "-wk2xxx_termios------exit---\n");
+#endif
+}
+
+
+static const char *wk2xxx_type(struct uart_port *port)
+{
+
+
+#ifdef _DEBUG_WK2XXX
+        printk(KERN_ALERT "%s!!\n", __func__);
+#endif
+        return port->type == PORT_WK2XXX ? "wk2xxx" : NULL;//this is defined in serial_core.h
+}
+
+
+static void wk2xxx_release_port(struct uart_port *port)
+{
+  #ifdef _DEBUG_WK2XXX
+       printk(KERN_ALERT "%s!!\n", __func__);
+  #endif
+
+}
+
+
+static int wk2xxx_request_port(struct uart_port *port)//no such memory region needed for wk2xxx
+{
+#ifdef _DEBUG_WK2XXX
+	printk(KERN_ALERT "%s!!\n", __func__);
+#endif
+    return 0;
+}
+
+
+static void wk2xxx_config_port(struct uart_port *port, int flags)
+{
+        struct wk2xxx_port *s = container_of(port,struct wk2xxx_port,port);
+
+#ifdef _DEBUG_WK2XXX
+        printk(KERN_ALERT "%s!!\n", __func__);
+#endif
+
+        if (flags & UART_CONFIG_TYPE && wk2xxx_request_port(port) == 0)
+               s->port.type = PORT_WK2XXX;
+}
+
+
+static int wk2xxx_verify_port(struct uart_port *port, struct serial_struct *ser)
+{
+
+        int ret = 0;
+#ifdef _DEBUG_WK2XXX
+				printk(KERN_ALERT "%s!!\n", __func__);
+#endif
+
+        if (ser->type != PORT_UNKNOWN && ser->type != PORT_WK2XXX)
+                ret = -EINVAL;
+        if (port->irq != ser->irq)
+                ret = -EINVAL;
+        if (ser->io_type != SERIAL_IO_PORT)
+                ret = -EINVAL;
+        //if (port->uartclk / 16 != ser->baud_base)
+        //      ret = -EINVAL;
+        if (port->iobase != ser->port)
+                ret = -EINVAL;
+        if (ser->hub6 != 0)
+                ret = -EINVAL;
+        return ret;
+}
+
+
+
+
+static struct uart_ops wk2xxx_pops = {
+        tx_empty:       wk2xxx_tx_empty,
+        set_mctrl:      wk2xxx_set_mctrl,
+        get_mctrl:      wk2xxx_get_mctrl,
+        stop_tx:        wk2xxx_stop_tx,
+        start_tx:       wk2xxx_start_tx,
+        stop_rx:        wk2xxx_stop_rx,
+        enable_ms:      wk2xxx_enable_ms,
+        break_ctl:      wk2xxx_break_ctl,
+        startup:        wk2xxx_startup,
+        shutdown:       wk2xxx_shutdown,
+        set_termios:    wk2xxx_termios,
+        type:           wk2xxx_type,
+        release_port:   wk2xxx_release_port,
+        request_port:   wk2xxx_request_port,
+        config_port:    wk2xxx_config_port,
+        verify_port:    wk2xxx_verify_port,
+
+};
+static struct uart_driver wk2xxx_uart_driver = {
+
+
+        owner:                  THIS_MODULE,
+        major:               SERIAL_WK2XXX_MAJOR,
+#ifdef CONFIG_DEVFS_FS
+        driver_name:            "ttySWK",
+        dev_name:               "ttysWK",
+#else
+        driver_name:            "ttySWK",
+        dev_name:               "ttysWK",
+#endif
+        minor:                  MINOR_START,
+        nr:                     NR_PORTS,
+        cons:                   NULL
+};
+
+static int uart_driver_registered;
+static struct spi_driver wk2xxx_driver;
+
+/*
+ *解析设备\E6\A0?
+ */
+//#ifdef CONFIG_OF
+static int rockchip_spi_parse_dt(struct device *dev)
+{
+
+	int irq_gpio, irq_flags, irq; 
+#ifdef _DEBUG_WK2XXX
+    printk(KERN_ERR "-rockchip_spi_parse_dt()------in---\n");
+#endif
+	//从设备树获取IRQ——GPIO
+	irq_gpio = of_get_named_gpio_flags(dev->of_node, "irq_gpio", 0,(enum of_gpio_flags *)&irq_flags);
+    	if (!gpio_is_valid(irq_gpio))
+    	{
+			printk(KERN_ERR"invalid wk2xxx_irq_gpio: %d\n", irq_gpio);
+			return -1;
+    	}
+   
+    	irq = gpio_to_irq(irq_gpio);
+    	if(!irq)
+    	{
+		printk(KERN_ERR"wk2xxx_irqGPIO: %d get irq failed!\n", irq);
+		//gpio_free(s->irq_gpio);
+		return -1;
+    	}
+	printk(KERN_ERR"wk2xxx_irq_gpio: %d, irq: %d", irq_gpio, irq);
+
+	#ifdef _DEBUG_WK2XXX
+	printk(KERN_ERR"-rockchip_spi_parse_dt()------out---\n");
+	#endif
+	return irq;
+}
+
+
+
+static int wk2xxx_probe(struct spi_device *spi)
+{
+    	uint8_t i;
+    	int status, irq;
+    	uint8_t dat[1];
+//////////////////test spi////////////////////////
+
+	do
+	{
+		wk2xxx_read_global_reg(spi,WK2XXX_GENA,dat);
+		printk(KERN_ERR "wk2xxx_probe()  GENA = 0x%X\n",dat[0]);
+		wk2xxx_write_global_reg(spi,WK2XXX_GENA,0xf5);
+		wk2xxx_read_global_reg(spi,WK2XXX_GENA,dat);
+		printk(KERN_ERR "wk2xxx_probe()  GENA = 0x%X\n",dat[0]);
+		wk2xxx_write_global_reg(spi,WK2XXX_GENA,0xf0);
+		wk2xxx_read_global_reg(spi,WK2XXX_GENA,dat);
+		printk(KERN_ERR "wk2xxx_probe()  GENA = 0x%X\n",dat[0]);
+	}while(0);
+/////////////////////test spi //////////////////////////	
+
+printk( KERN_ERR"-wk2xxx_probe()------in---\n");	
+	irq = rockchip_spi_parse_dt(&spi->dev);
+	if(irq<0)
+	{
+		return 1;
+	}
+
+    	wk2xxx_read_global_reg(spi,WK2XXX_GENA,dat);
+    	if((dat[0]&0xf0)!=0x30)
+        { 
+          printk(KERN_ALERT "wk2xxx_probe()  GENA = 0x%X\n",dat[0]);
+          printk(KERN_ERR "spi driver  error!!!!\n");
+          return 1;
+        }
+    	mutex_lock(&wk2xxxs_lock);
+    	if(!uart_driver_registered)
+    	{
+        	    uart_driver_registered = 1;
+        	    status = uart_register_driver(&wk2xxx_uart_driver);
+        	if (status)
+        	{
+             	printk(KERN_ERR "Couldn't register wk2xxx uart driver\n");
+            	mutex_unlock(&wk2xxxs_lock);
+            	return status;
+        	}
+    	}
+          printk(KERN_ALERT "wk2xxx_serial_init.\n");
+
+    	for(i =0;i<NR_PORTS;i++)
+    	{
+        	    struct wk2xxx_port *s = &wk2xxxs[i];//container_of(port,struct wk2xxx_port,port);
+        	    s->tx_done       =0;
+        	    s->spi_wk        = spi;
+			    s->port.line     = i;
+				s->port.ops      = &wk2xxx_pops;
+				s->port.uartclk  = WK_CRASTAL_CLK;
+				s->port.fifosize = 256;
+				s->port.iobase   = i+1;
+				s->port.irq      = irq;
+				s->port.iotype   = SERIAL_IO_PORT;
+				s->port.flags    = ASYNC_BOOT_AUTOCONF;
+		        status = uart_add_one_port(&wk2xxx_uart_driver, &s->port);
+       		if(status<0)
+          	{
+                  printk(KERN_ALERT "uart_add_one_port failed for line i:= %d with error %d\n",i,status);
+		          mutex_unlock(&wk2xxxs_lock);
+		          return status;
+           	}
+    	}
+        printk(KERN_ALERT "uart_add_one_port status= 0x%d\n",status);
+    	mutex_unlock(&wk2xxxs_lock);
+
+    	return status;
+}
+
+
+static int wk2xxx_remove(struct spi_device *spi)
+{
+
+    	int i;
+#ifdef _DEBUG_WK2XXX
+    	printk( KERN_ERR"-wk2xxx_remove()------in---\n");
+#endif
+
+    	mutex_lock(&wk2xxxs_lock);
+    	for(i =0;i<NR_PORTS;i++)
+       	{
+        	struct wk2xxx_port *s = &wk2xxxs[i];
+        	uart_remove_one_port(&wk2xxx_uart_driver, &s->port);
+       	}
+    	printk( KERN_ERR"removing wk2xxx driver\n");
+    	uart_unregister_driver(&wk2xxx_uart_driver);
+    	mutex_unlock(&wk2xxxs_lock);
+#ifdef _DEBUG_WK2XXX
+   	    printk(KERN_ERR "-wk2xxx_remove()------exit---\n");
+#endif
+
+    	return 0;
+}
+
+
+#if 0
+static int wk2xxx_resume(struct spi_device *spi)
+{
+    	printk(KERN_ERR "resume wk2xxx");
+    	return 0;
+}
+
+
+static int wk2xxx_suspend(struct spi_device *spi)
+{
+    	printk(KERN_ERR "suspend wk2xxx");
+    	return 0;
+}
+
+#endif
+
+static const struct of_device_id rockchip_spi_wk2xxx_dt_match[] = {
+        { .compatible = "wkmic,wk2124spi", },
+		{ },
+};
+MODULE_DEVICE_TABLE(of, rockchip_spi_wk2xxx_dt_match);
+
+static struct spi_driver wk2xxx_driver = {
+        .driver = {
+                .name           = "wk2xxxspi",
+                .bus            = &spi_bus_type,
+                .owner          = THIS_MODULE,
+				.of_match_table = of_match_ptr(rockchip_spi_wk2xxx_dt_match),
+        },
+        .probe          = wk2xxx_probe,
+        .remove         = wk2xxx_remove,
+#if 0
+		.suspend 		= wk2xxx_suspend,
+        .resume         = wk2xxx_resume,
+#endif
+};
+
+
+static int __init wk2xxx_init(void)
+{
+
+        int retval;
+        retval = spi_register_driver(&wk2xxx_driver);
+        printk(KERN_ERR "%s,register spi return v = :%d\n",__func__,retval);
+        return retval;
+}
+
+
+
+static void __exit wk2xxx_exit(void)
+{
+        printk(KERN_ERR "%s, TEST_REG:quit\n", __func__);
+	    return spi_unregister_driver(&wk2xxx_driver);
+}
+
+
+module_init(wk2xxx_init);
+module_exit(wk2xxx_exit);
+
+MODULE_AUTHOR("WKMIC Ltd");
+MODULE_DESCRIPTION("wk2xxx generic serial port driver");
+MODULE_LICENSE("GPL");
+
+
+
+
+
+
diff --git a/hm3399_mkernel.sh b/hm3399_mkernel.sh
new file mode 100755
index 00000000..9a8d7012
--- /dev/null
+++ b/hm3399_mkernel.sh
@@ -0,0 +1,6 @@
+#!/bin/bash
+
+make hm3399_linux_defconfig
+#make  rockchip_defconfig
+
+make hm3399-ad-board-lvds-linux.img -j24
diff --git a/hm3399_v2r0_mkernel.sh b/hm3399_v2r0_mkernel.sh
new file mode 100755
index 00000000..8e4a947b
--- /dev/null
+++ b/hm3399_v2r0_mkernel.sh
@@ -0,0 +1,6 @@
+#!/bin/bash
+
+make hm3399_v2r0_linux_defconfig
+#make  rockchip_defconfig
+
+make hm3399_v2r0-ad-board-lvds-linux.img -j24
diff --git a/hm3399_v2r0_mkernel_for_edp.sh b/hm3399_v2r0_mkernel_for_edp.sh
new file mode 100755
index 00000000..49506084
--- /dev/null
+++ b/hm3399_v2r0_mkernel_for_edp.sh
@@ -0,0 +1,6 @@
+#!/bin/bash
+
+#make hm3399_v2r0_linux_defconfig
+#make  rockchip_defconfig
+
+make hm3399_v2r0-ad-board-edp-linux.img -j24
diff --git a/include/linux/mfd/rk808.h b/include/linux/mfd/rk808.h
old mode 100644
new mode 100755
index b433c735..ed6b4222
--- a/include/linux/mfd/rk808.h
+++ b/include/linux/mfd/rk808.h
@@ -989,6 +989,11 @@ struct rk808 {
 	struct regmap *regmap;
 	long variant;
 	struct rk808_pin_info *pins;
+
+#ifdef CONFIG_SEND_POWEROFF_SIGNAL //add by zfanji
+	int poweroff_signal;
+	int active_low;
+#endif
 };
 
 enum {
diff --git a/sound/soc/codecs/Kconfig b/sound/soc/codecs/Kconfig
old mode 100644
new mode 100755
index 9a95b8b5..e25166d6
--- a/sound/soc/codecs/Kconfig
+++ b/sound/soc/codecs/Kconfig
@@ -68,6 +68,7 @@ config SND_SOC_ALL_CODECS
 	select SND_SOC_ES8323 if I2C
 	select SND_SOC_ES8328_SPI if SPI_MASTER
 	select SND_SOC_ES8328_I2C if I2C
+	select SND_SOC_ES8388 if I2C
 	select SND_SOC_ES8396 if I2C
 	select SND_SOC_FM1288 if I2C
 	select SND_SOC_GTM601
@@ -510,6 +511,10 @@ config SND_SOC_ES8328_SPI
 	tristate
 	select SND_SOC_ES8328
 
+config SND_SOC_ES8388
+	tristate "Everest Semi ES8388 CODEC"
+	depends on I2C
+
 config SND_SOC_ES8396
 	tristate "Everest Semi ES8396 CODEC"
 
diff --git a/sound/soc/codecs/Makefile b/sound/soc/codecs/Makefile
old mode 100644
new mode 100755
index 7fe7433f..8e78b768
--- a/sound/soc/codecs/Makefile
+++ b/sound/soc/codecs/Makefile
@@ -64,6 +64,7 @@ snd-soc-es8323-objs := es8323.o
 snd-soc-es8328-objs := es8328.o
 snd-soc-es8328-i2c-objs := es8328-i2c.o
 snd-soc-es8328-spi-objs := es8328-spi.o
+snd-soc-es8388-objs := es8388.o
 snd-soc-es8396-objs := es8396.o
 snd-soc-fm1288-objs := fm1288.o
 snd-soc-gtm601-objs := gtm601.o
@@ -277,6 +278,7 @@ obj-$(CONFIG_SND_SOC_ES8323)	+= snd-soc-es8323.o
 obj-$(CONFIG_SND_SOC_ES8328)	+= snd-soc-es8328.o
 obj-$(CONFIG_SND_SOC_ES8328_I2C)+= snd-soc-es8328-i2c.o
 obj-$(CONFIG_SND_SOC_ES8328_SPI)+= snd-soc-es8328-spi.o
+obj-$(CONFIG_SND_SOC_ES8388)	+= snd-soc-es8388.o
 obj-$(CONFIG_SND_SOC_ES8396)	+= snd-soc-es8396.o
 obj-$(CONFIG_SND_SOC_FM1288)	+= snd-soc-fm1288.o
 obj-$(CONFIG_SND_SOC_GTM601)    += snd-soc-gtm601.o
diff --git a/sound/soc/codecs/es8388.c b/sound/soc/codecs/es8388.c
new file mode 100755
index 00000000..f2bbacbb
--- /dev/null
+++ b/sound/soc/codecs/es8388.c
@@ -0,0 +1,932 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * es8388.c -- es8388 ALSA SoC audio driver
+ * base on sound/soc/codecs/es8323.c
+ *
+ * Copyright (c) 2018 Rockchip Electronics Co. Ltd.
+ *
+ * Author: Mark Brown <will@everset-semi.com>
+ * Author: Xiaotan Luo <lxt@rock-chips.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+//#define DEBUG
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/init.h>
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/pm.h>
+#include <linux/i2c.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/of_gpio.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/tlv.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+#include <sound/initval.h>
+#include <linux/proc_fs.h>
+#include <linux/gpio.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include "es8388.h"
+
+#define INVALID_GPIO -1
+
+#define ES8388_CODEC_SET_SPK	1
+#define ES8388_CODEC_SET_HP	2
+
+#define es8388_HP_VOL	0x1b
+#define es8388_SPK_VOL	0x1b
+
+static int es8388_set_bias_level(struct snd_soc_codec *codec,
+				 enum snd_soc_bias_level level);
+
+/*
+ * es8388 register cache
+ * We can't read the es8388 register space when we
+ * are using 2 wire for device control, so we cache them instead.
+ */
+static u16 es8388_reg[] = {
+	0x06, 0x1C, 0xC3, 0xFC,	/*  0 */
+	0xC0, 0x00, 0x00, 0x7C,	/*  4 */
+	0x80, 0x00, 0x00, 0x06,	/*  8 */
+	0x00, 0x06, 0x30, 0x30,	/* 12 */
+	0xC0, 0xC0, 0x38, 0xB0,	/* 16 */
+	0x32, 0x06, 0x00, 0x00,	/* 20 */
+	0x06, 0x30, 0xC0, 0xC0,	/* 24 */
+	0x08, 0x06, 0x1F, 0xF7,	/* 28 */
+	0xFD, 0xFF, 0x1F, 0xF7,	/* 32 */
+	0xFD, 0xFF, 0x00, 0x38,	/* 36 */
+	0x38, 0x38, 0x38, 0x38,	/* 40 */
+	0x38, 0x00, 0x00, 0x00,	/* 44 */
+	0x00, 0x00, 0x00, 0x00,	/* 48 */
+	0x00, 0x00, 0x00, 0x00,	/* 52 */
+};
+
+/* codec private data */
+struct es8388_priv {
+	unsigned int sysclk;
+	struct clk *mclk;
+	struct snd_pcm_hw_constraint_list *sysclk_constraints;
+	struct delayed_work work;
+	int debounce_time;
+
+	int spk_ctl_gpio;
+	int hp_det_gpio;
+
+	bool muted;
+	bool hp_inserted;
+	bool spk_gpio_level;
+	int hp_det_level;
+};
+
+static struct snd_soc_codec *es8388_codec;
+
+static struct es8388_priv *es8388_private;
+static int es8388_set_gpio(int gpio, bool level)
+{
+	struct es8388_priv *es8388 = es8388_private;
+
+	if (!es8388)
+		return 0;
+
+	if ((gpio & ES8388_CODEC_SET_SPK) && es8388 &&
+	    es8388->spk_ctl_gpio != INVALID_GPIO) {
+		gpio_set_value(es8388->spk_ctl_gpio, level);
+	}
+
+	return 0;
+}
+
+
+
+static void hp_work(struct work_struct *work)
+{
+
+	struct es8388_priv *es8388;
+	bool isInsert=false;
+	es8388 = container_of(work, struct es8388_priv, work.work);
+
+	isInsert = es8388->hp_inserted;
+	if (gpio_get_value(es8388->hp_det_gpio)){
+		es8388->hp_inserted = (es8388->hp_det_level==1)?true:false;
+	}else{
+		es8388->hp_inserted = (es8388->hp_det_level==1)?false:true;
+	}
+	
+	dev_dbg(es8388_codec->dev,"%s	 muted=%d hp_det_gpio=%d hp_inserted=%d\r\n",__FUNCTION__,es8388->muted,gpio_get_value(es8388->hp_det_gpio),es8388->hp_inserted);
+
+	if (es8388->muted == 0 && (isInsert!=es8388->hp_inserted)) {
+		if (es8388->hp_inserted){
+			dev_dbg(es8388_codec->dev,"%s spk=0 hp=1 \r\n",__FUNCTION__);
+			snd_soc_write(es8388_codec, 0x04, 0x0c);
+		
+			es8388_set_gpio(ES8388_CODEC_SET_SPK,
+					!es8388->spk_gpio_level);
+			snd_soc_write(es8388_codec, 0x2e, 0x00);
+			snd_soc_write(es8388_codec, 0x2f, 0x00);
+			snd_soc_write(es8388_codec, 0x30, es8388_HP_VOL);
+			snd_soc_write(es8388_codec, 0x31, es8388_HP_VOL);	
+		}
+		else{
+			dev_dbg(es8388_codec->dev,"%s spk=1 hp=0 \r\n",__FUNCTION__);
+			snd_soc_write(es8388_codec, 0x04, 0x30);
+		
+			es8388_set_gpio(ES8388_CODEC_SET_SPK,
+					es8388->spk_gpio_level);
+			snd_soc_write(es8388_codec, 0x2e, es8388_SPK_VOL);
+			snd_soc_write(es8388_codec, 0x2f, es8388_SPK_VOL);
+			snd_soc_write(es8388_codec, 0x30, 0x00);
+			snd_soc_write(es8388_codec, 0x31, 0x00);	
+		}
+	}
+	
+	schedule_delayed_work(&es8388->work, msecs_to_jiffies(es8388->debounce_time));
+
+
+}
+
+/*
+static irqreturn_t es8388_irq_handler(int irq, void *data)
+{
+	//struct es8388_priv *es8388 = data;
+
+//	queue_delayed_work(system_power_efficient_wq, &es8388->work,
+//			   msecs_to_jiffies(es8388->debounce_time));
+
+	return IRQ_HANDLED;
+}
+
+*/
+static unsigned int es8388_read_reg_cache(struct snd_soc_codec *codec,
+					  unsigned int reg)
+{
+	if (reg >= ARRAY_SIZE(es8388_reg))
+		return -1;
+	return es8388_reg[reg];
+}
+
+static int es8388_write(struct snd_soc_codec *codec, unsigned int reg,
+			unsigned int value)
+{
+	u8 data[2];
+	int ret;
+
+	data[0] = reg;
+	data[1] = value & 0x00ff;
+
+	if (reg < ARRAY_SIZE(es8388_reg))
+		es8388_reg[reg] = value;
+	ret = codec->hw_write(codec->control_data, data, 2);
+	if (ret == 2)
+		return 0;
+	if (ret < 0)
+		return ret;
+	else
+		return -EIO;
+}
+
+static int es8388_reset(struct snd_soc_codec *codec)
+{
+	snd_soc_write(codec, ES8388_CONTROL1, 0x80);
+	return snd_soc_write(codec, ES8388_CONTROL1, 0x00);
+}
+
+
+struct _coeff_div {
+	u32 mclk;
+	u32 rate;
+	u16 fs;
+	u8 sr:4;
+	u8 usb:1;
+};
+
+/* codec hifi mclk clock divider coefficients */
+static const struct _coeff_div coeff_div[] = {
+	/* 8k */
+	{12288000, 8000, 1536, 0xa, 0x0},
+	{11289600, 8000, 1408, 0x9, 0x0},
+	{18432000, 8000, 2304, 0xc, 0x0},
+	{16934400, 8000, 2112, 0xb, 0x0},
+	{12000000, 8000, 1500, 0xb, 0x1},
+
+	/* 11.025k */
+	{11289600, 11025, 1024, 0x7, 0x0},
+	{16934400, 11025, 1536, 0xa, 0x0},
+	{12000000, 11025, 1088, 0x9, 0x1},
+
+	/* 16k */
+	{12288000, 16000, 768, 0x6, 0x0},
+	{18432000, 16000, 1152, 0x8, 0x0},
+	{12000000, 16000, 750, 0x7, 0x1},
+
+	/* 22.05k */
+	{11289600, 22050, 512, 0x4, 0x0},
+	{16934400, 22050, 768, 0x6, 0x0},
+	{12000000, 22050, 544, 0x6, 0x1},
+
+	/* 32k */
+	{12288000, 32000, 384, 0x3, 0x0},
+	{18432000, 32000, 576, 0x5, 0x0},
+	{12000000, 32000, 375, 0x4, 0x1},
+
+	/* 44.1k */
+	{11289600, 44100, 256, 0x2, 0x0},
+	{16934400, 44100, 384, 0x3, 0x0},
+	{12000000, 44100, 272, 0x3, 0x1},
+
+	/* 48k */
+	{12288000, 48000, 256, 0x2, 0x0},
+	{18432000, 48000, 384, 0x3, 0x0},
+	{12000000, 48000, 250, 0x2, 0x1},
+
+	/* 88.2k */
+	{11289600, 88200, 128, 0x0, 0x0},
+	{16934400, 88200, 192, 0x1, 0x0},
+	{12000000, 88200, 136, 0x1, 0x1},
+
+	/* 96k */
+	{12288000, 96000, 128, 0x0, 0x0},
+	{18432000, 96000, 192, 0x1, 0x0},
+	{12000000, 96000, 125, 0x0, 0x1},
+};
+
+static inline int get_coeff(int mclk, int rate)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(coeff_div); i++) {
+		if (coeff_div[i].rate == rate && coeff_div[i].mclk == mclk)
+			return i;
+	}
+
+	return -EINVAL;
+}
+
+/* The set of rates we can generate from the above for each SYSCLK */
+static unsigned int rates_12288[] = {
+	8000, 12000, 16000, 24000, 24000, 32000, 48000, 96000,
+};
+
+static struct snd_pcm_hw_constraint_list constraints_12288 = {
+	.count = ARRAY_SIZE(rates_12288),
+	.list = rates_12288,
+};
+
+static unsigned int rates_112896[] = {
+	8000, 11025, 22050, 44100,
+};
+
+static struct snd_pcm_hw_constraint_list constraints_112896 = {
+	.count = ARRAY_SIZE(rates_112896),
+	.list = rates_112896,
+};
+
+static unsigned int rates_12[] = {
+	8000, 11025, 12000, 16000, 22050, 24000, 32000, 44100, 48000,
+	48000, 88235, 96000,
+};
+
+static struct snd_pcm_hw_constraint_list constraints_12 = {
+	.count = ARRAY_SIZE(rates_12),
+	.list = rates_12,
+};
+
+/*
+ * Note that this should be called from init rather than from hw_params.
+ */
+static int es8388_set_dai_sysclk(struct snd_soc_dai *codec_dai,
+				 int clk_id, unsigned int freq, int dir)
+{
+	struct snd_soc_codec *codec = codec_dai->codec;
+	struct es8388_priv *es8388 = snd_soc_codec_get_drvdata(codec);
+
+	dev_dbg(codec->dev,"%s %d \r\n",__FUNCTION__,freq);
+
+	switch (freq) {
+	case 11289600:
+	case 18432000:
+	case 22579200:
+	case 36864000:
+		es8388->sysclk_constraints = &constraints_112896;
+		es8388->sysclk = freq;
+		return 0;
+
+	case 12288000:
+	case 16934400:
+	case 24576000:
+	case 33868800:
+		es8388->sysclk_constraints = &constraints_12288;
+		es8388->sysclk = freq;
+		return 0;
+
+	case 12000000:
+	case 24000000:
+		es8388->sysclk_constraints = &constraints_12;
+		es8388->sysclk = freq;
+		return 0;
+	}
+	return -EINVAL;
+}
+
+static int es8388_set_dai_fmt(struct snd_soc_dai *codec_dai, unsigned int fmt)
+{
+	struct snd_soc_codec *codec = codec_dai->codec;
+	u8 iface = 0;
+	u8 adciface = 0;
+	u8 daciface = 0;
+	dev_dbg(codec->dev,"%s \r\n",__FUNCTION__);
+
+	iface = snd_soc_read(codec, ES8388_IFACE);
+	adciface = snd_soc_read(codec, ES8388_ADC_IFACE);
+	daciface = snd_soc_read(codec, ES8388_DAC_IFACE);
+
+	/* set master/slave audio interface */
+	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
+	case SND_SOC_DAIFMT_CBM_CFM:	/* MASTER MODE */
+		iface |= 0x80;
+		break;
+	case SND_SOC_DAIFMT_CBS_CFS:	/* SLAVE MODE */
+		iface &= 0x7F;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	/* interface format */
+	switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+	case SND_SOC_DAIFMT_I2S:
+		adciface &= 0xFC;
+		daciface &= 0xF9;
+		break;
+	case SND_SOC_DAIFMT_RIGHT_J:
+		break;
+	case SND_SOC_DAIFMT_LEFT_J:
+		break;
+	case SND_SOC_DAIFMT_DSP_A:
+		break;
+	case SND_SOC_DAIFMT_DSP_B:
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	/* clock inversion */
+	switch (fmt & SND_SOC_DAIFMT_INV_MASK) {
+	case SND_SOC_DAIFMT_NB_NF:
+		iface &= 0xDF;
+		adciface &= 0xDF;
+		daciface &= 0xBF;
+		break;
+	case SND_SOC_DAIFMT_IB_IF:
+		iface |= 0x20;
+		adciface |= 0x20;
+		daciface |= 0x40;
+		break;
+	case SND_SOC_DAIFMT_IB_NF:
+		iface |= 0x20;
+		adciface &= 0xDF;
+		daciface &= 0xBF;
+		break;
+	case SND_SOC_DAIFMT_NB_IF:
+		iface &= 0xDF;
+		adciface |= 0x20;
+		daciface |= 0x40;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	snd_soc_write(codec, ES8388_IFACE, iface);
+	snd_soc_write(codec, ES8388_ADC_IFACE, adciface);
+	snd_soc_write(codec, ES8388_DAC_IFACE, daciface);
+
+	return 0;
+}
+
+static int es8388_pcm_startup(struct snd_pcm_substream *substream,
+			      struct snd_soc_dai *dai)
+{
+	struct snd_soc_codec *codec = dai->codec;
+	struct es8388_priv *es8388 = snd_soc_codec_get_drvdata(codec);
+
+	dev_dbg(codec->dev,"%s   \r\n",__FUNCTION__);
+
+	/* The set of sample rates that can be supported depends on the
+	 * MCLK supplied to the CODEC - enforce this.
+	 */
+	if (!es8388->sysclk) {
+		dev_err(codec->dev,
+			"No MCLK configured, call set_sysclk() on init\n");
+		return -EINVAL;
+	}
+
+
+	snd_pcm_hw_constraint_list(substream->runtime, 0,
+				   SNDRV_PCM_HW_PARAM_RATE,
+				   es8388->sysclk_constraints);
+
+	return 0;
+}
+
+static int es8388_pcm_hw_params(struct snd_pcm_substream *substream,
+				struct snd_pcm_hw_params *params,
+				struct snd_soc_dai *dai)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_codec *codec = rtd->codec;
+	struct es8388_priv *es8388 = snd_soc_codec_get_drvdata(codec);
+	u16 srate = snd_soc_read(codec, ES8388_IFACE) & 0x80;
+	u16 adciface = snd_soc_read(codec, ES8388_ADC_IFACE) & 0xE3;
+	u16 daciface = snd_soc_read(codec, ES8388_DAC_IFACE) & 0xC7;
+	int coeff;
+
+	dev_dbg(codec->dev,"%s \r\n",__FUNCTION__);
+
+	coeff = get_coeff(es8388->sysclk, params_rate(params));
+	if (coeff < 0) {
+		coeff = get_coeff(es8388->sysclk / 2, params_rate(params));
+		srate |= 0x40;
+	}
+	if (coeff < 0) {
+		dev_err(codec->dev,
+			"Unable to configure sample rate %dHz with %dHz MCLK\n",
+			params_rate(params), es8388->sysclk);
+		return coeff;
+	}
+
+	/* bit size */
+	switch (params_format(params)) {
+	case SNDRV_PCM_FORMAT_S16_LE:
+		adciface |= 0x000C;
+		daciface |= 0x0018;
+		break;
+	case SNDRV_PCM_FORMAT_S20_3LE:
+		adciface |= 0x0004;
+		daciface |= 0x0008;
+		break;
+	case SNDRV_PCM_FORMAT_S24_LE:
+		break;
+	case SNDRV_PCM_FORMAT_S32_LE:
+		adciface |= 0x0010;
+		daciface |= 0x0020;
+		break;
+	}
+
+	/* set iface & srate */
+	snd_soc_write(codec, ES8388_DAC_IFACE, daciface);
+	snd_soc_write(codec, ES8388_ADC_IFACE, adciface);
+
+	if (coeff >= 0) {
+		snd_soc_write(codec, ES8388_IFACE, srate);
+		snd_soc_write(codec, ES8388_ADCCONTROL5,
+			      coeff_div[coeff].sr |
+			      (coeff_div[coeff].usb) << 4);
+		snd_soc_write(codec, ES8388_DACCONTROL2,
+			      coeff_div[coeff].sr |
+			      (coeff_div[coeff].usb) << 4);
+	}
+
+	return 0;
+}
+
+static int es8388_mute(struct snd_soc_dai *dai, int mute)
+{
+	struct snd_soc_codec *codec = dai->codec;
+	struct es8388_priv *es8388 = snd_soc_codec_get_drvdata(codec);
+
+	es8388->muted = mute;
+
+	dev_dbg(es8388_codec->dev,"%s muted=%d     hp_inserted=%d \r\n",__FUNCTION__,mute,es8388->hp_inserted);
+	if (mute) {
+		es8388_set_gpio(ES8388_CODEC_SET_SPK, !es8388->spk_gpio_level);
+		
+		snd_soc_write(codec, 0x04, 0x00);
+	
+		usleep_range(18000, 20000);
+		snd_soc_write(es8388_codec, 0x30, 0x00);
+		snd_soc_write(es8388_codec, 0x31, 0x00);	
+		snd_soc_write(es8388_codec, 0x2e, 0x00);
+		snd_soc_write(es8388_codec, 0x2f, 0x00);
+		snd_soc_write(codec, ES8388_DACCONTROL3, 0x06);
+
+	} else {
+		
+		snd_soc_write(codec, ES8388_DACCONTROL3, 0x02);
+		
+		msleep(50);
+
+		if (gpio_get_value(es8388->hp_det_gpio))
+			es8388->hp_inserted = (es8388->hp_det_level==1)?true:false;
+		else
+			es8388->hp_inserted = (es8388->hp_det_level==1)?false:true;
+
+		if (es8388->hp_inserted){
+			dev_dbg(es8388_codec->dev,"%s spk=0 hp=1 \r\n",__FUNCTION__);
+			snd_soc_write(codec, 0x04, 0x0c);
+			es8388_set_gpio(ES8388_CODEC_SET_SPK,
+					!es8388->spk_gpio_level);
+			snd_soc_write(es8388_codec, 0x2e, 0x00);
+			snd_soc_write(es8388_codec, 0x2f, 0x00);
+			snd_soc_write(es8388_codec, 0x30, es8388_HP_VOL);
+			snd_soc_write(es8388_codec, 0x31, es8388_HP_VOL);	
+		}
+		else{
+			dev_dbg(es8388_codec->dev,"%s spk=1 hp=0 \r\n",__FUNCTION__);
+			snd_soc_write(codec, 0x04, 0x30);
+			es8388_set_gpio(ES8388_CODEC_SET_SPK,
+					es8388->spk_gpio_level);
+			snd_soc_write(es8388_codec, 0x2e, es8388_SPK_VOL);
+			snd_soc_write(es8388_codec, 0x2f, es8388_SPK_VOL);
+			snd_soc_write(es8388_codec, 0x30, 0x00);
+			snd_soc_write(es8388_codec, 0x31, 0x00);	
+		}
+
+		usleep_range(18000, 20000);
+	}
+	return 0;
+}
+
+static int es8388_set_bias_level(struct snd_soc_codec *codec,
+				 enum snd_soc_bias_level level)
+{
+	struct es8388_priv *es8388 = snd_soc_codec_get_drvdata(codec);
+	int ret;
+
+	dev_dbg(codec->dev,"%s   \r\n",__FUNCTION__);
+
+
+	switch (level) {
+	case SND_SOC_BIAS_ON:
+		dev_dbg(codec->dev, "%s on\n", __func__);
+		break;
+	case SND_SOC_BIAS_PREPARE:
+		dev_dbg(codec->dev, "%s prepare\n", __func__);
+		if (IS_ERR(es8388->mclk))
+			break;
+		if (snd_soc_codec_get_bias_level(codec) == SND_SOC_BIAS_ON) {
+			clk_disable_unprepare(es8388->mclk);
+		} else {
+			ret = clk_prepare_enable(es8388->mclk);
+			if (ret)
+				return ret;
+		}
+		snd_soc_write(codec, ES8388_ANAVOLMANAG, 0x7C);
+		snd_soc_write(codec, ES8388_CHIPLOPOW1, 0x00);
+		snd_soc_write(codec, ES8388_CHIPLOPOW2, 0x00);
+		snd_soc_write(codec, ES8388_CHIPPOWER, 0x00);
+		snd_soc_write(codec, ES8388_ADCPOWER, 0x00);
+		break;
+	case SND_SOC_BIAS_STANDBY:
+		dev_dbg(codec->dev, "%s standby\n", __func__);
+		snd_soc_write(codec, ES8388_ANAVOLMANAG, 0x7C);
+		snd_soc_write(codec, ES8388_CHIPLOPOW1, 0x00);
+		snd_soc_write(codec, ES8388_CHIPLOPOW2, 0x00);
+		snd_soc_write(codec, ES8388_CHIPPOWER, 0x00);
+		snd_soc_write(codec, ES8388_ADCPOWER, 0x00);
+		break;
+	case SND_SOC_BIAS_OFF:
+		if (es8388->mclk)
+			clk_disable_unprepare(es8388->mclk);
+		dev_dbg(codec->dev, "%s off\n", __func__);
+		snd_soc_write(codec, ES8388_ADCPOWER, 0xFF);
+		snd_soc_write(codec, ES8388_DACPOWER, 0xC0);
+		snd_soc_write(codec, ES8388_CHIPLOPOW1, 0xFF);
+		snd_soc_write(codec, ES8388_CHIPLOPOW2, 0xFF);
+		snd_soc_write(codec, ES8388_CHIPPOWER, 0xFF);
+		snd_soc_write(codec, ES8388_ANAVOLMANAG, 0x7B);
+		break;
+	}
+	return 0;
+}
+
+#define es8388_RATES SNDRV_PCM_RATE_8000_96000
+
+#define es8388_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE |\
+	SNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S32_LE)
+
+static struct snd_soc_dai_ops es8388_ops = {
+	.startup = es8388_pcm_startup,
+	.hw_params = es8388_pcm_hw_params,
+	.set_fmt = es8388_set_dai_fmt,
+	.set_sysclk = es8388_set_dai_sysclk,
+	.digital_mute = es8388_mute,
+};
+
+static struct snd_soc_dai_driver es8388_dai = {
+	.name = "ES8388 HiFi",
+	.playback = {
+		     .stream_name = "Playback",
+		     .channels_min = 1,
+		     .channels_max = 2,
+		     .rates = es8388_RATES,
+		     .formats = es8388_FORMATS,
+		     },
+	.capture = {
+		    .stream_name = "Capture",
+		    .channels_min = 2,
+		    .channels_max = 8,
+		    .rates = es8388_RATES,
+		    .formats = es8388_FORMATS,
+		    },
+	.ops = &es8388_ops,
+	.symmetric_rates = 1,
+};
+
+static int es8388_suspend(struct snd_soc_codec *codec)
+{
+	snd_soc_write(codec, 0x19, 0x06);
+	snd_soc_write(codec, 0x30, 0x00);
+	snd_soc_write(codec, 0x31, 0x00);
+	snd_soc_write(codec, ES8388_ADCPOWER, 0xFF);
+	snd_soc_write(codec, ES8388_DACPOWER, 0xc0);
+	snd_soc_write(codec, ES8388_CHIPPOWER, 0xF3);
+	snd_soc_write(codec, 0x00, 0x00);
+	snd_soc_write(codec, 0x01, 0x58);
+	snd_soc_write(codec, 0x2b, 0x9c);
+	usleep_range(18000, 20000);
+	return 0;
+}
+
+static int es8388_resume(struct snd_soc_codec *codec)
+{
+	snd_soc_write(codec, 0x2b, 0x80);
+	snd_soc_write(codec, 0x01, 0x50);
+	snd_soc_write(codec, 0x00, 0x32);
+	snd_soc_write(codec, ES8388_CHIPPOWER, 0x00);
+	snd_soc_write(codec, ES8388_DACPOWER, 0x0c);
+	snd_soc_write(codec, ES8388_ADCPOWER, 0x00);
+	snd_soc_write(codec, 0x2f, es8388_SPK_VOL);
+	snd_soc_write(codec, 0x2e, es8388_SPK_VOL);
+	snd_soc_write(codec, 0x31, es8388_HP_VOL);
+	snd_soc_write(codec, 0x30, es8388_HP_VOL);
+	snd_soc_write(codec, 0x19, 0x02);
+	return 0;
+}
+
+static int es8388_probe(struct snd_soc_codec *codec)
+{
+	struct es8388_priv *es8388 = snd_soc_codec_get_drvdata(codec);
+	int ret = 0;
+
+	if (!codec) {
+		dev_err(codec->dev, "Codec device not registered\n");
+		return -ENODEV;
+	}
+
+	es8388->mclk = devm_clk_get(codec->dev, "mclk");
+	if (IS_ERR(es8388->mclk)) {
+		dev_err(codec->dev, "%s mclk is missing or invalid\n",
+			__func__);
+		return PTR_ERR(es8388->mclk);
+	}
+	ret = clk_prepare_enable(es8388->mclk);
+	if (ret)
+		return ret;
+	codec->hw_write = (hw_write_t)i2c_master_send;
+	codec->control_data = container_of(codec->dev, struct i2c_client, dev);
+
+	es8388_codec = codec;
+	ret = es8388_reset(codec);
+	if (ret < 0) {
+		dev_err(codec->dev, "Failed to issue reset\n");
+		return ret;
+	}
+	usleep_range(18000, 20000);
+	snd_soc_write(codec, 0x02, 0xf3);
+	snd_soc_write(codec, 0x2B, 0x80);
+	/* ES8388 salve */
+	snd_soc_write(codec, 0x08, 0x00);
+	snd_soc_write(codec, 0x00, 0x35);
+	/* PLAYBACK & RECORD Mode,EnRefr=1 */
+	snd_soc_write(codec, 0x01, 0x50);
+	/* pdn_ana=0,ibiasgen_pdn=0 */
+	snd_soc_write(codec, 0x03, 0x59);
+	/* pdn_ana=0,ibiasgen_pdn=0 */
+	snd_soc_write(codec, 0x05, 0x00);
+	/* pdn_ana=0,ibiasgen_pdn=0 */
+	snd_soc_write(codec, 0x06, 0x00);
+	snd_soc_write(codec, 0x07, 0x7c);
+	/* ADC L/R PGA =  0dB */
+	snd_soc_write(codec, 0x09, 0x88);/* ADC L/R PGA =  +24dB */
+	/* ADC INPUT=LIN2/RIN2 */
+	snd_soc_write(codec, 0x0a, 0xf8);
+	/* ADC INPUT=LIN2/RIN2 */
+	snd_soc_write(codec, 0x0b, 0x82);
+	/* I2S-16BIT */
+	snd_soc_write(codec, 0x0C, 0x0c);
+	/* MCLK/LRCK=256 */
+	snd_soc_write(codec, 0x0d, 0x02);
+	/*
+	 * left channel polarity inverted and
+	 * enable ADC right channel high pass filter
+	 */
+	snd_soc_write(codec, 0x0e, 0xb0);
+	/* ADC Left Volume=0db */
+	snd_soc_write(codec, 0x10, 0x00);
+	/* ADC Right Volume=0db */
+	snd_soc_write(codec, 0x11, 0x00);
+	/* ALC off */
+	snd_soc_write(codec, 0x12, 0x2a);
+	snd_soc_write(codec, 0x13, 0xc0);
+	snd_soc_write(codec, 0x14, 0x05);
+	snd_soc_write(codec, 0x15, 0x06);
+	snd_soc_write(codec, 0x16, 0x53);
+	/* I2S-16BIT */
+	snd_soc_write(codec, 0x17, 0x18);
+	snd_soc_write(codec, 0x18, 0x02);
+	/* DAC VOLUME=0DB */
+	snd_soc_write(codec, 0x1A, 0x0A);
+	snd_soc_write(codec, 0x1B, 0x0A);
+	/* Left DAC TO Left IXER */
+	snd_soc_write(codec, 0x26, 0x12);
+	/* Left DAC TO Left MIXER */
+	snd_soc_write(codec, 0x27, 0xb8);
+	snd_soc_write(codec, 0x28, 0x38);
+	snd_soc_write(codec, 0x29, 0x38);
+	snd_soc_write(codec, 0x2A, 0xb8);
+	/* START DLL and state-machine,START DSM */
+	snd_soc_write(codec, 0x02, 0x00);
+	/* SOFT RAMP RATE=32LRCKS/STEP,Enable ZERO-CROSS CHECK,DAC MUTE */
+	snd_soc_write(codec, 0x19, 0x02);
+	/* pdn_ana=0,ibiasgen_pdn=0 */
+	snd_soc_write(codec, 0x04, 0x0c);
+	usleep_range(18000, 20000);
+	snd_soc_write(codec, 0x2e, 0x00);
+	snd_soc_write(codec, 0x2f, 0x00);
+	snd_soc_write(codec, 0x30, 0x08);
+	snd_soc_write(codec, 0x31, 0x08);
+	usleep_range(18000, 20000);
+	snd_soc_write(codec, 0x30, 0x0f);
+	snd_soc_write(codec, 0x31, 0x0f);
+	usleep_range(18000, 20000);
+	snd_soc_write(codec, 0x30, 0x18);
+	snd_soc_write(codec, 0x31, 0x18);
+	usleep_range(18000, 20000);
+	/* pdn_ana=0,ibiasgen_pdn=0 */
+	snd_soc_write(codec, 0x04, 0x3c);
+
+	snd_soc_write(codec, ES8388_DACCONTROL3, 0x06);
+	es8388_set_bias_level(codec, SND_SOC_BIAS_STANDBY);
+	return 0;
+}
+
+static int es8388_remove(struct snd_soc_codec *codec)
+{
+	es8388_set_bias_level(codec, SND_SOC_BIAS_OFF);
+	return 0;
+}
+
+static struct snd_soc_codec_driver soc_codec_dev_es8388 = {
+	.probe = es8388_probe,
+	.remove = es8388_remove,
+	.suspend = es8388_suspend,
+	.resume = es8388_resume,
+	.set_bias_level = es8388_set_bias_level,
+	.reg_cache_size = ARRAY_SIZE(es8388_reg),
+	.reg_word_size = sizeof(u16),
+	.reg_cache_default = es8388_reg,
+	.reg_cache_step = 1,
+	.read = es8388_read_reg_cache,
+	.write = es8388_write,
+
+};
+
+static int es8388_i2c_probe(struct i2c_client *i2c,
+			    const struct i2c_device_id *id)
+{
+	struct es8388_priv *es8388;
+	int ret = -1;
+	//int hp_irq = 0;
+	enum of_gpio_flags flags;
+	struct i2c_adapter *adapter = to_i2c_adapter(i2c->dev.parent);
+	char reg;
+
+	if (!i2c_check_functionality(adapter, I2C_FUNC_I2C)) {
+		dev_warn(&adapter->dev,
+			 "I2C-Adapter doesn't support I2C_FUNC_I2C\n");
+		return -EIO;
+	}
+
+	es8388 = devm_kzalloc(&i2c->dev, sizeof(struct es8388_priv),
+			      GFP_KERNEL);
+	if (!es8388)
+		return -ENOMEM;
+
+	i2c_set_clientdata(i2c, es8388);
+
+	reg = ES8388_DACCONTROL18;
+	ret = i2c_master_recv(i2c, &reg, 1);
+	if (ret < 0) {
+		dev_err(&i2c->dev, "i2c recv Failed\n");
+		return ret;
+	}
+
+	es8388_private = es8388;
+	es8388->spk_ctl_gpio = of_get_named_gpio_flags(i2c->dev.of_node,
+						       "spk-con-gpio", 0,
+						       &flags);
+	if (es8388->spk_ctl_gpio < 0) {
+		dev_info(&i2c->dev, "Can not read property spk_ctl_gpio\n");
+		es8388->spk_ctl_gpio = INVALID_GPIO;
+	} else {
+		es8388->spk_gpio_level = (flags & OF_GPIO_ACTIVE_LOW) ? 0 : 1;
+		ret = devm_gpio_request_one(&i2c->dev, es8388->spk_ctl_gpio,
+					    GPIOF_DIR_OUT, NULL);
+		if (ret != 0) {
+			dev_err(&i2c->dev, "Failed to request spk_ctl_gpio\n");
+			return ret;
+		}
+		es8388_set_gpio(ES8388_CODEC_SET_SPK, !es8388->spk_gpio_level);
+	}
+
+
+	es8388->debounce_time = 1000;
+
+	es8388->hp_det_gpio = of_get_named_gpio_flags(i2c->dev.of_node,
+						      "hp-det-gpio", 0, &flags);
+	if (es8388->hp_det_gpio < 0) {
+					dev_info(&i2c->dev, "Can not read property hp_det_gpio\n");
+					es8388->hp_det_gpio = INVALID_GPIO;
+	} else {
+			es8388->hp_det_level = (flags & OF_GPIO_ACTIVE_LOW) ? 0 : 1;
+			gpio_direction_input(es8388->hp_det_gpio);
+			ret = devm_gpio_request(&i2c->dev, es8388->hp_det_gpio, "hp-det-gpio");
+			if(ret < 0){
+				gpio_free(es8388->hp_det_gpio);
+				printk(KERN_INFO "hp-det-gpio request ERROR\n");
+			}
+			
+			INIT_DELAYED_WORK(&es8388->work, hp_work);
+			schedule_delayed_work(&es8388->work,
+								  msecs_to_jiffies(es8388->debounce_time));
+	}
+							  
+	ret = snd_soc_register_codec(&i2c->dev,
+				     &soc_codec_dev_es8388,
+				     &es8388_dai, 1);
+
+	return ret;
+}
+
+static int es8388_i2c_remove(struct i2c_client *client)
+{
+	snd_soc_unregister_codec(&client->dev);
+	return 0;
+}
+
+static const struct i2c_device_id es8388_i2c_id[] = {
+	{"es8388", 0},
+	{}
+};
+
+MODULE_DEVICE_TABLE(i2c, es8388_i2c_id);
+
+void es8388_i2c_shutdown(struct i2c_client *client)
+{
+	struct es8388_priv *es8388 = es8388_private;
+
+	es8388_set_gpio(ES8388_CODEC_SET_SPK, !es8388->spk_gpio_level);
+	mdelay(20);
+	snd_soc_write(es8388_codec, ES8388_CONTROL2, 0x58);
+	snd_soc_write(es8388_codec, ES8388_CONTROL1, 0x32);
+	snd_soc_write(es8388_codec, ES8388_CHIPPOWER, 0xf3);
+	snd_soc_write(es8388_codec, ES8388_DACPOWER, 0xc0);
+	mdelay(50);
+	snd_soc_write(es8388_codec, ES8388_DACCONTROL24, 0x00);
+	snd_soc_write(es8388_codec, ES8388_DACCONTROL25, 0x00);
+	snd_soc_write(es8388_codec, ES8388_DACCONTROL26, 0x00);
+	snd_soc_write(es8388_codec, ES8388_DACCONTROL27, 0x00);
+	mdelay(50);
+	snd_soc_write(es8388_codec, ES8388_CONTROL1, 0x30);
+	snd_soc_write(es8388_codec, ES8388_CONTROL1, 0x34);
+}
+
+static const struct of_device_id es8388_of_match[] = {
+	{ .compatible = "everest,es8388", },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, es8388_of_match);
+
+static struct i2c_driver es8388_i2c_driver = {
+	.driver = {
+		.name = "ES8388",
+		.of_match_table = of_match_ptr(es8388_of_match),
+		},
+	.shutdown = es8388_i2c_shutdown,
+	.probe = es8388_i2c_probe,
+	.remove = es8388_i2c_remove,
+	.id_table = es8388_i2c_id,
+};
+module_i2c_driver(es8388_i2c_driver);
+
+MODULE_DESCRIPTION("ASoC es8388 driver");
+MODULE_AUTHOR("Mark Brown <will@everset-semi.com>");
+MODULE_LICENSE("GPL");
diff --git a/sound/soc/codecs/es8388.h b/sound/soc/codecs/es8388.h
new file mode 100755
index 00000000..ec1c2d1d
--- /dev/null
+++ b/sound/soc/codecs/es8388.h
@@ -0,0 +1,81 @@
+/*
+ * Copyright 2005 Openedhand Ltd.
+ *
+ * Author: Richard Purdie <richard@openedhand.com>
+ *
+ * Based on ES8388.h
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#ifndef _ES8388_H
+#define _ES8388_H
+
+/* ES8388 register space */
+
+#define ES8388_CONTROL1         0x00
+#define ES8388_CONTROL2         0x01
+#define ES8388_CHIPPOWER        0x02
+#define ES8388_ADCPOWER         0x03
+#define ES8388_DACPOWER         0x04
+#define ES8388_CHIPLOPOW1       0x05
+#define ES8388_CHIPLOPOW2       0x06
+#define ES8388_ANAVOLMANAG      0x07
+#define ES8388_MASTERMODE       0x08
+#define ES8388_ADCCONTROL1      0x09
+#define ES8388_ADCCONTROL2      0x0a
+#define ES8388_ADCCONTROL3      0x0b
+#define ES8388_ADCCONTROL4      0x0c
+#define ES8388_ADCCONTROL5      0x0d
+#define ES8388_ADCCONTROL6      0x0e
+#define ES8388_ADCCONTROL7      0x0f
+#define ES8388_ADCCONTROL8      0x10
+#define ES8388_ADCCONTROL9      0x11
+#define ES8388_ADCCONTROL10     0x12
+#define ES8388_ADCCONTROL11     0x13
+#define ES8388_ADCCONTROL12     0x14
+#define ES8388_ADCCONTROL13     0x15
+#define ES8388_ADCCONTROL14     0x16
+
+#define ES8388_DACCONTROL1      0x17
+#define ES8388_DACCONTROL2      0x18
+#define ES8388_DACCONTROL3      0x19
+#define ES8388_DACCONTROL4      0x1a
+#define ES8388_DACCONTROL5      0x1b
+#define ES8388_DACCONTROL6      0x1c
+#define ES8388_DACCONTROL7      0x1d
+#define ES8388_DACCONTROL8      0x1e
+#define ES8388_DACCONTROL9      0x1f
+#define ES8388_DACCONTROL10     0x20
+#define ES8388_DACCONTROL11     0x21
+#define ES8388_DACCONTROL12     0x22
+#define ES8388_DACCONTROL13     0x23
+#define ES8388_DACCONTROL14     0x24
+#define ES8388_DACCONTROL15     0x25
+#define ES8388_DACCONTROL16     0x26
+#define ES8388_DACCONTROL17     0x27
+#define ES8388_DACCONTROL18     0x28
+#define ES8388_DACCONTROL19     0x29
+#define ES8388_DACCONTROL20     0x2a
+#define ES8388_DACCONTROL21     0x2b
+#define ES8388_DACCONTROL22     0x2c
+#define ES8388_DACCONTROL23     0x2d
+#define ES8388_DACCONTROL24     0x2e
+#define ES8388_DACCONTROL25     0x2f
+#define ES8388_DACCONTROL26     0x30
+#define ES8388_DACCONTROL27     0x31
+#define ES8388_DACCONTROL28     0x32
+#define ES8388_DACCONTROL29     0x33
+#define ES8388_DACCONTROL30     0x34
+
+#define ES8388_IFACE            ES8388_MASTERMODE
+
+#define ES8388_ADC_IFACE        ES8388_ADCCONTROL4
+#define ES8388_ADC_SRATE        ES8388_ADCCONTROL5
+
+#define ES8388_DAC_IFACE        ES8388_DACCONTROL1
+#define ES8388_DAC_SRATE        ES8388_DACCONTROL2
+#endif
\ No newline at end of file
-- 
2.25.1

